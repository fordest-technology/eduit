
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model Teacher
 * 
 */
export type Teacher = $Result.DefaultSelection<Prisma.$TeacherPayload>
/**
 * Model Student
 * 
 */
export type Student = $Result.DefaultSelection<Prisma.$StudentPayload>
/**
 * Model Parent
 * 
 */
export type Parent = $Result.DefaultSelection<Prisma.$ParentPayload>
/**
 * Model School
 * 
 */
export type School = $Result.DefaultSelection<Prisma.$SchoolPayload>
/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model Class
 * 
 */
export type Class = $Result.DefaultSelection<Prisma.$ClassPayload>
/**
 * Model Subject
 * 
 */
export type Subject = $Result.DefaultSelection<Prisma.$SubjectPayload>
/**
 * Model AcademicSession
 * 
 */
export type AcademicSession = $Result.DefaultSelection<Prisma.$AcademicSessionPayload>
/**
 * Model StudentClass
 * 
 */
export type StudentClass = $Result.DefaultSelection<Prisma.$StudentClassPayload>
/**
 * Model StudentParent
 * 
 */
export type StudentParent = $Result.DefaultSelection<Prisma.$StudentParentPayload>
/**
 * Model SubjectTeacher
 * 
 */
export type SubjectTeacher = $Result.DefaultSelection<Prisma.$SubjectTeacherPayload>
/**
 * Model ClassSubject
 * 
 */
export type ClassSubject = $Result.DefaultSelection<Prisma.$ClassSubjectPayload>
/**
 * Model Attendance
 * 
 */
export type Attendance = $Result.DefaultSelection<Prisma.$AttendancePayload>
/**
 * Model Result
 * 
 */
export type Result = $Result.DefaultSelection<Prisma.$ResultPayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model StudentSubject
 * 
 */
export type StudentSubject = $Result.DefaultSelection<Prisma.$StudentSubjectPayload>
/**
 * Model Bill
 * 
 */
export type Bill = $Result.DefaultSelection<Prisma.$BillPayload>
/**
 * Model BillItem
 * 
 */
export type BillItem = $Result.DefaultSelection<Prisma.$BillItemPayload>
/**
 * Model PaymentAccount
 * 
 */
export type PaymentAccount = $Result.DefaultSelection<Prisma.$PaymentAccountPayload>
/**
 * Model BillAssignment
 * 
 */
export type BillAssignment = $Result.DefaultSelection<Prisma.$BillAssignmentPayload>
/**
 * Model StudentPayment
 * 
 */
export type StudentPayment = $Result.DefaultSelection<Prisma.$StudentPaymentPayload>
/**
 * Model PaymentRequest
 * 
 */
export type PaymentRequest = $Result.DefaultSelection<Prisma.$PaymentRequestPayload>
/**
 * Model SchoolLevel
 * 
 */
export type SchoolLevel = $Result.DefaultSelection<Prisma.$SchoolLevelPayload>
/**
 * Model UserActivityLog
 * 
 */
export type UserActivityLog = $Result.DefaultSelection<Prisma.$UserActivityLogPayload>
/**
 * Model ApiRequestLog
 * 
 */
export type ApiRequestLog = $Result.DefaultSelection<Prisma.$ApiRequestLogPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model ResultConfiguration
 * 
 */
export type ResultConfiguration = $Result.DefaultSelection<Prisma.$ResultConfigurationPayload>
/**
 * Model ResultPeriod
 * 
 */
export type ResultPeriod = $Result.DefaultSelection<Prisma.$ResultPeriodPayload>
/**
 * Model AssessmentComponent
 * 
 */
export type AssessmentComponent = $Result.DefaultSelection<Prisma.$AssessmentComponentPayload>
/**
 * Model GradingScale
 * 
 */
export type GradingScale = $Result.DefaultSelection<Prisma.$GradingScalePayload>
/**
 * Model ComponentScore
 * 
 */
export type ComponentScore = $Result.DefaultSelection<Prisma.$ComponentScorePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  SCHOOL_ADMIN: 'SCHOOL_ADMIN',
  TEACHER: 'TEACHER',
  STUDENT: 'STUDENT',
  PARENT: 'PARENT'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const AdminType: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  SCHOOL_ADMIN: 'SCHOOL_ADMIN'
};

export type AdminType = (typeof AdminType)[keyof typeof AdminType]


export const AttendanceStatus: {
  PRESENT: 'PRESENT',
  ABSENT: 'ABSENT',
  LATE: 'LATE',
  EXCUSED: 'EXCUSED'
};

export type AttendanceStatus = (typeof AttendanceStatus)[keyof typeof AttendanceStatus]


export const EnrollmentStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  TRANSFERRED: 'TRANSFERRED',
  GRADUATED: 'GRADUATED'
};

export type EnrollmentStatus = (typeof EnrollmentStatus)[keyof typeof EnrollmentStatus]


export const ExamType: {
  QUIZ: 'QUIZ',
  TEST: 'TEST',
  MIDTERM: 'MIDTERM',
  FINAL: 'FINAL'
};

export type ExamType = (typeof ExamType)[keyof typeof ExamType]


export const BillAssignmentType: {
  CLASS: 'CLASS',
  STUDENT: 'STUDENT'
};

export type BillAssignmentType = (typeof BillAssignmentType)[keyof typeof BillAssignmentType]


export const BillStatus: {
  PENDING: 'PENDING',
  PARTIALLY_PAID: 'PARTIALLY_PAID',
  PAID: 'PAID',
  OVERDUE: 'OVERDUE'
};

export type BillStatus = (typeof BillStatus)[keyof typeof BillStatus]


export const PaymentStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type AdminType = $Enums.AdminType

export const AdminType: typeof $Enums.AdminType

export type AttendanceStatus = $Enums.AttendanceStatus

export const AttendanceStatus: typeof $Enums.AttendanceStatus

export type EnrollmentStatus = $Enums.EnrollmentStatus

export const EnrollmentStatus: typeof $Enums.EnrollmentStatus

export type ExamType = $Enums.ExamType

export const ExamType: typeof $Enums.ExamType

export type BillAssignmentType = $Enums.BillAssignmentType

export const BillAssignmentType: typeof $Enums.BillAssignmentType

export type BillStatus = $Enums.BillStatus

export const BillStatus: typeof $Enums.BillStatus

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teacher`: Exposes CRUD operations for the **Teacher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teachers
    * const teachers = await prisma.teacher.findMany()
    * ```
    */
  get teacher(): Prisma.TeacherDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parent`: Exposes CRUD operations for the **Parent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parents
    * const parents = await prisma.parent.findMany()
    * ```
    */
  get parent(): Prisma.ParentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.school`: Exposes CRUD operations for the **School** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schools
    * const schools = await prisma.school.findMany()
    * ```
    */
  get school(): Prisma.SchoolDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.class`: Exposes CRUD operations for the **Class** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classes
    * const classes = await prisma.class.findMany()
    * ```
    */
  get class(): Prisma.ClassDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subject`: Exposes CRUD operations for the **Subject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subjects
    * const subjects = await prisma.subject.findMany()
    * ```
    */
  get subject(): Prisma.SubjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.academicSession`: Exposes CRUD operations for the **AcademicSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AcademicSessions
    * const academicSessions = await prisma.academicSession.findMany()
    * ```
    */
  get academicSession(): Prisma.AcademicSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentClass`: Exposes CRUD operations for the **StudentClass** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentClasses
    * const studentClasses = await prisma.studentClass.findMany()
    * ```
    */
  get studentClass(): Prisma.StudentClassDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentParent`: Exposes CRUD operations for the **StudentParent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentParents
    * const studentParents = await prisma.studentParent.findMany()
    * ```
    */
  get studentParent(): Prisma.StudentParentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subjectTeacher`: Exposes CRUD operations for the **SubjectTeacher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubjectTeachers
    * const subjectTeachers = await prisma.subjectTeacher.findMany()
    * ```
    */
  get subjectTeacher(): Prisma.SubjectTeacherDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.classSubject`: Exposes CRUD operations for the **ClassSubject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassSubjects
    * const classSubjects = await prisma.classSubject.findMany()
    * ```
    */
  get classSubject(): Prisma.ClassSubjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendance`: Exposes CRUD operations for the **Attendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendances
    * const attendances = await prisma.attendance.findMany()
    * ```
    */
  get attendance(): Prisma.AttendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.result`: Exposes CRUD operations for the **Result** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Results
    * const results = await prisma.result.findMany()
    * ```
    */
  get result(): Prisma.ResultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentSubject`: Exposes CRUD operations for the **StudentSubject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentSubjects
    * const studentSubjects = await prisma.studentSubject.findMany()
    * ```
    */
  get studentSubject(): Prisma.StudentSubjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bill`: Exposes CRUD operations for the **Bill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bills
    * const bills = await prisma.bill.findMany()
    * ```
    */
  get bill(): Prisma.BillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.billItem`: Exposes CRUD operations for the **BillItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BillItems
    * const billItems = await prisma.billItem.findMany()
    * ```
    */
  get billItem(): Prisma.BillItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentAccount`: Exposes CRUD operations for the **PaymentAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentAccounts
    * const paymentAccounts = await prisma.paymentAccount.findMany()
    * ```
    */
  get paymentAccount(): Prisma.PaymentAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.billAssignment`: Exposes CRUD operations for the **BillAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BillAssignments
    * const billAssignments = await prisma.billAssignment.findMany()
    * ```
    */
  get billAssignment(): Prisma.BillAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentPayment`: Exposes CRUD operations for the **StudentPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentPayments
    * const studentPayments = await prisma.studentPayment.findMany()
    * ```
    */
  get studentPayment(): Prisma.StudentPaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentRequest`: Exposes CRUD operations for the **PaymentRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentRequests
    * const paymentRequests = await prisma.paymentRequest.findMany()
    * ```
    */
  get paymentRequest(): Prisma.PaymentRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.schoolLevel`: Exposes CRUD operations for the **SchoolLevel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SchoolLevels
    * const schoolLevels = await prisma.schoolLevel.findMany()
    * ```
    */
  get schoolLevel(): Prisma.SchoolLevelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userActivityLog`: Exposes CRUD operations for the **UserActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserActivityLogs
    * const userActivityLogs = await prisma.userActivityLog.findMany()
    * ```
    */
  get userActivityLog(): Prisma.UserActivityLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apiRequestLog`: Exposes CRUD operations for the **ApiRequestLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiRequestLogs
    * const apiRequestLogs = await prisma.apiRequestLog.findMany()
    * ```
    */
  get apiRequestLog(): Prisma.ApiRequestLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resultConfiguration`: Exposes CRUD operations for the **ResultConfiguration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResultConfigurations
    * const resultConfigurations = await prisma.resultConfiguration.findMany()
    * ```
    */
  get resultConfiguration(): Prisma.ResultConfigurationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resultPeriod`: Exposes CRUD operations for the **ResultPeriod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResultPeriods
    * const resultPeriods = await prisma.resultPeriod.findMany()
    * ```
    */
  get resultPeriod(): Prisma.ResultPeriodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assessmentComponent`: Exposes CRUD operations for the **AssessmentComponent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssessmentComponents
    * const assessmentComponents = await prisma.assessmentComponent.findMany()
    * ```
    */
  get assessmentComponent(): Prisma.AssessmentComponentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gradingScale`: Exposes CRUD operations for the **GradingScale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GradingScales
    * const gradingScales = await prisma.gradingScale.findMany()
    * ```
    */
  get gradingScale(): Prisma.GradingScaleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.componentScore`: Exposes CRUD operations for the **ComponentScore** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ComponentScores
    * const componentScores = await prisma.componentScore.findMany()
    * ```
    */
  get componentScore(): Prisma.ComponentScoreDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.5.0
   * Query Engine version: 173f8d54f8d52e692c7e27e72a88314ec7aeff60
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Admin: 'Admin',
    Teacher: 'Teacher',
    Student: 'Student',
    Parent: 'Parent',
    School: 'School',
    Department: 'Department',
    Class: 'Class',
    Subject: 'Subject',
    AcademicSession: 'AcademicSession',
    StudentClass: 'StudentClass',
    StudentParent: 'StudentParent',
    SubjectTeacher: 'SubjectTeacher',
    ClassSubject: 'ClassSubject',
    Attendance: 'Attendance',
    Result: 'Result',
    Event: 'Event',
    StudentSubject: 'StudentSubject',
    Bill: 'Bill',
    BillItem: 'BillItem',
    PaymentAccount: 'PaymentAccount',
    BillAssignment: 'BillAssignment',
    StudentPayment: 'StudentPayment',
    PaymentRequest: 'PaymentRequest',
    SchoolLevel: 'SchoolLevel',
    UserActivityLog: 'UserActivityLog',
    ApiRequestLog: 'ApiRequestLog',
    Account: 'Account',
    Session: 'Session',
    ResultConfiguration: 'ResultConfiguration',
    ResultPeriod: 'ResultPeriod',
    AssessmentComponent: 'AssessmentComponent',
    GradingScale: 'GradingScale',
    ComponentScore: 'ComponentScore'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "admin" | "teacher" | "student" | "parent" | "school" | "department" | "class" | "subject" | "academicSession" | "studentClass" | "studentParent" | "subjectTeacher" | "classSubject" | "attendance" | "result" | "event" | "studentSubject" | "bill" | "billItem" | "paymentAccount" | "billAssignment" | "studentPayment" | "paymentRequest" | "schoolLevel" | "userActivityLog" | "apiRequestLog" | "account" | "session" | "resultConfiguration" | "resultPeriod" | "assessmentComponent" | "gradingScale" | "componentScore"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      Teacher: {
        payload: Prisma.$TeacherPayload<ExtArgs>
        fields: Prisma.TeacherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeacherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeacherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          findFirst: {
            args: Prisma.TeacherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeacherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          findMany: {
            args: Prisma.TeacherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>[]
          }
          create: {
            args: Prisma.TeacherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          createMany: {
            args: Prisma.TeacherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeacherCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>[]
          }
          delete: {
            args: Prisma.TeacherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          update: {
            args: Prisma.TeacherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          deleteMany: {
            args: Prisma.TeacherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeacherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeacherUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>[]
          }
          upsert: {
            args: Prisma.TeacherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          aggregate: {
            args: Prisma.TeacherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeacher>
          }
          groupBy: {
            args: Prisma.TeacherGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeacherGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeacherCountArgs<ExtArgs>
            result: $Utils.Optional<TeacherCountAggregateOutputType> | number
          }
        }
      }
      Student: {
        payload: Prisma.$StudentPayload<ExtArgs>
        fields: Prisma.StudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findFirst: {
            args: Prisma.StudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findMany: {
            args: Prisma.StudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          create: {
            args: Prisma.StudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          createMany: {
            args: Prisma.StudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          delete: {
            args: Prisma.StudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          update: {
            args: Prisma.StudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          deleteMany: {
            args: Prisma.StudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          upsert: {
            args: Prisma.StudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.StudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      Parent: {
        payload: Prisma.$ParentPayload<ExtArgs>
        fields: Prisma.ParentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          findFirst: {
            args: Prisma.ParentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          findMany: {
            args: Prisma.ParentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>[]
          }
          create: {
            args: Prisma.ParentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          createMany: {
            args: Prisma.ParentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>[]
          }
          delete: {
            args: Prisma.ParentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          update: {
            args: Prisma.ParentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          deleteMany: {
            args: Prisma.ParentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ParentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>[]
          }
          upsert: {
            args: Prisma.ParentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          aggregate: {
            args: Prisma.ParentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParent>
          }
          groupBy: {
            args: Prisma.ParentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParentCountArgs<ExtArgs>
            result: $Utils.Optional<ParentCountAggregateOutputType> | number
          }
        }
      }
      School: {
        payload: Prisma.$SchoolPayload<ExtArgs>
        fields: Prisma.SchoolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          findFirst: {
            args: Prisma.SchoolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          findMany: {
            args: Prisma.SchoolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          create: {
            args: Prisma.SchoolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          createMany: {
            args: Prisma.SchoolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchoolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          delete: {
            args: Prisma.SchoolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          update: {
            args: Prisma.SchoolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          deleteMany: {
            args: Prisma.SchoolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SchoolUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          upsert: {
            args: Prisma.SchoolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          aggregate: {
            args: Prisma.SchoolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchool>
          }
          groupBy: {
            args: Prisma.SchoolGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolCountAggregateOutputType> | number
          }
        }
      }
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepartmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      Class: {
        payload: Prisma.$ClassPayload<ExtArgs>
        fields: Prisma.ClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findFirst: {
            args: Prisma.ClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findMany: {
            args: Prisma.ClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          create: {
            args: Prisma.ClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          createMany: {
            args: Prisma.ClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          delete: {
            args: Prisma.ClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          update: {
            args: Prisma.ClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          deleteMany: {
            args: Prisma.ClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClassUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          upsert: {
            args: Prisma.ClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          aggregate: {
            args: Prisma.ClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClass>
          }
          groupBy: {
            args: Prisma.ClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassCountArgs<ExtArgs>
            result: $Utils.Optional<ClassCountAggregateOutputType> | number
          }
        }
      }
      Subject: {
        payload: Prisma.$SubjectPayload<ExtArgs>
        fields: Prisma.SubjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          findFirst: {
            args: Prisma.SubjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          findMany: {
            args: Prisma.SubjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          create: {
            args: Prisma.SubjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          createMany: {
            args: Prisma.SubjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          delete: {
            args: Prisma.SubjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          update: {
            args: Prisma.SubjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          deleteMany: {
            args: Prisma.SubjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          upsert: {
            args: Prisma.SubjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          aggregate: {
            args: Prisma.SubjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubject>
          }
          groupBy: {
            args: Prisma.SubjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubjectCountArgs<ExtArgs>
            result: $Utils.Optional<SubjectCountAggregateOutputType> | number
          }
        }
      }
      AcademicSession: {
        payload: Prisma.$AcademicSessionPayload<ExtArgs>
        fields: Prisma.AcademicSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AcademicSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AcademicSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSessionPayload>
          }
          findFirst: {
            args: Prisma.AcademicSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AcademicSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSessionPayload>
          }
          findMany: {
            args: Prisma.AcademicSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSessionPayload>[]
          }
          create: {
            args: Prisma.AcademicSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSessionPayload>
          }
          createMany: {
            args: Prisma.AcademicSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AcademicSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSessionPayload>[]
          }
          delete: {
            args: Prisma.AcademicSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSessionPayload>
          }
          update: {
            args: Prisma.AcademicSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSessionPayload>
          }
          deleteMany: {
            args: Prisma.AcademicSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AcademicSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AcademicSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSessionPayload>[]
          }
          upsert: {
            args: Prisma.AcademicSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSessionPayload>
          }
          aggregate: {
            args: Prisma.AcademicSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAcademicSession>
          }
          groupBy: {
            args: Prisma.AcademicSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AcademicSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AcademicSessionCountArgs<ExtArgs>
            result: $Utils.Optional<AcademicSessionCountAggregateOutputType> | number
          }
        }
      }
      StudentClass: {
        payload: Prisma.$StudentClassPayload<ExtArgs>
        fields: Prisma.StudentClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentClassPayload>
          }
          findFirst: {
            args: Prisma.StudentClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentClassPayload>
          }
          findMany: {
            args: Prisma.StudentClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentClassPayload>[]
          }
          create: {
            args: Prisma.StudentClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentClassPayload>
          }
          createMany: {
            args: Prisma.StudentClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentClassCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentClassPayload>[]
          }
          delete: {
            args: Prisma.StudentClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentClassPayload>
          }
          update: {
            args: Prisma.StudentClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentClassPayload>
          }
          deleteMany: {
            args: Prisma.StudentClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentClassUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentClassPayload>[]
          }
          upsert: {
            args: Prisma.StudentClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentClassPayload>
          }
          aggregate: {
            args: Prisma.StudentClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentClass>
          }
          groupBy: {
            args: Prisma.StudentClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentClassGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentClassCountArgs<ExtArgs>
            result: $Utils.Optional<StudentClassCountAggregateOutputType> | number
          }
        }
      }
      StudentParent: {
        payload: Prisma.$StudentParentPayload<ExtArgs>
        fields: Prisma.StudentParentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentParentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentParentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload>
          }
          findFirst: {
            args: Prisma.StudentParentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentParentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload>
          }
          findMany: {
            args: Prisma.StudentParentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload>[]
          }
          create: {
            args: Prisma.StudentParentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload>
          }
          createMany: {
            args: Prisma.StudentParentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentParentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload>[]
          }
          delete: {
            args: Prisma.StudentParentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload>
          }
          update: {
            args: Prisma.StudentParentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload>
          }
          deleteMany: {
            args: Prisma.StudentParentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentParentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentParentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload>[]
          }
          upsert: {
            args: Prisma.StudentParentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload>
          }
          aggregate: {
            args: Prisma.StudentParentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentParent>
          }
          groupBy: {
            args: Prisma.StudentParentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentParentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentParentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentParentCountAggregateOutputType> | number
          }
        }
      }
      SubjectTeacher: {
        payload: Prisma.$SubjectTeacherPayload<ExtArgs>
        fields: Prisma.SubjectTeacherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubjectTeacherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectTeacherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubjectTeacherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectTeacherPayload>
          }
          findFirst: {
            args: Prisma.SubjectTeacherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectTeacherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubjectTeacherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectTeacherPayload>
          }
          findMany: {
            args: Prisma.SubjectTeacherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectTeacherPayload>[]
          }
          create: {
            args: Prisma.SubjectTeacherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectTeacherPayload>
          }
          createMany: {
            args: Prisma.SubjectTeacherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubjectTeacherCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectTeacherPayload>[]
          }
          delete: {
            args: Prisma.SubjectTeacherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectTeacherPayload>
          }
          update: {
            args: Prisma.SubjectTeacherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectTeacherPayload>
          }
          deleteMany: {
            args: Prisma.SubjectTeacherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubjectTeacherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubjectTeacherUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectTeacherPayload>[]
          }
          upsert: {
            args: Prisma.SubjectTeacherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectTeacherPayload>
          }
          aggregate: {
            args: Prisma.SubjectTeacherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubjectTeacher>
          }
          groupBy: {
            args: Prisma.SubjectTeacherGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubjectTeacherGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubjectTeacherCountArgs<ExtArgs>
            result: $Utils.Optional<SubjectTeacherCountAggregateOutputType> | number
          }
        }
      }
      ClassSubject: {
        payload: Prisma.$ClassSubjectPayload<ExtArgs>
        fields: Prisma.ClassSubjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassSubjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSubjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassSubjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSubjectPayload>
          }
          findFirst: {
            args: Prisma.ClassSubjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSubjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassSubjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSubjectPayload>
          }
          findMany: {
            args: Prisma.ClassSubjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSubjectPayload>[]
          }
          create: {
            args: Prisma.ClassSubjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSubjectPayload>
          }
          createMany: {
            args: Prisma.ClassSubjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassSubjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSubjectPayload>[]
          }
          delete: {
            args: Prisma.ClassSubjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSubjectPayload>
          }
          update: {
            args: Prisma.ClassSubjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSubjectPayload>
          }
          deleteMany: {
            args: Prisma.ClassSubjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassSubjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClassSubjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSubjectPayload>[]
          }
          upsert: {
            args: Prisma.ClassSubjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSubjectPayload>
          }
          aggregate: {
            args: Prisma.ClassSubjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassSubject>
          }
          groupBy: {
            args: Prisma.ClassSubjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassSubjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassSubjectCountArgs<ExtArgs>
            result: $Utils.Optional<ClassSubjectCountAggregateOutputType> | number
          }
        }
      }
      Attendance: {
        payload: Prisma.$AttendancePayload<ExtArgs>
        fields: Prisma.AttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findFirst: {
            args: Prisma.AttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findMany: {
            args: Prisma.AttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          create: {
            args: Prisma.AttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          createMany: {
            args: Prisma.AttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          delete: {
            args: Prisma.AttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          update: {
            args: Prisma.AttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          deleteMany: {
            args: Prisma.AttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          upsert: {
            args: Prisma.AttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          aggregate: {
            args: Prisma.AttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendance>
          }
          groupBy: {
            args: Prisma.AttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceCountAggregateOutputType> | number
          }
        }
      }
      Result: {
        payload: Prisma.$ResultPayload<ExtArgs>
        fields: Prisma.ResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultPayload>
          }
          findFirst: {
            args: Prisma.ResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultPayload>
          }
          findMany: {
            args: Prisma.ResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultPayload>[]
          }
          create: {
            args: Prisma.ResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultPayload>
          }
          createMany: {
            args: Prisma.ResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultPayload>[]
          }
          delete: {
            args: Prisma.ResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultPayload>
          }
          update: {
            args: Prisma.ResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultPayload>
          }
          deleteMany: {
            args: Prisma.ResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResultUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultPayload>[]
          }
          upsert: {
            args: Prisma.ResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultPayload>
          }
          aggregate: {
            args: Prisma.ResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResult>
          }
          groupBy: {
            args: Prisma.ResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResultCountArgs<ExtArgs>
            result: $Utils.Optional<ResultCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      StudentSubject: {
        payload: Prisma.$StudentSubjectPayload<ExtArgs>
        fields: Prisma.StudentSubjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentSubjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSubjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentSubjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSubjectPayload>
          }
          findFirst: {
            args: Prisma.StudentSubjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSubjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentSubjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSubjectPayload>
          }
          findMany: {
            args: Prisma.StudentSubjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSubjectPayload>[]
          }
          create: {
            args: Prisma.StudentSubjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSubjectPayload>
          }
          createMany: {
            args: Prisma.StudentSubjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentSubjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSubjectPayload>[]
          }
          delete: {
            args: Prisma.StudentSubjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSubjectPayload>
          }
          update: {
            args: Prisma.StudentSubjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSubjectPayload>
          }
          deleteMany: {
            args: Prisma.StudentSubjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentSubjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentSubjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSubjectPayload>[]
          }
          upsert: {
            args: Prisma.StudentSubjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSubjectPayload>
          }
          aggregate: {
            args: Prisma.StudentSubjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentSubject>
          }
          groupBy: {
            args: Prisma.StudentSubjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentSubjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentSubjectCountArgs<ExtArgs>
            result: $Utils.Optional<StudentSubjectCountAggregateOutputType> | number
          }
        }
      }
      Bill: {
        payload: Prisma.$BillPayload<ExtArgs>
        fields: Prisma.BillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          findFirst: {
            args: Prisma.BillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          findMany: {
            args: Prisma.BillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>[]
          }
          create: {
            args: Prisma.BillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          createMany: {
            args: Prisma.BillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>[]
          }
          delete: {
            args: Prisma.BillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          update: {
            args: Prisma.BillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          deleteMany: {
            args: Prisma.BillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>[]
          }
          upsert: {
            args: Prisma.BillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          aggregate: {
            args: Prisma.BillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBill>
          }
          groupBy: {
            args: Prisma.BillGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillCountArgs<ExtArgs>
            result: $Utils.Optional<BillCountAggregateOutputType> | number
          }
        }
      }
      BillItem: {
        payload: Prisma.$BillItemPayload<ExtArgs>
        fields: Prisma.BillItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillItemPayload>
          }
          findFirst: {
            args: Prisma.BillItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillItemPayload>
          }
          findMany: {
            args: Prisma.BillItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillItemPayload>[]
          }
          create: {
            args: Prisma.BillItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillItemPayload>
          }
          createMany: {
            args: Prisma.BillItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillItemPayload>[]
          }
          delete: {
            args: Prisma.BillItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillItemPayload>
          }
          update: {
            args: Prisma.BillItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillItemPayload>
          }
          deleteMany: {
            args: Prisma.BillItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BillItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillItemPayload>[]
          }
          upsert: {
            args: Prisma.BillItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillItemPayload>
          }
          aggregate: {
            args: Prisma.BillItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBillItem>
          }
          groupBy: {
            args: Prisma.BillItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillItemCountArgs<ExtArgs>
            result: $Utils.Optional<BillItemCountAggregateOutputType> | number
          }
        }
      }
      PaymentAccount: {
        payload: Prisma.$PaymentAccountPayload<ExtArgs>
        fields: Prisma.PaymentAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAccountPayload>
          }
          findFirst: {
            args: Prisma.PaymentAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAccountPayload>
          }
          findMany: {
            args: Prisma.PaymentAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAccountPayload>[]
          }
          create: {
            args: Prisma.PaymentAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAccountPayload>
          }
          createMany: {
            args: Prisma.PaymentAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAccountPayload>[]
          }
          delete: {
            args: Prisma.PaymentAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAccountPayload>
          }
          update: {
            args: Prisma.PaymentAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAccountPayload>
          }
          deleteMany: {
            args: Prisma.PaymentAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAccountPayload>[]
          }
          upsert: {
            args: Prisma.PaymentAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAccountPayload>
          }
          aggregate: {
            args: Prisma.PaymentAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentAccount>
          }
          groupBy: {
            args: Prisma.PaymentAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentAccountCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentAccountCountAggregateOutputType> | number
          }
        }
      }
      BillAssignment: {
        payload: Prisma.$BillAssignmentPayload<ExtArgs>
        fields: Prisma.BillAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillAssignmentPayload>
          }
          findFirst: {
            args: Prisma.BillAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillAssignmentPayload>
          }
          findMany: {
            args: Prisma.BillAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillAssignmentPayload>[]
          }
          create: {
            args: Prisma.BillAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillAssignmentPayload>
          }
          createMany: {
            args: Prisma.BillAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillAssignmentPayload>[]
          }
          delete: {
            args: Prisma.BillAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillAssignmentPayload>
          }
          update: {
            args: Prisma.BillAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.BillAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BillAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.BillAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillAssignmentPayload>
          }
          aggregate: {
            args: Prisma.BillAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBillAssignment>
          }
          groupBy: {
            args: Prisma.BillAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<BillAssignmentCountAggregateOutputType> | number
          }
        }
      }
      StudentPayment: {
        payload: Prisma.$StudentPaymentPayload<ExtArgs>
        fields: Prisma.StudentPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPaymentPayload>
          }
          findFirst: {
            args: Prisma.StudentPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPaymentPayload>
          }
          findMany: {
            args: Prisma.StudentPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPaymentPayload>[]
          }
          create: {
            args: Prisma.StudentPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPaymentPayload>
          }
          createMany: {
            args: Prisma.StudentPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPaymentPayload>[]
          }
          delete: {
            args: Prisma.StudentPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPaymentPayload>
          }
          update: {
            args: Prisma.StudentPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPaymentPayload>
          }
          deleteMany: {
            args: Prisma.StudentPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentPaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPaymentPayload>[]
          }
          upsert: {
            args: Prisma.StudentPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPaymentPayload>
          }
          aggregate: {
            args: Prisma.StudentPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentPayment>
          }
          groupBy: {
            args: Prisma.StudentPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentPaymentCountAggregateOutputType> | number
          }
        }
      }
      PaymentRequest: {
        payload: Prisma.$PaymentRequestPayload<ExtArgs>
        fields: Prisma.PaymentRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRequestPayload>
          }
          findFirst: {
            args: Prisma.PaymentRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRequestPayload>
          }
          findMany: {
            args: Prisma.PaymentRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRequestPayload>[]
          }
          create: {
            args: Prisma.PaymentRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRequestPayload>
          }
          createMany: {
            args: Prisma.PaymentRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRequestPayload>[]
          }
          delete: {
            args: Prisma.PaymentRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRequestPayload>
          }
          update: {
            args: Prisma.PaymentRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRequestPayload>
          }
          deleteMany: {
            args: Prisma.PaymentRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRequestPayload>[]
          }
          upsert: {
            args: Prisma.PaymentRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRequestPayload>
          }
          aggregate: {
            args: Prisma.PaymentRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentRequest>
          }
          groupBy: {
            args: Prisma.PaymentRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentRequestCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentRequestCountAggregateOutputType> | number
          }
        }
      }
      SchoolLevel: {
        payload: Prisma.$SchoolLevelPayload<ExtArgs>
        fields: Prisma.SchoolLevelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolLevelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLevelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolLevelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLevelPayload>
          }
          findFirst: {
            args: Prisma.SchoolLevelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLevelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolLevelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLevelPayload>
          }
          findMany: {
            args: Prisma.SchoolLevelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLevelPayload>[]
          }
          create: {
            args: Prisma.SchoolLevelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLevelPayload>
          }
          createMany: {
            args: Prisma.SchoolLevelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchoolLevelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLevelPayload>[]
          }
          delete: {
            args: Prisma.SchoolLevelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLevelPayload>
          }
          update: {
            args: Prisma.SchoolLevelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLevelPayload>
          }
          deleteMany: {
            args: Prisma.SchoolLevelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolLevelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SchoolLevelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLevelPayload>[]
          }
          upsert: {
            args: Prisma.SchoolLevelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLevelPayload>
          }
          aggregate: {
            args: Prisma.SchoolLevelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchoolLevel>
          }
          groupBy: {
            args: Prisma.SchoolLevelGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolLevelGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolLevelCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolLevelCountAggregateOutputType> | number
          }
        }
      }
      UserActivityLog: {
        payload: Prisma.$UserActivityLogPayload<ExtArgs>
        fields: Prisma.UserActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityLogPayload>
          }
          findFirst: {
            args: Prisma.UserActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityLogPayload>
          }
          findMany: {
            args: Prisma.UserActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityLogPayload>[]
          }
          create: {
            args: Prisma.UserActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityLogPayload>
          }
          createMany: {
            args: Prisma.UserActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserActivityLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityLogPayload>[]
          }
          delete: {
            args: Prisma.UserActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityLogPayload>
          }
          update: {
            args: Prisma.UserActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.UserActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserActivityLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityLogPayload>[]
          }
          upsert: {
            args: Prisma.UserActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityLogPayload>
          }
          aggregate: {
            args: Prisma.UserActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserActivityLog>
          }
          groupBy: {
            args: Prisma.UserActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<UserActivityLogCountAggregateOutputType> | number
          }
        }
      }
      ApiRequestLog: {
        payload: Prisma.$ApiRequestLogPayload<ExtArgs>
        fields: Prisma.ApiRequestLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiRequestLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiRequestLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiRequestLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiRequestLogPayload>
          }
          findFirst: {
            args: Prisma.ApiRequestLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiRequestLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiRequestLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiRequestLogPayload>
          }
          findMany: {
            args: Prisma.ApiRequestLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiRequestLogPayload>[]
          }
          create: {
            args: Prisma.ApiRequestLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiRequestLogPayload>
          }
          createMany: {
            args: Prisma.ApiRequestLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiRequestLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiRequestLogPayload>[]
          }
          delete: {
            args: Prisma.ApiRequestLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiRequestLogPayload>
          }
          update: {
            args: Prisma.ApiRequestLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiRequestLogPayload>
          }
          deleteMany: {
            args: Prisma.ApiRequestLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiRequestLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApiRequestLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiRequestLogPayload>[]
          }
          upsert: {
            args: Prisma.ApiRequestLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiRequestLogPayload>
          }
          aggregate: {
            args: Prisma.ApiRequestLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiRequestLog>
          }
          groupBy: {
            args: Prisma.ApiRequestLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiRequestLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiRequestLogCountArgs<ExtArgs>
            result: $Utils.Optional<ApiRequestLogCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      ResultConfiguration: {
        payload: Prisma.$ResultConfigurationPayload<ExtArgs>
        fields: Prisma.ResultConfigurationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResultConfigurationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultConfigurationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResultConfigurationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultConfigurationPayload>
          }
          findFirst: {
            args: Prisma.ResultConfigurationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultConfigurationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResultConfigurationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultConfigurationPayload>
          }
          findMany: {
            args: Prisma.ResultConfigurationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultConfigurationPayload>[]
          }
          create: {
            args: Prisma.ResultConfigurationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultConfigurationPayload>
          }
          createMany: {
            args: Prisma.ResultConfigurationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResultConfigurationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultConfigurationPayload>[]
          }
          delete: {
            args: Prisma.ResultConfigurationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultConfigurationPayload>
          }
          update: {
            args: Prisma.ResultConfigurationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultConfigurationPayload>
          }
          deleteMany: {
            args: Prisma.ResultConfigurationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResultConfigurationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResultConfigurationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultConfigurationPayload>[]
          }
          upsert: {
            args: Prisma.ResultConfigurationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultConfigurationPayload>
          }
          aggregate: {
            args: Prisma.ResultConfigurationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResultConfiguration>
          }
          groupBy: {
            args: Prisma.ResultConfigurationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResultConfigurationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResultConfigurationCountArgs<ExtArgs>
            result: $Utils.Optional<ResultConfigurationCountAggregateOutputType> | number
          }
        }
      }
      ResultPeriod: {
        payload: Prisma.$ResultPeriodPayload<ExtArgs>
        fields: Prisma.ResultPeriodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResultPeriodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultPeriodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResultPeriodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultPeriodPayload>
          }
          findFirst: {
            args: Prisma.ResultPeriodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultPeriodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResultPeriodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultPeriodPayload>
          }
          findMany: {
            args: Prisma.ResultPeriodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultPeriodPayload>[]
          }
          create: {
            args: Prisma.ResultPeriodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultPeriodPayload>
          }
          createMany: {
            args: Prisma.ResultPeriodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResultPeriodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultPeriodPayload>[]
          }
          delete: {
            args: Prisma.ResultPeriodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultPeriodPayload>
          }
          update: {
            args: Prisma.ResultPeriodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultPeriodPayload>
          }
          deleteMany: {
            args: Prisma.ResultPeriodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResultPeriodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResultPeriodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultPeriodPayload>[]
          }
          upsert: {
            args: Prisma.ResultPeriodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultPeriodPayload>
          }
          aggregate: {
            args: Prisma.ResultPeriodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResultPeriod>
          }
          groupBy: {
            args: Prisma.ResultPeriodGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResultPeriodGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResultPeriodCountArgs<ExtArgs>
            result: $Utils.Optional<ResultPeriodCountAggregateOutputType> | number
          }
        }
      }
      AssessmentComponent: {
        payload: Prisma.$AssessmentComponentPayload<ExtArgs>
        fields: Prisma.AssessmentComponentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssessmentComponentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentComponentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssessmentComponentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentComponentPayload>
          }
          findFirst: {
            args: Prisma.AssessmentComponentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentComponentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssessmentComponentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentComponentPayload>
          }
          findMany: {
            args: Prisma.AssessmentComponentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentComponentPayload>[]
          }
          create: {
            args: Prisma.AssessmentComponentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentComponentPayload>
          }
          createMany: {
            args: Prisma.AssessmentComponentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssessmentComponentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentComponentPayload>[]
          }
          delete: {
            args: Prisma.AssessmentComponentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentComponentPayload>
          }
          update: {
            args: Prisma.AssessmentComponentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentComponentPayload>
          }
          deleteMany: {
            args: Prisma.AssessmentComponentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssessmentComponentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssessmentComponentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentComponentPayload>[]
          }
          upsert: {
            args: Prisma.AssessmentComponentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentComponentPayload>
          }
          aggregate: {
            args: Prisma.AssessmentComponentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssessmentComponent>
          }
          groupBy: {
            args: Prisma.AssessmentComponentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssessmentComponentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssessmentComponentCountArgs<ExtArgs>
            result: $Utils.Optional<AssessmentComponentCountAggregateOutputType> | number
          }
        }
      }
      GradingScale: {
        payload: Prisma.$GradingScalePayload<ExtArgs>
        fields: Prisma.GradingScaleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GradingScaleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradingScalePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GradingScaleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradingScalePayload>
          }
          findFirst: {
            args: Prisma.GradingScaleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradingScalePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GradingScaleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradingScalePayload>
          }
          findMany: {
            args: Prisma.GradingScaleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradingScalePayload>[]
          }
          create: {
            args: Prisma.GradingScaleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradingScalePayload>
          }
          createMany: {
            args: Prisma.GradingScaleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GradingScaleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradingScalePayload>[]
          }
          delete: {
            args: Prisma.GradingScaleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradingScalePayload>
          }
          update: {
            args: Prisma.GradingScaleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradingScalePayload>
          }
          deleteMany: {
            args: Prisma.GradingScaleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GradingScaleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GradingScaleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradingScalePayload>[]
          }
          upsert: {
            args: Prisma.GradingScaleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradingScalePayload>
          }
          aggregate: {
            args: Prisma.GradingScaleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGradingScale>
          }
          groupBy: {
            args: Prisma.GradingScaleGroupByArgs<ExtArgs>
            result: $Utils.Optional<GradingScaleGroupByOutputType>[]
          }
          count: {
            args: Prisma.GradingScaleCountArgs<ExtArgs>
            result: $Utils.Optional<GradingScaleCountAggregateOutputType> | number
          }
        }
      }
      ComponentScore: {
        payload: Prisma.$ComponentScorePayload<ExtArgs>
        fields: Prisma.ComponentScoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComponentScoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentScorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComponentScoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentScorePayload>
          }
          findFirst: {
            args: Prisma.ComponentScoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentScorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComponentScoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentScorePayload>
          }
          findMany: {
            args: Prisma.ComponentScoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentScorePayload>[]
          }
          create: {
            args: Prisma.ComponentScoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentScorePayload>
          }
          createMany: {
            args: Prisma.ComponentScoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComponentScoreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentScorePayload>[]
          }
          delete: {
            args: Prisma.ComponentScoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentScorePayload>
          }
          update: {
            args: Prisma.ComponentScoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentScorePayload>
          }
          deleteMany: {
            args: Prisma.ComponentScoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComponentScoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ComponentScoreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentScorePayload>[]
          }
          upsert: {
            args: Prisma.ComponentScoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentScorePayload>
          }
          aggregate: {
            args: Prisma.ComponentScoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComponentScore>
          }
          groupBy: {
            args: Prisma.ComponentScoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComponentScoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComponentScoreCountArgs<ExtArgs>
            result: $Utils.Optional<ComponentScoreCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    admin?: AdminOmit
    teacher?: TeacherOmit
    student?: StudentOmit
    parent?: ParentOmit
    school?: SchoolOmit
    department?: DepartmentOmit
    class?: ClassOmit
    subject?: SubjectOmit
    academicSession?: AcademicSessionOmit
    studentClass?: StudentClassOmit
    studentParent?: StudentParentOmit
    subjectTeacher?: SubjectTeacherOmit
    classSubject?: ClassSubjectOmit
    attendance?: AttendanceOmit
    result?: ResultOmit
    event?: EventOmit
    studentSubject?: StudentSubjectOmit
    bill?: BillOmit
    billItem?: BillItemOmit
    paymentAccount?: PaymentAccountOmit
    billAssignment?: BillAssignmentOmit
    studentPayment?: StudentPaymentOmit
    paymentRequest?: PaymentRequestOmit
    schoolLevel?: SchoolLevelOmit
    userActivityLog?: UserActivityLogOmit
    apiRequestLog?: ApiRequestLogOmit
    account?: AccountOmit
    session?: SessionOmit
    resultConfiguration?: ResultConfigurationOmit
    resultPeriod?: ResultPeriodOmit
    assessmentComponent?: AssessmentComponentOmit
    gradingScale?: GradingScaleOmit
    componentScore?: ComponentScoreOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    processedPayments: number
    approvedResults: number
    sessions: number
    activityLogs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    processedPayments?: boolean | UserCountOutputTypeCountProcessedPaymentsArgs
    approvedResults?: boolean | UserCountOutputTypeCountApprovedResultsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    activityLogs?: boolean | UserCountOutputTypeCountActivityLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProcessedPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovedResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResultWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserActivityLogWhereInput
  }


  /**
   * Count Type TeacherCountOutputType
   */

  export type TeacherCountOutputType = {
    classes: number
    subjects: number
  }

  export type TeacherCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | TeacherCountOutputTypeCountClassesArgs
    subjects?: boolean | TeacherCountOutputTypeCountSubjectsArgs
  }

  // Custom InputTypes
  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherCountOutputType
     */
    select?: TeacherCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectTeacherWhereInput
  }


  /**
   * Count Type StudentCountOutputType
   */

  export type StudentCountOutputType = {
    attendance: number
    paymentRequests: number
    results: number
    classes: number
    parents: number
    payments: number
    subjects: number
  }

  export type StudentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendance?: boolean | StudentCountOutputTypeCountAttendanceArgs
    paymentRequests?: boolean | StudentCountOutputTypeCountPaymentRequestsArgs
    results?: boolean | StudentCountOutputTypeCountResultsArgs
    classes?: boolean | StudentCountOutputTypeCountClassesArgs
    parents?: boolean | StudentCountOutputTypeCountParentsArgs
    payments?: boolean | StudentCountOutputTypeCountPaymentsArgs
    subjects?: boolean | StudentCountOutputTypeCountSubjectsArgs
  }

  // Custom InputTypes
  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountPaymentRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentRequestWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResultWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentClassWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountParentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentParentWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentPaymentWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSubjectWhereInput
  }


  /**
   * Count Type ParentCountOutputType
   */

  export type ParentCountOutputType = {
    children: number
  }

  export type ParentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | ParentCountOutputTypeCountChildrenArgs
  }

  // Custom InputTypes
  /**
   * ParentCountOutputType without action
   */
  export type ParentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentCountOutputType
     */
    select?: ParentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ParentCountOutputType without action
   */
  export type ParentCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentParentWhereInput
  }


  /**
   * Count Type SchoolCountOutputType
   */

  export type SchoolCountOutputType = {
    sessions: number
    bills: number
    classes: number
    departments: number
    events: number
    paymentAccounts: number
    levels: number
    subjects: number
    users: number
    resultConfigs: number
  }

  export type SchoolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | SchoolCountOutputTypeCountSessionsArgs
    bills?: boolean | SchoolCountOutputTypeCountBillsArgs
    classes?: boolean | SchoolCountOutputTypeCountClassesArgs
    departments?: boolean | SchoolCountOutputTypeCountDepartmentsArgs
    events?: boolean | SchoolCountOutputTypeCountEventsArgs
    paymentAccounts?: boolean | SchoolCountOutputTypeCountPaymentAccountsArgs
    levels?: boolean | SchoolCountOutputTypeCountLevelsArgs
    subjects?: boolean | SchoolCountOutputTypeCountSubjectsArgs
    users?: boolean | SchoolCountOutputTypeCountUsersArgs
    resultConfigs?: boolean | SchoolCountOutputTypeCountResultConfigsArgs
  }

  // Custom InputTypes
  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolCountOutputType
     */
    select?: SchoolCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicSessionWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountBillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountPaymentAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentAccountWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountLevelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolLevelWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountResultConfigsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResultConfigurationWhereInput
  }


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    students: number
    subjects: number
    teachers: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | DepartmentCountOutputTypeCountStudentsArgs
    subjects?: boolean | DepartmentCountOutputTypeCountSubjectsArgs
    teachers?: boolean | DepartmentCountOutputTypeCountTeachersArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountTeachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherWhereInput
  }


  /**
   * Count Type ClassCountOutputType
   */

  export type ClassCountOutputType = {
    subjects: number
    students: number
  }

  export type ClassCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subjects?: boolean | ClassCountOutputTypeCountSubjectsArgs
    students?: boolean | ClassCountOutputTypeCountStudentsArgs
  }

  // Custom InputTypes
  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassCountOutputType
     */
    select?: ClassCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassSubjectWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentClassWhereInput
  }


  /**
   * Count Type SubjectCountOutputType
   */

  export type SubjectCountOutputType = {
    classes: number
    results: number
    students: number
    teachers: number
  }

  export type SubjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | SubjectCountOutputTypeCountClassesArgs
    results?: boolean | SubjectCountOutputTypeCountResultsArgs
    students?: boolean | SubjectCountOutputTypeCountStudentsArgs
    teachers?: boolean | SubjectCountOutputTypeCountTeachersArgs
  }

  // Custom InputTypes
  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectCountOutputType
     */
    select?: SubjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassSubjectWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResultWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSubjectWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountTeachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectTeacherWhereInput
  }


  /**
   * Count Type AcademicSessionCountOutputType
   */

  export type AcademicSessionCountOutputType = {
    attendance: number
    results: number
    studentClasses: number
    resultConfigurations: number
  }

  export type AcademicSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendance?: boolean | AcademicSessionCountOutputTypeCountAttendanceArgs
    results?: boolean | AcademicSessionCountOutputTypeCountResultsArgs
    studentClasses?: boolean | AcademicSessionCountOutputTypeCountStudentClassesArgs
    resultConfigurations?: boolean | AcademicSessionCountOutputTypeCountResultConfigurationsArgs
  }

  // Custom InputTypes
  /**
   * AcademicSessionCountOutputType without action
   */
  export type AcademicSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSessionCountOutputType
     */
    select?: AcademicSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AcademicSessionCountOutputType without action
   */
  export type AcademicSessionCountOutputTypeCountAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * AcademicSessionCountOutputType without action
   */
  export type AcademicSessionCountOutputTypeCountResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResultWhereInput
  }

  /**
   * AcademicSessionCountOutputType without action
   */
  export type AcademicSessionCountOutputTypeCountStudentClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentClassWhereInput
  }

  /**
   * AcademicSessionCountOutputType without action
   */
  export type AcademicSessionCountOutputTypeCountResultConfigurationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResultConfigurationWhereInput
  }


  /**
   * Count Type ResultCountOutputType
   */

  export type ResultCountOutputType = {
    componentScores: number
  }

  export type ResultCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    componentScores?: boolean | ResultCountOutputTypeCountComponentScoresArgs
  }

  // Custom InputTypes
  /**
   * ResultCountOutputType without action
   */
  export type ResultCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultCountOutputType
     */
    select?: ResultCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ResultCountOutputType without action
   */
  export type ResultCountOutputTypeCountComponentScoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComponentScoreWhereInput
  }


  /**
   * Count Type BillCountOutputType
   */

  export type BillCountOutputType = {
    assignments: number
    items: number
    paymentRequests: number
  }

  export type BillCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | BillCountOutputTypeCountAssignmentsArgs
    items?: boolean | BillCountOutputTypeCountItemsArgs
    paymentRequests?: boolean | BillCountOutputTypeCountPaymentRequestsArgs
  }

  // Custom InputTypes
  /**
   * BillCountOutputType without action
   */
  export type BillCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillCountOutputType
     */
    select?: BillCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BillCountOutputType without action
   */
  export type BillCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillAssignmentWhereInput
  }

  /**
   * BillCountOutputType without action
   */
  export type BillCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillItemWhereInput
  }

  /**
   * BillCountOutputType without action
   */
  export type BillCountOutputTypeCountPaymentRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentRequestWhereInput
  }


  /**
   * Count Type PaymentAccountCountOutputType
   */

  export type PaymentAccountCountOutputType = {
    bills: number
  }

  export type PaymentAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bills?: boolean | PaymentAccountCountOutputTypeCountBillsArgs
  }

  // Custom InputTypes
  /**
   * PaymentAccountCountOutputType without action
   */
  export type PaymentAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAccountCountOutputType
     */
    select?: PaymentAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentAccountCountOutputType without action
   */
  export type PaymentAccountCountOutputTypeCountBillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillWhereInput
  }


  /**
   * Count Type BillAssignmentCountOutputType
   */

  export type BillAssignmentCountOutputType = {
    paymentRequests: number
    studentPayments: number
  }

  export type BillAssignmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paymentRequests?: boolean | BillAssignmentCountOutputTypeCountPaymentRequestsArgs
    studentPayments?: boolean | BillAssignmentCountOutputTypeCountStudentPaymentsArgs
  }

  // Custom InputTypes
  /**
   * BillAssignmentCountOutputType without action
   */
  export type BillAssignmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillAssignmentCountOutputType
     */
    select?: BillAssignmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BillAssignmentCountOutputType without action
   */
  export type BillAssignmentCountOutputTypeCountPaymentRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentRequestWhereInput
  }

  /**
   * BillAssignmentCountOutputType without action
   */
  export type BillAssignmentCountOutputTypeCountStudentPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentPaymentWhereInput
  }


  /**
   * Count Type StudentPaymentCountOutputType
   */

  export type StudentPaymentCountOutputType = {
    paymentRequests: number
  }

  export type StudentPaymentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paymentRequests?: boolean | StudentPaymentCountOutputTypeCountPaymentRequestsArgs
  }

  // Custom InputTypes
  /**
   * StudentPaymentCountOutputType without action
   */
  export type StudentPaymentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentPaymentCountOutputType
     */
    select?: StudentPaymentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentPaymentCountOutputType without action
   */
  export type StudentPaymentCountOutputTypeCountPaymentRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentRequestWhereInput
  }


  /**
   * Count Type SchoolLevelCountOutputType
   */

  export type SchoolLevelCountOutputType = {
    classes: number
    subjects: number
  }

  export type SchoolLevelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | SchoolLevelCountOutputTypeCountClassesArgs
    subjects?: boolean | SchoolLevelCountOutputTypeCountSubjectsArgs
  }

  // Custom InputTypes
  /**
   * SchoolLevelCountOutputType without action
   */
  export type SchoolLevelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLevelCountOutputType
     */
    select?: SchoolLevelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SchoolLevelCountOutputType without action
   */
  export type SchoolLevelCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }

  /**
   * SchoolLevelCountOutputType without action
   */
  export type SchoolLevelCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
  }


  /**
   * Count Type ResultConfigurationCountOutputType
   */

  export type ResultConfigurationCountOutputType = {
    periods: number
    assessmentComponents: number
    gradingScale: number
  }

  export type ResultConfigurationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    periods?: boolean | ResultConfigurationCountOutputTypeCountPeriodsArgs
    assessmentComponents?: boolean | ResultConfigurationCountOutputTypeCountAssessmentComponentsArgs
    gradingScale?: boolean | ResultConfigurationCountOutputTypeCountGradingScaleArgs
  }

  // Custom InputTypes
  /**
   * ResultConfigurationCountOutputType without action
   */
  export type ResultConfigurationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultConfigurationCountOutputType
     */
    select?: ResultConfigurationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ResultConfigurationCountOutputType without action
   */
  export type ResultConfigurationCountOutputTypeCountPeriodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResultPeriodWhereInput
  }

  /**
   * ResultConfigurationCountOutputType without action
   */
  export type ResultConfigurationCountOutputTypeCountAssessmentComponentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssessmentComponentWhereInput
  }

  /**
   * ResultConfigurationCountOutputType without action
   */
  export type ResultConfigurationCountOutputTypeCountGradingScaleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradingScaleWhereInput
  }


  /**
   * Count Type ResultPeriodCountOutputType
   */

  export type ResultPeriodCountOutputType = {
    results: number
  }

  export type ResultPeriodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    results?: boolean | ResultPeriodCountOutputTypeCountResultsArgs
  }

  // Custom InputTypes
  /**
   * ResultPeriodCountOutputType without action
   */
  export type ResultPeriodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultPeriodCountOutputType
     */
    select?: ResultPeriodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ResultPeriodCountOutputType without action
   */
  export type ResultPeriodCountOutputTypeCountResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResultWhereInput
  }


  /**
   * Count Type AssessmentComponentCountOutputType
   */

  export type AssessmentComponentCountOutputType = {
    scores: number
  }

  export type AssessmentComponentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scores?: boolean | AssessmentComponentCountOutputTypeCountScoresArgs
  }

  // Custom InputTypes
  /**
   * AssessmentComponentCountOutputType without action
   */
  export type AssessmentComponentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentComponentCountOutputType
     */
    select?: AssessmentComponentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AssessmentComponentCountOutputType without action
   */
  export type AssessmentComponentCountOutputTypeCountScoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComponentScoreWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    role: $Enums.UserRole | null
    profileImage: string | null
    createdAt: Date | null
    updatedAt: Date | null
    emailVerified: Date | null
    image: string | null
    schoolId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    role: $Enums.UserRole | null
    profileImage: string | null
    createdAt: Date | null
    updatedAt: Date | null
    emailVerified: Date | null
    image: string | null
    schoolId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    role: number
    profileImage: number
    createdAt: number
    updatedAt: number
    emailVerified: number
    image: number
    schoolId: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    profileImage?: true
    createdAt?: true
    updatedAt?: true
    emailVerified?: true
    image?: true
    schoolId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    profileImage?: true
    createdAt?: true
    updatedAt?: true
    emailVerified?: true
    image?: true
    schoolId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    profileImage?: true
    createdAt?: true
    updatedAt?: true
    emailVerified?: true
    image?: true
    schoolId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    password: string
    role: $Enums.UserRole
    profileImage: string | null
    createdAt: Date
    updatedAt: Date
    emailVerified: Date | null
    image: string | null
    schoolId: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    profileImage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emailVerified?: boolean
    image?: boolean
    schoolId?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    admin?: boolean | User$adminArgs<ExtArgs>
    parent?: boolean | User$parentArgs<ExtArgs>
    processedPayments?: boolean | User$processedPaymentsArgs<ExtArgs>
    approvedResults?: boolean | User$approvedResultsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    student?: boolean | User$studentArgs<ExtArgs>
    teacher?: boolean | User$teacherArgs<ExtArgs>
    school?: boolean | User$schoolArgs<ExtArgs>
    activityLogs?: boolean | User$activityLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    profileImage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emailVerified?: boolean
    image?: boolean
    schoolId?: boolean
    school?: boolean | User$schoolArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    profileImage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emailVerified?: boolean
    image?: boolean
    schoolId?: boolean
    school?: boolean | User$schoolArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    profileImage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emailVerified?: boolean
    image?: boolean
    schoolId?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password" | "role" | "profileImage" | "createdAt" | "updatedAt" | "emailVerified" | "image" | "schoolId", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    admin?: boolean | User$adminArgs<ExtArgs>
    parent?: boolean | User$parentArgs<ExtArgs>
    processedPayments?: boolean | User$processedPaymentsArgs<ExtArgs>
    approvedResults?: boolean | User$approvedResultsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    student?: boolean | User$studentArgs<ExtArgs>
    teacher?: boolean | User$teacherArgs<ExtArgs>
    school?: boolean | User$schoolArgs<ExtArgs>
    activityLogs?: boolean | User$activityLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | User$schoolArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | User$schoolArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      admin: Prisma.$AdminPayload<ExtArgs> | null
      parent: Prisma.$ParentPayload<ExtArgs> | null
      processedPayments: Prisma.$PaymentRequestPayload<ExtArgs>[]
      approvedResults: Prisma.$ResultPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      student: Prisma.$StudentPayload<ExtArgs> | null
      teacher: Prisma.$TeacherPayload<ExtArgs> | null
      school: Prisma.$SchoolPayload<ExtArgs> | null
      activityLogs: Prisma.$UserActivityLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      password: string
      role: $Enums.UserRole
      profileImage: string | null
      createdAt: Date
      updatedAt: Date
      emailVerified: Date | null
      image: string | null
      schoolId: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    admin<T extends User$adminArgs<ExtArgs> = {}>(args?: Subset<T, User$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    parent<T extends User$parentArgs<ExtArgs> = {}>(args?: Subset<T, User$parentArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    processedPayments<T extends User$processedPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$processedPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approvedResults<T extends User$approvedResultsArgs<ExtArgs> = {}>(args?: Subset<T, User$approvedResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    student<T extends User$studentArgs<ExtArgs> = {}>(args?: Subset<T, User$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    teacher<T extends User$teacherArgs<ExtArgs> = {}>(args?: Subset<T, User$teacherArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    school<T extends User$schoolArgs<ExtArgs> = {}>(args?: Subset<T, User$schoolArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    activityLogs<T extends User$activityLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$activityLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly profileImage: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
    readonly schoolId: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.admin
   */
  export type User$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * User.parent
   */
  export type User$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    where?: ParentWhereInput
  }

  /**
   * User.processedPayments
   */
  export type User$processedPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRequest
     */
    select?: PaymentRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRequest
     */
    omit?: PaymentRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRequestInclude<ExtArgs> | null
    where?: PaymentRequestWhereInput
    orderBy?: PaymentRequestOrderByWithRelationInput | PaymentRequestOrderByWithRelationInput[]
    cursor?: PaymentRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentRequestScalarFieldEnum | PaymentRequestScalarFieldEnum[]
  }

  /**
   * User.approvedResults
   */
  export type User$approvedResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Result
     */
    select?: ResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Result
     */
    omit?: ResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultInclude<ExtArgs> | null
    where?: ResultWhereInput
    orderBy?: ResultOrderByWithRelationInput | ResultOrderByWithRelationInput[]
    cursor?: ResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResultScalarFieldEnum | ResultScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.student
   */
  export type User$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * User.teacher
   */
  export type User$teacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    where?: TeacherWhereInput
  }

  /**
   * User.school
   */
  export type User$schoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    where?: SchoolWhereInput
  }

  /**
   * User.activityLogs
   */
  export type User$activityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivityLog
     */
    select?: UserActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivityLog
     */
    omit?: UserActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityLogInclude<ExtArgs> | null
    where?: UserActivityLogWhereInput
    orderBy?: UserActivityLogOrderByWithRelationInput | UserActivityLogOrderByWithRelationInput[]
    cursor?: UserActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserActivityLogScalarFieldEnum | UserActivityLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminMinAggregateOutputType = {
    id: string | null
    userId: string | null
    adminType: $Enums.AdminType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    adminType: $Enums.AdminType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    userId: number
    adminType: number
    permissions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminMinAggregateInputType = {
    id?: true
    userId?: true
    adminType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    userId?: true
    adminType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    userId?: true
    adminType?: true
    permissions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: string
    userId: string
    adminType: $Enums.AdminType
    permissions: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    adminType?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    adminType?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    adminType?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    userId?: boolean
    adminType?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "adminType" | "permissions" | "createdAt" | "updatedAt", ExtArgs["result"]["admin"]>
  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      adminType: $Enums.AdminType
      permissions: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {AdminUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */ 
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'String'>
    readonly userId: FieldRef<"Admin", 'String'>
    readonly adminType: FieldRef<"Admin", 'AdminType'>
    readonly permissions: FieldRef<"Admin", 'Json'>
    readonly createdAt: FieldRef<"Admin", 'DateTime'>
    readonly updatedAt: FieldRef<"Admin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin updateManyAndReturn
   */
  export type AdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model Teacher
   */

  export type AggregateTeacher = {
    _count: TeacherCountAggregateOutputType | null
    _min: TeacherMinAggregateOutputType | null
    _max: TeacherMaxAggregateOutputType | null
  }

  export type TeacherMinAggregateOutputType = {
    id: string | null
    userId: string | null
    employeeId: string | null
    qualifications: string | null
    specialization: string | null
    joiningDate: Date | null
    departmentId: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    phone: string | null
    dateOfBirth: Date | null
    gender: string | null
    emergencyContact: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeacherMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    employeeId: string | null
    qualifications: string | null
    specialization: string | null
    joiningDate: Date | null
    departmentId: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    phone: string | null
    dateOfBirth: Date | null
    gender: string | null
    emergencyContact: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeacherCountAggregateOutputType = {
    id: number
    userId: number
    employeeId: number
    qualifications: number
    specialization: number
    joiningDate: number
    departmentId: number
    address: number
    city: number
    state: number
    country: number
    phone: number
    dateOfBirth: number
    gender: number
    emergencyContact: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeacherMinAggregateInputType = {
    id?: true
    userId?: true
    employeeId?: true
    qualifications?: true
    specialization?: true
    joiningDate?: true
    departmentId?: true
    address?: true
    city?: true
    state?: true
    country?: true
    phone?: true
    dateOfBirth?: true
    gender?: true
    emergencyContact?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeacherMaxAggregateInputType = {
    id?: true
    userId?: true
    employeeId?: true
    qualifications?: true
    specialization?: true
    joiningDate?: true
    departmentId?: true
    address?: true
    city?: true
    state?: true
    country?: true
    phone?: true
    dateOfBirth?: true
    gender?: true
    emergencyContact?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeacherCountAggregateInputType = {
    id?: true
    userId?: true
    employeeId?: true
    qualifications?: true
    specialization?: true
    joiningDate?: true
    departmentId?: true
    address?: true
    city?: true
    state?: true
    country?: true
    phone?: true
    dateOfBirth?: true
    gender?: true
    emergencyContact?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeacherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teacher to aggregate.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teachers
    **/
    _count?: true | TeacherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherMaxAggregateInputType
  }

  export type GetTeacherAggregateType<T extends TeacherAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacher[P]>
      : GetScalarType<T[P], AggregateTeacher[P]>
  }




  export type TeacherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherWhereInput
    orderBy?: TeacherOrderByWithAggregationInput | TeacherOrderByWithAggregationInput[]
    by: TeacherScalarFieldEnum[] | TeacherScalarFieldEnum
    having?: TeacherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherCountAggregateInputType | true
    _min?: TeacherMinAggregateInputType
    _max?: TeacherMaxAggregateInputType
  }

  export type TeacherGroupByOutputType = {
    id: string
    userId: string
    employeeId: string | null
    qualifications: string | null
    specialization: string | null
    joiningDate: Date | null
    departmentId: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    phone: string | null
    dateOfBirth: Date | null
    gender: string | null
    emergencyContact: string | null
    createdAt: Date
    updatedAt: Date
    _count: TeacherCountAggregateOutputType | null
    _min: TeacherMinAggregateOutputType | null
    _max: TeacherMaxAggregateOutputType | null
  }

  type GetTeacherGroupByPayload<T extends TeacherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeacherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherGroupByOutputType[P]>
        }
      >
    >


  export type TeacherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    employeeId?: boolean
    qualifications?: boolean
    specialization?: boolean
    joiningDate?: boolean
    departmentId?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    phone?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    emergencyContact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    classes?: boolean | Teacher$classesArgs<ExtArgs>
    subjects?: boolean | Teacher$subjectsArgs<ExtArgs>
    department?: boolean | Teacher$departmentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | TeacherCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacher"]>

  export type TeacherSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    employeeId?: boolean
    qualifications?: boolean
    specialization?: boolean
    joiningDate?: boolean
    departmentId?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    phone?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    emergencyContact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | Teacher$departmentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacher"]>

  export type TeacherSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    employeeId?: boolean
    qualifications?: boolean
    specialization?: boolean
    joiningDate?: boolean
    departmentId?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    phone?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    emergencyContact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | Teacher$departmentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacher"]>

  export type TeacherSelectScalar = {
    id?: boolean
    userId?: boolean
    employeeId?: boolean
    qualifications?: boolean
    specialization?: boolean
    joiningDate?: boolean
    departmentId?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    phone?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    emergencyContact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeacherOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "employeeId" | "qualifications" | "specialization" | "joiningDate" | "departmentId" | "address" | "city" | "state" | "country" | "phone" | "dateOfBirth" | "gender" | "emergencyContact" | "createdAt" | "updatedAt", ExtArgs["result"]["teacher"]>
  export type TeacherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | Teacher$classesArgs<ExtArgs>
    subjects?: boolean | Teacher$subjectsArgs<ExtArgs>
    department?: boolean | Teacher$departmentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | TeacherCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeacherIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Teacher$departmentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TeacherIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Teacher$departmentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TeacherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Teacher"
    objects: {
      classes: Prisma.$ClassPayload<ExtArgs>[]
      subjects: Prisma.$SubjectTeacherPayload<ExtArgs>[]
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      employeeId: string | null
      qualifications: string | null
      specialization: string | null
      joiningDate: Date | null
      departmentId: string | null
      address: string | null
      city: string | null
      state: string | null
      country: string | null
      phone: string | null
      dateOfBirth: Date | null
      gender: string | null
      emergencyContact: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["teacher"]>
    composites: {}
  }

  type TeacherGetPayload<S extends boolean | null | undefined | TeacherDefaultArgs> = $Result.GetResult<Prisma.$TeacherPayload, S>

  type TeacherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeacherFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeacherCountAggregateInputType | true
    }

  export interface TeacherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Teacher'], meta: { name: 'Teacher' } }
    /**
     * Find zero or one Teacher that matches the filter.
     * @param {TeacherFindUniqueArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeacherFindUniqueArgs>(args: SelectSubset<T, TeacherFindUniqueArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Teacher that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeacherFindUniqueOrThrowArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeacherFindUniqueOrThrowArgs>(args: SelectSubset<T, TeacherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teacher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindFirstArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeacherFindFirstArgs>(args?: SelectSubset<T, TeacherFindFirstArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teacher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindFirstOrThrowArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeacherFindFirstOrThrowArgs>(args?: SelectSubset<T, TeacherFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teachers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teachers
     * const teachers = await prisma.teacher.findMany()
     * 
     * // Get first 10 Teachers
     * const teachers = await prisma.teacher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacherWithIdOnly = await prisma.teacher.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeacherFindManyArgs>(args?: SelectSubset<T, TeacherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Teacher.
     * @param {TeacherCreateArgs} args - Arguments to create a Teacher.
     * @example
     * // Create one Teacher
     * const Teacher = await prisma.teacher.create({
     *   data: {
     *     // ... data to create a Teacher
     *   }
     * })
     * 
     */
    create<T extends TeacherCreateArgs>(args: SelectSubset<T, TeacherCreateArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teachers.
     * @param {TeacherCreateManyArgs} args - Arguments to create many Teachers.
     * @example
     * // Create many Teachers
     * const teacher = await prisma.teacher.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeacherCreateManyArgs>(args?: SelectSubset<T, TeacherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teachers and returns the data saved in the database.
     * @param {TeacherCreateManyAndReturnArgs} args - Arguments to create many Teachers.
     * @example
     * // Create many Teachers
     * const teacher = await prisma.teacher.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teachers and only return the `id`
     * const teacherWithIdOnly = await prisma.teacher.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeacherCreateManyAndReturnArgs>(args?: SelectSubset<T, TeacherCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Teacher.
     * @param {TeacherDeleteArgs} args - Arguments to delete one Teacher.
     * @example
     * // Delete one Teacher
     * const Teacher = await prisma.teacher.delete({
     *   where: {
     *     // ... filter to delete one Teacher
     *   }
     * })
     * 
     */
    delete<T extends TeacherDeleteArgs>(args: SelectSubset<T, TeacherDeleteArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Teacher.
     * @param {TeacherUpdateArgs} args - Arguments to update one Teacher.
     * @example
     * // Update one Teacher
     * const teacher = await prisma.teacher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeacherUpdateArgs>(args: SelectSubset<T, TeacherUpdateArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teachers.
     * @param {TeacherDeleteManyArgs} args - Arguments to filter Teachers to delete.
     * @example
     * // Delete a few Teachers
     * const { count } = await prisma.teacher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeacherDeleteManyArgs>(args?: SelectSubset<T, TeacherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teachers
     * const teacher = await prisma.teacher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeacherUpdateManyArgs>(args: SelectSubset<T, TeacherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers and returns the data updated in the database.
     * @param {TeacherUpdateManyAndReturnArgs} args - Arguments to update many Teachers.
     * @example
     * // Update many Teachers
     * const teacher = await prisma.teacher.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teachers and only return the `id`
     * const teacherWithIdOnly = await prisma.teacher.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeacherUpdateManyAndReturnArgs>(args: SelectSubset<T, TeacherUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Teacher.
     * @param {TeacherUpsertArgs} args - Arguments to update or create a Teacher.
     * @example
     * // Update or create a Teacher
     * const teacher = await prisma.teacher.upsert({
     *   create: {
     *     // ... data to create a Teacher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teacher we want to update
     *   }
     * })
     */
    upsert<T extends TeacherUpsertArgs>(args: SelectSubset<T, TeacherUpsertArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherCountArgs} args - Arguments to filter Teachers to count.
     * @example
     * // Count the number of Teachers
     * const count = await prisma.teacher.count({
     *   where: {
     *     // ... the filter for the Teachers we want to count
     *   }
     * })
    **/
    count<T extends TeacherCountArgs>(
      args?: Subset<T, TeacherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherAggregateArgs>(args: Subset<T, TeacherAggregateArgs>): Prisma.PrismaPromise<GetTeacherAggregateType<T>>

    /**
     * Group by Teacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherGroupByArgs['orderBy'] }
        : { orderBy?: TeacherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Teacher model
   */
  readonly fields: TeacherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Teacher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeacherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classes<T extends Teacher$classesArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subjects<T extends Teacher$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectTeacherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    department<T extends Teacher$departmentArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Teacher model
   */ 
  interface TeacherFieldRefs {
    readonly id: FieldRef<"Teacher", 'String'>
    readonly userId: FieldRef<"Teacher", 'String'>
    readonly employeeId: FieldRef<"Teacher", 'String'>
    readonly qualifications: FieldRef<"Teacher", 'String'>
    readonly specialization: FieldRef<"Teacher", 'String'>
    readonly joiningDate: FieldRef<"Teacher", 'DateTime'>
    readonly departmentId: FieldRef<"Teacher", 'String'>
    readonly address: FieldRef<"Teacher", 'String'>
    readonly city: FieldRef<"Teacher", 'String'>
    readonly state: FieldRef<"Teacher", 'String'>
    readonly country: FieldRef<"Teacher", 'String'>
    readonly phone: FieldRef<"Teacher", 'String'>
    readonly dateOfBirth: FieldRef<"Teacher", 'DateTime'>
    readonly gender: FieldRef<"Teacher", 'String'>
    readonly emergencyContact: FieldRef<"Teacher", 'String'>
    readonly createdAt: FieldRef<"Teacher", 'DateTime'>
    readonly updatedAt: FieldRef<"Teacher", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Teacher findUnique
   */
  export type TeacherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher findUniqueOrThrow
   */
  export type TeacherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher findFirst
   */
  export type TeacherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachers.
     */
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Teacher findFirstOrThrow
   */
  export type TeacherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachers.
     */
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Teacher findMany
   */
  export type TeacherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teachers to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Teacher create
   */
  export type TeacherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The data needed to create a Teacher.
     */
    data: XOR<TeacherCreateInput, TeacherUncheckedCreateInput>
  }

  /**
   * Teacher createMany
   */
  export type TeacherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teachers.
     */
    data: TeacherCreateManyInput | TeacherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Teacher createManyAndReturn
   */
  export type TeacherCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * The data used to create many Teachers.
     */
    data: TeacherCreateManyInput | TeacherCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Teacher update
   */
  export type TeacherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The data needed to update a Teacher.
     */
    data: XOR<TeacherUpdateInput, TeacherUncheckedUpdateInput>
    /**
     * Choose, which Teacher to update.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher updateMany
   */
  export type TeacherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teachers.
     */
    data: XOR<TeacherUpdateManyMutationInput, TeacherUncheckedUpdateManyInput>
    /**
     * Filter which Teachers to update
     */
    where?: TeacherWhereInput
    /**
     * Limit how many Teachers to update.
     */
    limit?: number
  }

  /**
   * Teacher updateManyAndReturn
   */
  export type TeacherUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * The data used to update Teachers.
     */
    data: XOR<TeacherUpdateManyMutationInput, TeacherUncheckedUpdateManyInput>
    /**
     * Filter which Teachers to update
     */
    where?: TeacherWhereInput
    /**
     * Limit how many Teachers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Teacher upsert
   */
  export type TeacherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The filter to search for the Teacher to update in case it exists.
     */
    where: TeacherWhereUniqueInput
    /**
     * In case the Teacher found by the `where` argument doesn't exist, create a new Teacher with this data.
     */
    create: XOR<TeacherCreateInput, TeacherUncheckedCreateInput>
    /**
     * In case the Teacher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherUpdateInput, TeacherUncheckedUpdateInput>
  }

  /**
   * Teacher delete
   */
  export type TeacherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter which Teacher to delete.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher deleteMany
   */
  export type TeacherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teachers to delete
     */
    where?: TeacherWhereInput
    /**
     * Limit how many Teachers to delete.
     */
    limit?: number
  }

  /**
   * Teacher.classes
   */
  export type Teacher$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Teacher.subjects
   */
  export type Teacher$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectTeacher
     */
    select?: SubjectTeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubjectTeacher
     */
    omit?: SubjectTeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectTeacherInclude<ExtArgs> | null
    where?: SubjectTeacherWhereInput
    orderBy?: SubjectTeacherOrderByWithRelationInput | SubjectTeacherOrderByWithRelationInput[]
    cursor?: SubjectTeacherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectTeacherScalarFieldEnum | SubjectTeacherScalarFieldEnum[]
  }

  /**
   * Teacher.department
   */
  export type Teacher$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Teacher without action
   */
  export type TeacherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
  }


  /**
   * Model Student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    admissionDate: Date | null
    departmentId: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    phone: string | null
    dateOfBirth: Date | null
    gender: string | null
    religion: string | null
    bloodGroup: string | null
    createdAt: Date | null
    updatedAt: Date | null
    classId: string | null
  }

  export type StudentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    admissionDate: Date | null
    departmentId: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    phone: string | null
    dateOfBirth: Date | null
    gender: string | null
    religion: string | null
    bloodGroup: string | null
    createdAt: Date | null
    updatedAt: Date | null
    classId: string | null
  }

  export type StudentCountAggregateOutputType = {
    id: number
    userId: number
    admissionDate: number
    departmentId: number
    address: number
    city: number
    state: number
    country: number
    phone: number
    dateOfBirth: number
    gender: number
    religion: number
    bloodGroup: number
    createdAt: number
    updatedAt: number
    classId: number
    _all: number
  }


  export type StudentMinAggregateInputType = {
    id?: true
    userId?: true
    admissionDate?: true
    departmentId?: true
    address?: true
    city?: true
    state?: true
    country?: true
    phone?: true
    dateOfBirth?: true
    gender?: true
    religion?: true
    bloodGroup?: true
    createdAt?: true
    updatedAt?: true
    classId?: true
  }

  export type StudentMaxAggregateInputType = {
    id?: true
    userId?: true
    admissionDate?: true
    departmentId?: true
    address?: true
    city?: true
    state?: true
    country?: true
    phone?: true
    dateOfBirth?: true
    gender?: true
    religion?: true
    bloodGroup?: true
    createdAt?: true
    updatedAt?: true
    classId?: true
  }

  export type StudentCountAggregateInputType = {
    id?: true
    userId?: true
    admissionDate?: true
    departmentId?: true
    address?: true
    city?: true
    state?: true
    country?: true
    phone?: true
    dateOfBirth?: true
    gender?: true
    religion?: true
    bloodGroup?: true
    createdAt?: true
    updatedAt?: true
    classId?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithAggregationInput | StudentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    id: string
    userId: string
    admissionDate: Date | null
    departmentId: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    phone: string | null
    dateOfBirth: Date | null
    gender: string | null
    religion: string | null
    bloodGroup: string | null
    createdAt: Date
    updatedAt: Date
    classId: string | null
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    admissionDate?: boolean
    departmentId?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    phone?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    religion?: boolean
    bloodGroup?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    classId?: boolean
    attendance?: boolean | Student$attendanceArgs<ExtArgs>
    paymentRequests?: boolean | Student$paymentRequestsArgs<ExtArgs>
    results?: boolean | Student$resultsArgs<ExtArgs>
    department?: boolean | Student$departmentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    classes?: boolean | Student$classesArgs<ExtArgs>
    parents?: boolean | Student$parentsArgs<ExtArgs>
    payments?: boolean | Student$paymentsArgs<ExtArgs>
    subjects?: boolean | Student$subjectsArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    admissionDate?: boolean
    departmentId?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    phone?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    religion?: boolean
    bloodGroup?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    classId?: boolean
    department?: boolean | Student$departmentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    admissionDate?: boolean
    departmentId?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    phone?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    religion?: boolean
    bloodGroup?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    classId?: boolean
    department?: boolean | Student$departmentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectScalar = {
    id?: boolean
    userId?: boolean
    admissionDate?: boolean
    departmentId?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    phone?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    religion?: boolean
    bloodGroup?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    classId?: boolean
  }

  export type StudentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "admissionDate" | "departmentId" | "address" | "city" | "state" | "country" | "phone" | "dateOfBirth" | "gender" | "religion" | "bloodGroup" | "createdAt" | "updatedAt" | "classId", ExtArgs["result"]["student"]>
  export type StudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendance?: boolean | Student$attendanceArgs<ExtArgs>
    paymentRequests?: boolean | Student$paymentRequestsArgs<ExtArgs>
    results?: boolean | Student$resultsArgs<ExtArgs>
    department?: boolean | Student$departmentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    classes?: boolean | Student$classesArgs<ExtArgs>
    parents?: boolean | Student$parentsArgs<ExtArgs>
    payments?: boolean | Student$paymentsArgs<ExtArgs>
    subjects?: boolean | Student$subjectsArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Student$departmentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StudentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Student$departmentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Student"
    objects: {
      attendance: Prisma.$AttendancePayload<ExtArgs>[]
      paymentRequests: Prisma.$PaymentRequestPayload<ExtArgs>[]
      results: Prisma.$ResultPayload<ExtArgs>[]
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
      classes: Prisma.$StudentClassPayload<ExtArgs>[]
      parents: Prisma.$StudentParentPayload<ExtArgs>[]
      payments: Prisma.$StudentPaymentPayload<ExtArgs>[]
      subjects: Prisma.$StudentSubjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      admissionDate: Date | null
      departmentId: string | null
      address: string | null
      city: string | null
      state: string | null
      country: string | null
      phone: string | null
      dateOfBirth: Date | null
      gender: string | null
      religion: string | null
      bloodGroup: string | null
      createdAt: Date
      updatedAt: Date
      classId: string | null
    }, ExtArgs["result"]["student"]>
    composites: {}
  }

  type StudentGetPayload<S extends boolean | null | undefined | StudentDefaultArgs> = $Result.GetResult<Prisma.$StudentPayload, S>

  type StudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface StudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Student'], meta: { name: 'Student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentFindUniqueArgs>(args: SelectSubset<T, StudentFindUniqueArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Student that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentFindFirstArgs>(args?: SelectSubset<T, StudentFindFirstArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentFindManyArgs>(args?: SelectSubset<T, StudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
     */
    create<T extends StudentCreateArgs>(args: SelectSubset<T, StudentCreateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Students.
     * @param {StudentCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentCreateManyArgs>(args?: SelectSubset<T, StudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Students and returns the data saved in the database.
     * @param {StudentCreateManyAndReturnArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
     */
    delete<T extends StudentDeleteArgs>(args: SelectSubset<T, StudentDeleteArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentUpdateArgs>(args: SelectSubset<T, StudentUpdateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentDeleteManyArgs>(args?: SelectSubset<T, StudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentUpdateManyArgs>(args: SelectSubset<T, StudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students and returns the data updated in the database.
     * @param {StudentUpdateManyAndReturnArgs} args - Arguments to update many Students.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
     */
    upsert<T extends StudentUpsertArgs>(args: SelectSubset<T, StudentUpsertArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Student model
   */
  readonly fields: StudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attendance<T extends Student$attendanceArgs<ExtArgs> = {}>(args?: Subset<T, Student$attendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymentRequests<T extends Student$paymentRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Student$paymentRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    results<T extends Student$resultsArgs<ExtArgs> = {}>(args?: Subset<T, Student$resultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    department<T extends Student$departmentArgs<ExtArgs> = {}>(args?: Subset<T, Student$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    classes<T extends Student$classesArgs<ExtArgs> = {}>(args?: Subset<T, Student$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parents<T extends Student$parentsArgs<ExtArgs> = {}>(args?: Subset<T, Student$parentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Student$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Student$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subjects<T extends Student$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, Student$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Student model
   */ 
  interface StudentFieldRefs {
    readonly id: FieldRef<"Student", 'String'>
    readonly userId: FieldRef<"Student", 'String'>
    readonly admissionDate: FieldRef<"Student", 'DateTime'>
    readonly departmentId: FieldRef<"Student", 'String'>
    readonly address: FieldRef<"Student", 'String'>
    readonly city: FieldRef<"Student", 'String'>
    readonly state: FieldRef<"Student", 'String'>
    readonly country: FieldRef<"Student", 'String'>
    readonly phone: FieldRef<"Student", 'String'>
    readonly dateOfBirth: FieldRef<"Student", 'DateTime'>
    readonly gender: FieldRef<"Student", 'String'>
    readonly religion: FieldRef<"Student", 'String'>
    readonly bloodGroup: FieldRef<"Student", 'String'>
    readonly createdAt: FieldRef<"Student", 'DateTime'>
    readonly updatedAt: FieldRef<"Student", 'DateTime'>
    readonly classId: FieldRef<"Student", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Student findUnique
   */
  export type StudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findFirst
   */
  export type StudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findMany
   */
  export type StudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student create
   */
  export type StudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }

  /**
   * Student createMany
   */
  export type StudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Student createManyAndReturn
   */
  export type StudentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Student update
   */
  export type StudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
  }

  /**
   * Student updateManyAndReturn
   */
  export type StudentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Student upsert
   */
  export type StudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }

  /**
   * Student delete
   */
  export type StudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to delete.
     */
    limit?: number
  }

  /**
   * Student.attendance
   */
  export type Student$attendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Student.paymentRequests
   */
  export type Student$paymentRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRequest
     */
    select?: PaymentRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRequest
     */
    omit?: PaymentRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRequestInclude<ExtArgs> | null
    where?: PaymentRequestWhereInput
    orderBy?: PaymentRequestOrderByWithRelationInput | PaymentRequestOrderByWithRelationInput[]
    cursor?: PaymentRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentRequestScalarFieldEnum | PaymentRequestScalarFieldEnum[]
  }

  /**
   * Student.results
   */
  export type Student$resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Result
     */
    select?: ResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Result
     */
    omit?: ResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultInclude<ExtArgs> | null
    where?: ResultWhereInput
    orderBy?: ResultOrderByWithRelationInput | ResultOrderByWithRelationInput[]
    cursor?: ResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResultScalarFieldEnum | ResultScalarFieldEnum[]
  }

  /**
   * Student.department
   */
  export type Student$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Student.classes
   */
  export type Student$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentClass
     */
    select?: StudentClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentClass
     */
    omit?: StudentClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentClassInclude<ExtArgs> | null
    where?: StudentClassWhereInput
    orderBy?: StudentClassOrderByWithRelationInput | StudentClassOrderByWithRelationInput[]
    cursor?: StudentClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentClassScalarFieldEnum | StudentClassScalarFieldEnum[]
  }

  /**
   * Student.parents
   */
  export type Student$parentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    where?: StudentParentWhereInput
    orderBy?: StudentParentOrderByWithRelationInput | StudentParentOrderByWithRelationInput[]
    cursor?: StudentParentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentParentScalarFieldEnum | StudentParentScalarFieldEnum[]
  }

  /**
   * Student.payments
   */
  export type Student$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentPayment
     */
    select?: StudentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentPayment
     */
    omit?: StudentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentPaymentInclude<ExtArgs> | null
    where?: StudentPaymentWhereInput
    orderBy?: StudentPaymentOrderByWithRelationInput | StudentPaymentOrderByWithRelationInput[]
    cursor?: StudentPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentPaymentScalarFieldEnum | StudentPaymentScalarFieldEnum[]
  }

  /**
   * Student.subjects
   */
  export type Student$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSubject
     */
    omit?: StudentSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectInclude<ExtArgs> | null
    where?: StudentSubjectWhereInput
    orderBy?: StudentSubjectOrderByWithRelationInput | StudentSubjectOrderByWithRelationInput[]
    cursor?: StudentSubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSubjectScalarFieldEnum | StudentSubjectScalarFieldEnum[]
  }

  /**
   * Student without action
   */
  export type StudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
  }


  /**
   * Model Parent
   */

  export type AggregateParent = {
    _count: ParentCountAggregateOutputType | null
    _min: ParentMinAggregateOutputType | null
    _max: ParentMaxAggregateOutputType | null
  }

  export type ParentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    occupation: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    phone: string | null
    alternatePhone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    occupation: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    phone: string | null
    alternatePhone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParentCountAggregateOutputType = {
    id: number
    userId: number
    occupation: number
    address: number
    city: number
    state: number
    country: number
    phone: number
    alternatePhone: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ParentMinAggregateInputType = {
    id?: true
    userId?: true
    occupation?: true
    address?: true
    city?: true
    state?: true
    country?: true
    phone?: true
    alternatePhone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParentMaxAggregateInputType = {
    id?: true
    userId?: true
    occupation?: true
    address?: true
    city?: true
    state?: true
    country?: true
    phone?: true
    alternatePhone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParentCountAggregateInputType = {
    id?: true
    userId?: true
    occupation?: true
    address?: true
    city?: true
    state?: true
    country?: true
    phone?: true
    alternatePhone?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ParentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parent to aggregate.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Parents
    **/
    _count?: true | ParentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParentMaxAggregateInputType
  }

  export type GetParentAggregateType<T extends ParentAggregateArgs> = {
        [P in keyof T & keyof AggregateParent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParent[P]>
      : GetScalarType<T[P], AggregateParent[P]>
  }




  export type ParentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParentWhereInput
    orderBy?: ParentOrderByWithAggregationInput | ParentOrderByWithAggregationInput[]
    by: ParentScalarFieldEnum[] | ParentScalarFieldEnum
    having?: ParentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParentCountAggregateInputType | true
    _min?: ParentMinAggregateInputType
    _max?: ParentMaxAggregateInputType
  }

  export type ParentGroupByOutputType = {
    id: string
    userId: string
    occupation: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    phone: string | null
    alternatePhone: string | null
    createdAt: Date
    updatedAt: Date
    _count: ParentCountAggregateOutputType | null
    _min: ParentMinAggregateOutputType | null
    _max: ParentMaxAggregateOutputType | null
  }

  type GetParentGroupByPayload<T extends ParentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParentGroupByOutputType[P]>
            : GetScalarType<T[P], ParentGroupByOutputType[P]>
        }
      >
    >


  export type ParentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    occupation?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    phone?: boolean
    alternatePhone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    children?: boolean | Parent$childrenArgs<ExtArgs>
    _count?: boolean | ParentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parent"]>

  export type ParentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    occupation?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    phone?: boolean
    alternatePhone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parent"]>

  export type ParentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    occupation?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    phone?: boolean
    alternatePhone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parent"]>

  export type ParentSelectScalar = {
    id?: boolean
    userId?: boolean
    occupation?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    phone?: boolean
    alternatePhone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ParentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "occupation" | "address" | "city" | "state" | "country" | "phone" | "alternatePhone" | "createdAt" | "updatedAt", ExtArgs["result"]["parent"]>
  export type ParentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    children?: boolean | Parent$childrenArgs<ExtArgs>
    _count?: boolean | ParentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ParentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ParentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ParentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Parent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      children: Prisma.$StudentParentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      occupation: string | null
      address: string | null
      city: string | null
      state: string | null
      country: string | null
      phone: string | null
      alternatePhone: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["parent"]>
    composites: {}
  }

  type ParentGetPayload<S extends boolean | null | undefined | ParentDefaultArgs> = $Result.GetResult<Prisma.$ParentPayload, S>

  type ParentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParentCountAggregateInputType | true
    }

  export interface ParentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Parent'], meta: { name: 'Parent' } }
    /**
     * Find zero or one Parent that matches the filter.
     * @param {ParentFindUniqueArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParentFindUniqueArgs>(args: SelectSubset<T, ParentFindUniqueArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Parent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParentFindUniqueOrThrowArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParentFindUniqueOrThrowArgs>(args: SelectSubset<T, ParentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentFindFirstArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParentFindFirstArgs>(args?: SelectSubset<T, ParentFindFirstArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentFindFirstOrThrowArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParentFindFirstOrThrowArgs>(args?: SelectSubset<T, ParentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Parents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parents
     * const parents = await prisma.parent.findMany()
     * 
     * // Get first 10 Parents
     * const parents = await prisma.parent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parentWithIdOnly = await prisma.parent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParentFindManyArgs>(args?: SelectSubset<T, ParentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Parent.
     * @param {ParentCreateArgs} args - Arguments to create a Parent.
     * @example
     * // Create one Parent
     * const Parent = await prisma.parent.create({
     *   data: {
     *     // ... data to create a Parent
     *   }
     * })
     * 
     */
    create<T extends ParentCreateArgs>(args: SelectSubset<T, ParentCreateArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Parents.
     * @param {ParentCreateManyArgs} args - Arguments to create many Parents.
     * @example
     * // Create many Parents
     * const parent = await prisma.parent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParentCreateManyArgs>(args?: SelectSubset<T, ParentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Parents and returns the data saved in the database.
     * @param {ParentCreateManyAndReturnArgs} args - Arguments to create many Parents.
     * @example
     * // Create many Parents
     * const parent = await prisma.parent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Parents and only return the `id`
     * const parentWithIdOnly = await prisma.parent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParentCreateManyAndReturnArgs>(args?: SelectSubset<T, ParentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Parent.
     * @param {ParentDeleteArgs} args - Arguments to delete one Parent.
     * @example
     * // Delete one Parent
     * const Parent = await prisma.parent.delete({
     *   where: {
     *     // ... filter to delete one Parent
     *   }
     * })
     * 
     */
    delete<T extends ParentDeleteArgs>(args: SelectSubset<T, ParentDeleteArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Parent.
     * @param {ParentUpdateArgs} args - Arguments to update one Parent.
     * @example
     * // Update one Parent
     * const parent = await prisma.parent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParentUpdateArgs>(args: SelectSubset<T, ParentUpdateArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Parents.
     * @param {ParentDeleteManyArgs} args - Arguments to filter Parents to delete.
     * @example
     * // Delete a few Parents
     * const { count } = await prisma.parent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParentDeleteManyArgs>(args?: SelectSubset<T, ParentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parents
     * const parent = await prisma.parent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParentUpdateManyArgs>(args: SelectSubset<T, ParentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parents and returns the data updated in the database.
     * @param {ParentUpdateManyAndReturnArgs} args - Arguments to update many Parents.
     * @example
     * // Update many Parents
     * const parent = await prisma.parent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Parents and only return the `id`
     * const parentWithIdOnly = await prisma.parent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ParentUpdateManyAndReturnArgs>(args: SelectSubset<T, ParentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Parent.
     * @param {ParentUpsertArgs} args - Arguments to update or create a Parent.
     * @example
     * // Update or create a Parent
     * const parent = await prisma.parent.upsert({
     *   create: {
     *     // ... data to create a Parent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parent we want to update
     *   }
     * })
     */
    upsert<T extends ParentUpsertArgs>(args: SelectSubset<T, ParentUpsertArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentCountArgs} args - Arguments to filter Parents to count.
     * @example
     * // Count the number of Parents
     * const count = await prisma.parent.count({
     *   where: {
     *     // ... the filter for the Parents we want to count
     *   }
     * })
    **/
    count<T extends ParentCountArgs>(
      args?: Subset<T, ParentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParentAggregateArgs>(args: Subset<T, ParentAggregateArgs>): Prisma.PrismaPromise<GetParentAggregateType<T>>

    /**
     * Group by Parent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParentGroupByArgs['orderBy'] }
        : { orderBy?: ParentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Parent model
   */
  readonly fields: ParentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Parent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    children<T extends Parent$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Parent$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Parent model
   */ 
  interface ParentFieldRefs {
    readonly id: FieldRef<"Parent", 'String'>
    readonly userId: FieldRef<"Parent", 'String'>
    readonly occupation: FieldRef<"Parent", 'String'>
    readonly address: FieldRef<"Parent", 'String'>
    readonly city: FieldRef<"Parent", 'String'>
    readonly state: FieldRef<"Parent", 'String'>
    readonly country: FieldRef<"Parent", 'String'>
    readonly phone: FieldRef<"Parent", 'String'>
    readonly alternatePhone: FieldRef<"Parent", 'String'>
    readonly createdAt: FieldRef<"Parent", 'DateTime'>
    readonly updatedAt: FieldRef<"Parent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Parent findUnique
   */
  export type ParentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent findUniqueOrThrow
   */
  export type ParentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent findFirst
   */
  export type ParentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parents.
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parents.
     */
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * Parent findFirstOrThrow
   */
  export type ParentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parents.
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parents.
     */
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * Parent findMany
   */
  export type ParentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parents to fetch.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Parents.
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * Parent create
   */
  export type ParentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * The data needed to create a Parent.
     */
    data: XOR<ParentCreateInput, ParentUncheckedCreateInput>
  }

  /**
   * Parent createMany
   */
  export type ParentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Parents.
     */
    data: ParentCreateManyInput | ParentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Parent createManyAndReturn
   */
  export type ParentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * The data used to create many Parents.
     */
    data: ParentCreateManyInput | ParentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Parent update
   */
  export type ParentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * The data needed to update a Parent.
     */
    data: XOR<ParentUpdateInput, ParentUncheckedUpdateInput>
    /**
     * Choose, which Parent to update.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent updateMany
   */
  export type ParentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Parents.
     */
    data: XOR<ParentUpdateManyMutationInput, ParentUncheckedUpdateManyInput>
    /**
     * Filter which Parents to update
     */
    where?: ParentWhereInput
    /**
     * Limit how many Parents to update.
     */
    limit?: number
  }

  /**
   * Parent updateManyAndReturn
   */
  export type ParentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * The data used to update Parents.
     */
    data: XOR<ParentUpdateManyMutationInput, ParentUncheckedUpdateManyInput>
    /**
     * Filter which Parents to update
     */
    where?: ParentWhereInput
    /**
     * Limit how many Parents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Parent upsert
   */
  export type ParentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * The filter to search for the Parent to update in case it exists.
     */
    where: ParentWhereUniqueInput
    /**
     * In case the Parent found by the `where` argument doesn't exist, create a new Parent with this data.
     */
    create: XOR<ParentCreateInput, ParentUncheckedCreateInput>
    /**
     * In case the Parent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParentUpdateInput, ParentUncheckedUpdateInput>
  }

  /**
   * Parent delete
   */
  export type ParentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter which Parent to delete.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent deleteMany
   */
  export type ParentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parents to delete
     */
    where?: ParentWhereInput
    /**
     * Limit how many Parents to delete.
     */
    limit?: number
  }

  /**
   * Parent.children
   */
  export type Parent$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    where?: StudentParentWhereInput
    orderBy?: StudentParentOrderByWithRelationInput | StudentParentOrderByWithRelationInput[]
    cursor?: StudentParentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentParentScalarFieldEnum | StudentParentScalarFieldEnum[]
  }

  /**
   * Parent without action
   */
  export type ParentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
  }


  /**
   * Model School
   */

  export type AggregateSchool = {
    _count: SchoolCountAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  export type SchoolMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    phone: string | null
    email: string | null
    logo: string | null
    subdomain: string | null
    primaryColor: string | null
    secondaryColor: string | null
    shortName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    phone: string | null
    email: string | null
    logo: string | null
    subdomain: string | null
    primaryColor: string | null
    secondaryColor: string | null
    shortName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolCountAggregateOutputType = {
    id: number
    name: number
    address: number
    phone: number
    email: number
    logo: number
    subdomain: number
    primaryColor: number
    secondaryColor: number
    shortName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SchoolMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    logo?: true
    subdomain?: true
    primaryColor?: true
    secondaryColor?: true
    shortName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    logo?: true
    subdomain?: true
    primaryColor?: true
    secondaryColor?: true
    shortName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    logo?: true
    subdomain?: true
    primaryColor?: true
    secondaryColor?: true
    shortName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchoolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which School to aggregate.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schools
    **/
    _count?: true | SchoolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolMaxAggregateInputType
  }

  export type GetSchoolAggregateType<T extends SchoolAggregateArgs> = {
        [P in keyof T & keyof AggregateSchool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchool[P]>
      : GetScalarType<T[P], AggregateSchool[P]>
  }




  export type SchoolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolWhereInput
    orderBy?: SchoolOrderByWithAggregationInput | SchoolOrderByWithAggregationInput[]
    by: SchoolScalarFieldEnum[] | SchoolScalarFieldEnum
    having?: SchoolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolCountAggregateInputType | true
    _min?: SchoolMinAggregateInputType
    _max?: SchoolMaxAggregateInputType
  }

  export type SchoolGroupByOutputType = {
    id: string
    name: string
    address: string | null
    phone: string | null
    email: string
    logo: string | null
    subdomain: string
    primaryColor: string | null
    secondaryColor: string | null
    shortName: string
    createdAt: Date
    updatedAt: Date
    _count: SchoolCountAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  type GetSchoolGroupByPayload<T extends SchoolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolGroupByOutputType[P]>
        }
      >
    >


  export type SchoolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    logo?: boolean
    subdomain?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    shortName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessions?: boolean | School$sessionsArgs<ExtArgs>
    bills?: boolean | School$billsArgs<ExtArgs>
    classes?: boolean | School$classesArgs<ExtArgs>
    departments?: boolean | School$departmentsArgs<ExtArgs>
    events?: boolean | School$eventsArgs<ExtArgs>
    paymentAccounts?: boolean | School$paymentAccountsArgs<ExtArgs>
    levels?: boolean | School$levelsArgs<ExtArgs>
    subjects?: boolean | School$subjectsArgs<ExtArgs>
    users?: boolean | School$usersArgs<ExtArgs>
    resultConfigs?: boolean | School$resultConfigsArgs<ExtArgs>
    _count?: boolean | SchoolCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    logo?: boolean
    subdomain?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    shortName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    logo?: boolean
    subdomain?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    shortName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    logo?: boolean
    subdomain?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    shortName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SchoolOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "phone" | "email" | "logo" | "subdomain" | "primaryColor" | "secondaryColor" | "shortName" | "createdAt" | "updatedAt", ExtArgs["result"]["school"]>
  export type SchoolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | School$sessionsArgs<ExtArgs>
    bills?: boolean | School$billsArgs<ExtArgs>
    classes?: boolean | School$classesArgs<ExtArgs>
    departments?: boolean | School$departmentsArgs<ExtArgs>
    events?: boolean | School$eventsArgs<ExtArgs>
    paymentAccounts?: boolean | School$paymentAccountsArgs<ExtArgs>
    levels?: boolean | School$levelsArgs<ExtArgs>
    subjects?: boolean | School$subjectsArgs<ExtArgs>
    users?: boolean | School$usersArgs<ExtArgs>
    resultConfigs?: boolean | School$resultConfigsArgs<ExtArgs>
    _count?: boolean | SchoolCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SchoolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SchoolIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SchoolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "School"
    objects: {
      sessions: Prisma.$AcademicSessionPayload<ExtArgs>[]
      bills: Prisma.$BillPayload<ExtArgs>[]
      classes: Prisma.$ClassPayload<ExtArgs>[]
      departments: Prisma.$DepartmentPayload<ExtArgs>[]
      events: Prisma.$EventPayload<ExtArgs>[]
      paymentAccounts: Prisma.$PaymentAccountPayload<ExtArgs>[]
      levels: Prisma.$SchoolLevelPayload<ExtArgs>[]
      subjects: Prisma.$SubjectPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      resultConfigs: Prisma.$ResultConfigurationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string | null
      phone: string | null
      email: string
      logo: string | null
      subdomain: string
      primaryColor: string | null
      secondaryColor: string | null
      shortName: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["school"]>
    composites: {}
  }

  type SchoolGetPayload<S extends boolean | null | undefined | SchoolDefaultArgs> = $Result.GetResult<Prisma.$SchoolPayload, S>

  type SchoolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SchoolFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SchoolCountAggregateInputType | true
    }

  export interface SchoolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['School'], meta: { name: 'School' } }
    /**
     * Find zero or one School that matches the filter.
     * @param {SchoolFindUniqueArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolFindUniqueArgs>(args: SelectSubset<T, SchoolFindUniqueArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one School that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SchoolFindUniqueOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first School that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindFirstArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolFindFirstArgs>(args?: SelectSubset<T, SchoolFindFirstArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first School that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindFirstOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Schools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schools
     * const schools = await prisma.school.findMany()
     * 
     * // Get first 10 Schools
     * const schools = await prisma.school.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolWithIdOnly = await prisma.school.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolFindManyArgs>(args?: SelectSubset<T, SchoolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a School.
     * @param {SchoolCreateArgs} args - Arguments to create a School.
     * @example
     * // Create one School
     * const School = await prisma.school.create({
     *   data: {
     *     // ... data to create a School
     *   }
     * })
     * 
     */
    create<T extends SchoolCreateArgs>(args: SelectSubset<T, SchoolCreateArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Schools.
     * @param {SchoolCreateManyArgs} args - Arguments to create many Schools.
     * @example
     * // Create many Schools
     * const school = await prisma.school.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolCreateManyArgs>(args?: SelectSubset<T, SchoolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Schools and returns the data saved in the database.
     * @param {SchoolCreateManyAndReturnArgs} args - Arguments to create many Schools.
     * @example
     * // Create many Schools
     * const school = await prisma.school.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Schools and only return the `id`
     * const schoolWithIdOnly = await prisma.school.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchoolCreateManyAndReturnArgs>(args?: SelectSubset<T, SchoolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a School.
     * @param {SchoolDeleteArgs} args - Arguments to delete one School.
     * @example
     * // Delete one School
     * const School = await prisma.school.delete({
     *   where: {
     *     // ... filter to delete one School
     *   }
     * })
     * 
     */
    delete<T extends SchoolDeleteArgs>(args: SelectSubset<T, SchoolDeleteArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one School.
     * @param {SchoolUpdateArgs} args - Arguments to update one School.
     * @example
     * // Update one School
     * const school = await prisma.school.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolUpdateArgs>(args: SelectSubset<T, SchoolUpdateArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Schools.
     * @param {SchoolDeleteManyArgs} args - Arguments to filter Schools to delete.
     * @example
     * // Delete a few Schools
     * const { count } = await prisma.school.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolDeleteManyArgs>(args?: SelectSubset<T, SchoolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schools
     * const school = await prisma.school.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolUpdateManyArgs>(args: SelectSubset<T, SchoolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schools and returns the data updated in the database.
     * @param {SchoolUpdateManyAndReturnArgs} args - Arguments to update many Schools.
     * @example
     * // Update many Schools
     * const school = await prisma.school.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Schools and only return the `id`
     * const schoolWithIdOnly = await prisma.school.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SchoolUpdateManyAndReturnArgs>(args: SelectSubset<T, SchoolUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one School.
     * @param {SchoolUpsertArgs} args - Arguments to update or create a School.
     * @example
     * // Update or create a School
     * const school = await prisma.school.upsert({
     *   create: {
     *     // ... data to create a School
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the School we want to update
     *   }
     * })
     */
    upsert<T extends SchoolUpsertArgs>(args: SelectSubset<T, SchoolUpsertArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolCountArgs} args - Arguments to filter Schools to count.
     * @example
     * // Count the number of Schools
     * const count = await prisma.school.count({
     *   where: {
     *     // ... the filter for the Schools we want to count
     *   }
     * })
    **/
    count<T extends SchoolCountArgs>(
      args?: Subset<T, SchoolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolAggregateArgs>(args: Subset<T, SchoolAggregateArgs>): Prisma.PrismaPromise<GetSchoolAggregateType<T>>

    /**
     * Group by School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolGroupByArgs['orderBy'] }
        : { orderBy?: SchoolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the School model
   */
  readonly fields: SchoolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for School.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends School$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, School$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bills<T extends School$billsArgs<ExtArgs> = {}>(args?: Subset<T, School$billsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    classes<T extends School$classesArgs<ExtArgs> = {}>(args?: Subset<T, School$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    departments<T extends School$departmentsArgs<ExtArgs> = {}>(args?: Subset<T, School$departmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    events<T extends School$eventsArgs<ExtArgs> = {}>(args?: Subset<T, School$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymentAccounts<T extends School$paymentAccountsArgs<ExtArgs> = {}>(args?: Subset<T, School$paymentAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    levels<T extends School$levelsArgs<ExtArgs> = {}>(args?: Subset<T, School$levelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolLevelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subjects<T extends School$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, School$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends School$usersArgs<ExtArgs> = {}>(args?: Subset<T, School$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    resultConfigs<T extends School$resultConfigsArgs<ExtArgs> = {}>(args?: Subset<T, School$resultConfigsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultConfigurationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the School model
   */ 
  interface SchoolFieldRefs {
    readonly id: FieldRef<"School", 'String'>
    readonly name: FieldRef<"School", 'String'>
    readonly address: FieldRef<"School", 'String'>
    readonly phone: FieldRef<"School", 'String'>
    readonly email: FieldRef<"School", 'String'>
    readonly logo: FieldRef<"School", 'String'>
    readonly subdomain: FieldRef<"School", 'String'>
    readonly primaryColor: FieldRef<"School", 'String'>
    readonly secondaryColor: FieldRef<"School", 'String'>
    readonly shortName: FieldRef<"School", 'String'>
    readonly createdAt: FieldRef<"School", 'DateTime'>
    readonly updatedAt: FieldRef<"School", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * School findUnique
   */
  export type SchoolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School findUniqueOrThrow
   */
  export type SchoolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School findFirst
   */
  export type SchoolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schools.
     */
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School findFirstOrThrow
   */
  export type SchoolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schools.
     */
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School findMany
   */
  export type SchoolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which Schools to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School create
   */
  export type SchoolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The data needed to create a School.
     */
    data: XOR<SchoolCreateInput, SchoolUncheckedCreateInput>
  }

  /**
   * School createMany
   */
  export type SchoolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schools.
     */
    data: SchoolCreateManyInput | SchoolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * School createManyAndReturn
   */
  export type SchoolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * The data used to create many Schools.
     */
    data: SchoolCreateManyInput | SchoolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * School update
   */
  export type SchoolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The data needed to update a School.
     */
    data: XOR<SchoolUpdateInput, SchoolUncheckedUpdateInput>
    /**
     * Choose, which School to update.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School updateMany
   */
  export type SchoolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schools.
     */
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyInput>
    /**
     * Filter which Schools to update
     */
    where?: SchoolWhereInput
    /**
     * Limit how many Schools to update.
     */
    limit?: number
  }

  /**
   * School updateManyAndReturn
   */
  export type SchoolUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * The data used to update Schools.
     */
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyInput>
    /**
     * Filter which Schools to update
     */
    where?: SchoolWhereInput
    /**
     * Limit how many Schools to update.
     */
    limit?: number
  }

  /**
   * School upsert
   */
  export type SchoolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The filter to search for the School to update in case it exists.
     */
    where: SchoolWhereUniqueInput
    /**
     * In case the School found by the `where` argument doesn't exist, create a new School with this data.
     */
    create: XOR<SchoolCreateInput, SchoolUncheckedCreateInput>
    /**
     * In case the School was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolUpdateInput, SchoolUncheckedUpdateInput>
  }

  /**
   * School delete
   */
  export type SchoolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter which School to delete.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School deleteMany
   */
  export type SchoolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schools to delete
     */
    where?: SchoolWhereInput
    /**
     * Limit how many Schools to delete.
     */
    limit?: number
  }

  /**
   * School.sessions
   */
  export type School$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSession
     */
    select?: AcademicSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSession
     */
    omit?: AcademicSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSessionInclude<ExtArgs> | null
    where?: AcademicSessionWhereInput
    orderBy?: AcademicSessionOrderByWithRelationInput | AcademicSessionOrderByWithRelationInput[]
    cursor?: AcademicSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AcademicSessionScalarFieldEnum | AcademicSessionScalarFieldEnum[]
  }

  /**
   * School.bills
   */
  export type School$billsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    where?: BillWhereInput
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    cursor?: BillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * School.classes
   */
  export type School$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * School.departments
   */
  export type School$departmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    cursor?: DepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * School.events
   */
  export type School$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * School.paymentAccounts
   */
  export type School$paymentAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAccount
     */
    select?: PaymentAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAccount
     */
    omit?: PaymentAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAccountInclude<ExtArgs> | null
    where?: PaymentAccountWhereInput
    orderBy?: PaymentAccountOrderByWithRelationInput | PaymentAccountOrderByWithRelationInput[]
    cursor?: PaymentAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentAccountScalarFieldEnum | PaymentAccountScalarFieldEnum[]
  }

  /**
   * School.levels
   */
  export type School$levelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLevel
     */
    select?: SchoolLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolLevel
     */
    omit?: SchoolLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLevelInclude<ExtArgs> | null
    where?: SchoolLevelWhereInput
    orderBy?: SchoolLevelOrderByWithRelationInput | SchoolLevelOrderByWithRelationInput[]
    cursor?: SchoolLevelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchoolLevelScalarFieldEnum | SchoolLevelScalarFieldEnum[]
  }

  /**
   * School.subjects
   */
  export type School$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    cursor?: SubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * School.users
   */
  export type School$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * School.resultConfigs
   */
  export type School$resultConfigsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultConfiguration
     */
    select?: ResultConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultConfiguration
     */
    omit?: ResultConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultConfigurationInclude<ExtArgs> | null
    where?: ResultConfigurationWhereInput
    orderBy?: ResultConfigurationOrderByWithRelationInput | ResultConfigurationOrderByWithRelationInput[]
    cursor?: ResultConfigurationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResultConfigurationScalarFieldEnum | ResultConfigurationScalarFieldEnum[]
  }

  /**
   * School without action
   */
  export type SchoolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
  }


  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    name: number
    description: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepartmentMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: string
    name: string
    description: string | null
    schoolId: string
    createdAt: Date
    updatedAt: Date
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    students?: boolean | Department$studentsArgs<ExtArgs>
    subjects?: boolean | Department$subjectsArgs<ExtArgs>
    teachers?: boolean | Department$teachersArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepartmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "schoolId" | "createdAt" | "updatedAt", ExtArgs["result"]["department"]>
  export type DepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    students?: boolean | Department$studentsArgs<ExtArgs>
    subjects?: boolean | Department$subjectsArgs<ExtArgs>
    teachers?: boolean | Department$teachersArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      students: Prisma.$StudentPayload<ExtArgs>[]
      subjects: Prisma.$SubjectPayload<ExtArgs>[]
      teachers: Prisma.$TeacherPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      schoolId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departments and returns the data saved in the database.
     * @param {DepartmentCreateManyAndReturnArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments and returns the data updated in the database.
     * @param {DepartmentUpdateManyAndReturnArgs} args - Arguments to update many Departments.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepartmentUpdateManyAndReturnArgs>(args: SelectSubset<T, DepartmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    students<T extends Department$studentsArgs<ExtArgs> = {}>(args?: Subset<T, Department$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subjects<T extends Department$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, Department$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teachers<T extends Department$teachersArgs<ExtArgs> = {}>(args?: Subset<T, Department$teachersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */ 
  interface DepartmentFieldRefs {
    readonly id: FieldRef<"Department", 'String'>
    readonly name: FieldRef<"Department", 'String'>
    readonly description: FieldRef<"Department", 'String'>
    readonly schoolId: FieldRef<"Department", 'String'>
    readonly createdAt: FieldRef<"Department", 'DateTime'>
    readonly updatedAt: FieldRef<"Department", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department createManyAndReturn
   */
  export type DepartmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department updateManyAndReturn
   */
  export type DepartmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to delete.
     */
    limit?: number
  }

  /**
   * Department.students
   */
  export type Department$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Department.subjects
   */
  export type Department$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    cursor?: SubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Department.teachers
   */
  export type Department$teachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    where?: TeacherWhereInput
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    cursor?: TeacherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
  }


  /**
   * Model Class
   */

  export type AggregateClass = {
    _count: ClassCountAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  export type ClassMinAggregateOutputType = {
    id: string | null
    name: string | null
    section: string | null
    schoolId: string | null
    teacherId: string | null
    levelId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassMaxAggregateOutputType = {
    id: string | null
    name: string | null
    section: string | null
    schoolId: string | null
    teacherId: string | null
    levelId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassCountAggregateOutputType = {
    id: number
    name: number
    section: number
    schoolId: number
    teacherId: number
    levelId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClassMinAggregateInputType = {
    id?: true
    name?: true
    section?: true
    schoolId?: true
    teacherId?: true
    levelId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassMaxAggregateInputType = {
    id?: true
    name?: true
    section?: true
    schoolId?: true
    teacherId?: true
    levelId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassCountAggregateInputType = {
    id?: true
    name?: true
    section?: true
    schoolId?: true
    teacherId?: true
    levelId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Class to aggregate.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Classes
    **/
    _count?: true | ClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassMaxAggregateInputType
  }

  export type GetClassAggregateType<T extends ClassAggregateArgs> = {
        [P in keyof T & keyof AggregateClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClass[P]>
      : GetScalarType<T[P], AggregateClass[P]>
  }




  export type ClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithAggregationInput | ClassOrderByWithAggregationInput[]
    by: ClassScalarFieldEnum[] | ClassScalarFieldEnum
    having?: ClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassCountAggregateInputType | true
    _min?: ClassMinAggregateInputType
    _max?: ClassMaxAggregateInputType
  }

  export type ClassGroupByOutputType = {
    id: string
    name: string
    section: string | null
    schoolId: string
    teacherId: string | null
    levelId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ClassCountAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  type GetClassGroupByPayload<T extends ClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassGroupByOutputType[P]>
            : GetScalarType<T[P], ClassGroupByOutputType[P]>
        }
      >
    >


  export type ClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    section?: boolean
    schoolId?: boolean
    teacherId?: boolean
    levelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    level?: boolean | Class$levelArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    teacher?: boolean | Class$teacherArgs<ExtArgs>
    subjects?: boolean | Class$subjectsArgs<ExtArgs>
    students?: boolean | Class$studentsArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    section?: boolean
    schoolId?: boolean
    teacherId?: boolean
    levelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    level?: boolean | Class$levelArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    teacher?: boolean | Class$teacherArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    section?: boolean
    schoolId?: boolean
    teacherId?: boolean
    levelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    level?: boolean | Class$levelArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    teacher?: boolean | Class$teacherArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectScalar = {
    id?: boolean
    name?: boolean
    section?: boolean
    schoolId?: boolean
    teacherId?: boolean
    levelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClassOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "section" | "schoolId" | "teacherId" | "levelId" | "createdAt" | "updatedAt", ExtArgs["result"]["class"]>
  export type ClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    level?: boolean | Class$levelArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    teacher?: boolean | Class$teacherArgs<ExtArgs>
    subjects?: boolean | Class$subjectsArgs<ExtArgs>
    students?: boolean | Class$studentsArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClassIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    level?: boolean | Class$levelArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    teacher?: boolean | Class$teacherArgs<ExtArgs>
  }
  export type ClassIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    level?: boolean | Class$levelArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    teacher?: boolean | Class$teacherArgs<ExtArgs>
  }

  export type $ClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Class"
    objects: {
      level: Prisma.$SchoolLevelPayload<ExtArgs> | null
      school: Prisma.$SchoolPayload<ExtArgs>
      teacher: Prisma.$TeacherPayload<ExtArgs> | null
      subjects: Prisma.$ClassSubjectPayload<ExtArgs>[]
      students: Prisma.$StudentClassPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      section: string | null
      schoolId: string
      teacherId: string | null
      levelId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["class"]>
    composites: {}
  }

  type ClassGetPayload<S extends boolean | null | undefined | ClassDefaultArgs> = $Result.GetResult<Prisma.$ClassPayload, S>

  type ClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassCountAggregateInputType | true
    }

  export interface ClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Class'], meta: { name: 'Class' } }
    /**
     * Find zero or one Class that matches the filter.
     * @param {ClassFindUniqueArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassFindUniqueArgs>(args: SelectSubset<T, ClassFindUniqueArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Class that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassFindUniqueOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassFindFirstArgs>(args?: SelectSubset<T, ClassFindFirstArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classes
     * const classes = await prisma.class.findMany()
     * 
     * // Get first 10 Classes
     * const classes = await prisma.class.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classWithIdOnly = await prisma.class.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassFindManyArgs>(args?: SelectSubset<T, ClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Class.
     * @param {ClassCreateArgs} args - Arguments to create a Class.
     * @example
     * // Create one Class
     * const Class = await prisma.class.create({
     *   data: {
     *     // ... data to create a Class
     *   }
     * })
     * 
     */
    create<T extends ClassCreateArgs>(args: SelectSubset<T, ClassCreateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Classes.
     * @param {ClassCreateManyArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassCreateManyArgs>(args?: SelectSubset<T, ClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Classes and returns the data saved in the database.
     * @param {ClassCreateManyAndReturnArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Classes and only return the `id`
     * const classWithIdOnly = await prisma.class.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Class.
     * @param {ClassDeleteArgs} args - Arguments to delete one Class.
     * @example
     * // Delete one Class
     * const Class = await prisma.class.delete({
     *   where: {
     *     // ... filter to delete one Class
     *   }
     * })
     * 
     */
    delete<T extends ClassDeleteArgs>(args: SelectSubset<T, ClassDeleteArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Class.
     * @param {ClassUpdateArgs} args - Arguments to update one Class.
     * @example
     * // Update one Class
     * const class = await prisma.class.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassUpdateArgs>(args: SelectSubset<T, ClassUpdateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Classes.
     * @param {ClassDeleteManyArgs} args - Arguments to filter Classes to delete.
     * @example
     * // Delete a few Classes
     * const { count } = await prisma.class.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassDeleteManyArgs>(args?: SelectSubset<T, ClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassUpdateManyArgs>(args: SelectSubset<T, ClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes and returns the data updated in the database.
     * @param {ClassUpdateManyAndReturnArgs} args - Arguments to update many Classes.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Classes and only return the `id`
     * const classWithIdOnly = await prisma.class.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClassUpdateManyAndReturnArgs>(args: SelectSubset<T, ClassUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Class.
     * @param {ClassUpsertArgs} args - Arguments to update or create a Class.
     * @example
     * // Update or create a Class
     * const class = await prisma.class.upsert({
     *   create: {
     *     // ... data to create a Class
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Class we want to update
     *   }
     * })
     */
    upsert<T extends ClassUpsertArgs>(args: SelectSubset<T, ClassUpsertArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassCountArgs} args - Arguments to filter Classes to count.
     * @example
     * // Count the number of Classes
     * const count = await prisma.class.count({
     *   where: {
     *     // ... the filter for the Classes we want to count
     *   }
     * })
    **/
    count<T extends ClassCountArgs>(
      args?: Subset<T, ClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassAggregateArgs>(args: Subset<T, ClassAggregateArgs>): Prisma.PrismaPromise<GetClassAggregateType<T>>

    /**
     * Group by Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassGroupByArgs['orderBy'] }
        : { orderBy?: ClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Class model
   */
  readonly fields: ClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Class.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    level<T extends Class$levelArgs<ExtArgs> = {}>(args?: Subset<T, Class$levelArgs<ExtArgs>>): Prisma__SchoolLevelClient<$Result.GetResult<Prisma.$SchoolLevelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    teacher<T extends Class$teacherArgs<ExtArgs> = {}>(args?: Subset<T, Class$teacherArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subjects<T extends Class$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, Class$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    students<T extends Class$studentsArgs<ExtArgs> = {}>(args?: Subset<T, Class$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Class model
   */ 
  interface ClassFieldRefs {
    readonly id: FieldRef<"Class", 'String'>
    readonly name: FieldRef<"Class", 'String'>
    readonly section: FieldRef<"Class", 'String'>
    readonly schoolId: FieldRef<"Class", 'String'>
    readonly teacherId: FieldRef<"Class", 'String'>
    readonly levelId: FieldRef<"Class", 'String'>
    readonly createdAt: FieldRef<"Class", 'DateTime'>
    readonly updatedAt: FieldRef<"Class", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Class findUnique
   */
  export type ClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findUniqueOrThrow
   */
  export type ClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findFirst
   */
  export type ClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findFirstOrThrow
   */
  export type ClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findMany
   */
  export type ClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Classes to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class create
   */
  export type ClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to create a Class.
     */
    data: XOR<ClassCreateInput, ClassUncheckedCreateInput>
  }

  /**
   * Class createMany
   */
  export type ClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Class createManyAndReturn
   */
  export type ClassCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Class update
   */
  export type ClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to update a Class.
     */
    data: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
    /**
     * Choose, which Class to update.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class updateMany
   */
  export type ClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to update.
     */
    limit?: number
  }

  /**
   * Class updateManyAndReturn
   */
  export type ClassUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Class upsert
   */
  export type ClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The filter to search for the Class to update in case it exists.
     */
    where: ClassWhereUniqueInput
    /**
     * In case the Class found by the `where` argument doesn't exist, create a new Class with this data.
     */
    create: XOR<ClassCreateInput, ClassUncheckedCreateInput>
    /**
     * In case the Class was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
  }

  /**
   * Class delete
   */
  export type ClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter which Class to delete.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class deleteMany
   */
  export type ClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classes to delete
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to delete.
     */
    limit?: number
  }

  /**
   * Class.level
   */
  export type Class$levelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLevel
     */
    select?: SchoolLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolLevel
     */
    omit?: SchoolLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLevelInclude<ExtArgs> | null
    where?: SchoolLevelWhereInput
  }

  /**
   * Class.teacher
   */
  export type Class$teacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    where?: TeacherWhereInput
  }

  /**
   * Class.subjects
   */
  export type Class$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSubject
     */
    omit?: ClassSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectInclude<ExtArgs> | null
    where?: ClassSubjectWhereInput
    orderBy?: ClassSubjectOrderByWithRelationInput | ClassSubjectOrderByWithRelationInput[]
    cursor?: ClassSubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassSubjectScalarFieldEnum | ClassSubjectScalarFieldEnum[]
  }

  /**
   * Class.students
   */
  export type Class$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentClass
     */
    select?: StudentClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentClass
     */
    omit?: StudentClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentClassInclude<ExtArgs> | null
    where?: StudentClassWhereInput
    orderBy?: StudentClassOrderByWithRelationInput | StudentClassOrderByWithRelationInput[]
    cursor?: StudentClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentClassScalarFieldEnum | StudentClassScalarFieldEnum[]
  }

  /**
   * Class without action
   */
  export type ClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
  }


  /**
   * Model Subject
   */

  export type AggregateSubject = {
    _count: SubjectCountAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  export type SubjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    schoolId: string | null
    departmentId: string | null
    levelId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    schoolId: string | null
    departmentId: string | null
    levelId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubjectCountAggregateOutputType = {
    id: number
    name: number
    code: number
    description: number
    schoolId: number
    departmentId: number
    levelId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubjectMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    schoolId?: true
    departmentId?: true
    levelId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubjectMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    schoolId?: true
    departmentId?: true
    levelId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubjectCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    schoolId?: true
    departmentId?: true
    levelId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subject to aggregate.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subjects
    **/
    _count?: true | SubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubjectMaxAggregateInputType
  }

  export type GetSubjectAggregateType<T extends SubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateSubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubject[P]>
      : GetScalarType<T[P], AggregateSubject[P]>
  }




  export type SubjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithAggregationInput | SubjectOrderByWithAggregationInput[]
    by: SubjectScalarFieldEnum[] | SubjectScalarFieldEnum
    having?: SubjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubjectCountAggregateInputType | true
    _min?: SubjectMinAggregateInputType
    _max?: SubjectMaxAggregateInputType
  }

  export type SubjectGroupByOutputType = {
    id: string
    name: string
    code: string | null
    description: string | null
    schoolId: string
    departmentId: string | null
    levelId: string | null
    createdAt: Date
    updatedAt: Date
    _count: SubjectCountAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  type GetSubjectGroupByPayload<T extends SubjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectGroupByOutputType[P]>
        }
      >
    >


  export type SubjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    schoolId?: boolean
    departmentId?: boolean
    levelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    classes?: boolean | Subject$classesArgs<ExtArgs>
    results?: boolean | Subject$resultsArgs<ExtArgs>
    students?: boolean | Subject$studentsArgs<ExtArgs>
    department?: boolean | Subject$departmentArgs<ExtArgs>
    level?: boolean | Subject$levelArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    teachers?: boolean | Subject$teachersArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    schoolId?: boolean
    departmentId?: boolean
    levelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | Subject$departmentArgs<ExtArgs>
    level?: boolean | Subject$levelArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    schoolId?: boolean
    departmentId?: boolean
    levelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | Subject$departmentArgs<ExtArgs>
    level?: boolean | Subject$levelArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    schoolId?: boolean
    departmentId?: boolean
    levelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "description" | "schoolId" | "departmentId" | "levelId" | "createdAt" | "updatedAt", ExtArgs["result"]["subject"]>
  export type SubjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | Subject$classesArgs<ExtArgs>
    results?: boolean | Subject$resultsArgs<ExtArgs>
    students?: boolean | Subject$studentsArgs<ExtArgs>
    department?: boolean | Subject$departmentArgs<ExtArgs>
    level?: boolean | Subject$levelArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    teachers?: boolean | Subject$teachersArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Subject$departmentArgs<ExtArgs>
    level?: boolean | Subject$levelArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type SubjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Subject$departmentArgs<ExtArgs>
    level?: boolean | Subject$levelArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $SubjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subject"
    objects: {
      classes: Prisma.$ClassSubjectPayload<ExtArgs>[]
      results: Prisma.$ResultPayload<ExtArgs>[]
      students: Prisma.$StudentSubjectPayload<ExtArgs>[]
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      level: Prisma.$SchoolLevelPayload<ExtArgs> | null
      school: Prisma.$SchoolPayload<ExtArgs>
      teachers: Prisma.$SubjectTeacherPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string | null
      description: string | null
      schoolId: string
      departmentId: string | null
      levelId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subject"]>
    composites: {}
  }

  type SubjectGetPayload<S extends boolean | null | undefined | SubjectDefaultArgs> = $Result.GetResult<Prisma.$SubjectPayload, S>

  type SubjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubjectCountAggregateInputType | true
    }

  export interface SubjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subject'], meta: { name: 'Subject' } }
    /**
     * Find zero or one Subject that matches the filter.
     * @param {SubjectFindUniqueArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubjectFindUniqueArgs>(args: SelectSubset<T, SubjectFindUniqueArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subject that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubjectFindUniqueOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubjectFindUniqueOrThrowArgs>(args: SelectSubset<T, SubjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubjectFindFirstArgs>(args?: SelectSubset<T, SubjectFindFirstArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubjectFindFirstOrThrowArgs>(args?: SelectSubset<T, SubjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subjects
     * const subjects = await prisma.subject.findMany()
     * 
     * // Get first 10 Subjects
     * const subjects = await prisma.subject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subjectWithIdOnly = await prisma.subject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubjectFindManyArgs>(args?: SelectSubset<T, SubjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subject.
     * @param {SubjectCreateArgs} args - Arguments to create a Subject.
     * @example
     * // Create one Subject
     * const Subject = await prisma.subject.create({
     *   data: {
     *     // ... data to create a Subject
     *   }
     * })
     * 
     */
    create<T extends SubjectCreateArgs>(args: SelectSubset<T, SubjectCreateArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subjects.
     * @param {SubjectCreateManyArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subject = await prisma.subject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubjectCreateManyArgs>(args?: SelectSubset<T, SubjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subjects and returns the data saved in the database.
     * @param {SubjectCreateManyAndReturnArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subject = await prisma.subject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subjects and only return the `id`
     * const subjectWithIdOnly = await prisma.subject.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubjectCreateManyAndReturnArgs>(args?: SelectSubset<T, SubjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subject.
     * @param {SubjectDeleteArgs} args - Arguments to delete one Subject.
     * @example
     * // Delete one Subject
     * const Subject = await prisma.subject.delete({
     *   where: {
     *     // ... filter to delete one Subject
     *   }
     * })
     * 
     */
    delete<T extends SubjectDeleteArgs>(args: SelectSubset<T, SubjectDeleteArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subject.
     * @param {SubjectUpdateArgs} args - Arguments to update one Subject.
     * @example
     * // Update one Subject
     * const subject = await prisma.subject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubjectUpdateArgs>(args: SelectSubset<T, SubjectUpdateArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subjects.
     * @param {SubjectDeleteManyArgs} args - Arguments to filter Subjects to delete.
     * @example
     * // Delete a few Subjects
     * const { count } = await prisma.subject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubjectDeleteManyArgs>(args?: SelectSubset<T, SubjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subjects
     * const subject = await prisma.subject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubjectUpdateManyArgs>(args: SelectSubset<T, SubjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects and returns the data updated in the database.
     * @param {SubjectUpdateManyAndReturnArgs} args - Arguments to update many Subjects.
     * @example
     * // Update many Subjects
     * const subject = await prisma.subject.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subjects and only return the `id`
     * const subjectWithIdOnly = await prisma.subject.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubjectUpdateManyAndReturnArgs>(args: SelectSubset<T, SubjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subject.
     * @param {SubjectUpsertArgs} args - Arguments to update or create a Subject.
     * @example
     * // Update or create a Subject
     * const subject = await prisma.subject.upsert({
     *   create: {
     *     // ... data to create a Subject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subject we want to update
     *   }
     * })
     */
    upsert<T extends SubjectUpsertArgs>(args: SelectSubset<T, SubjectUpsertArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectCountArgs} args - Arguments to filter Subjects to count.
     * @example
     * // Count the number of Subjects
     * const count = await prisma.subject.count({
     *   where: {
     *     // ... the filter for the Subjects we want to count
     *   }
     * })
    **/
    count<T extends SubjectCountArgs>(
      args?: Subset<T, SubjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubjectAggregateArgs>(args: Subset<T, SubjectAggregateArgs>): Prisma.PrismaPromise<GetSubjectAggregateType<T>>

    /**
     * Group by Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubjectGroupByArgs['orderBy'] }
        : { orderBy?: SubjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subject model
   */
  readonly fields: SubjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classes<T extends Subject$classesArgs<ExtArgs> = {}>(args?: Subset<T, Subject$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    results<T extends Subject$resultsArgs<ExtArgs> = {}>(args?: Subset<T, Subject$resultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    students<T extends Subject$studentsArgs<ExtArgs> = {}>(args?: Subset<T, Subject$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    department<T extends Subject$departmentArgs<ExtArgs> = {}>(args?: Subset<T, Subject$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    level<T extends Subject$levelArgs<ExtArgs> = {}>(args?: Subset<T, Subject$levelArgs<ExtArgs>>): Prisma__SchoolLevelClient<$Result.GetResult<Prisma.$SchoolLevelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    teachers<T extends Subject$teachersArgs<ExtArgs> = {}>(args?: Subset<T, Subject$teachersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectTeacherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subject model
   */ 
  interface SubjectFieldRefs {
    readonly id: FieldRef<"Subject", 'String'>
    readonly name: FieldRef<"Subject", 'String'>
    readonly code: FieldRef<"Subject", 'String'>
    readonly description: FieldRef<"Subject", 'String'>
    readonly schoolId: FieldRef<"Subject", 'String'>
    readonly departmentId: FieldRef<"Subject", 'String'>
    readonly levelId: FieldRef<"Subject", 'String'>
    readonly createdAt: FieldRef<"Subject", 'DateTime'>
    readonly updatedAt: FieldRef<"Subject", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subject findUnique
   */
  export type SubjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject findUniqueOrThrow
   */
  export type SubjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject findFirst
   */
  export type SubjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject findFirstOrThrow
   */
  export type SubjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject findMany
   */
  export type SubjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subjects to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject create
   */
  export type SubjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Subject.
     */
    data: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
  }

  /**
   * Subject createMany
   */
  export type SubjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subjects.
     */
    data: SubjectCreateManyInput | SubjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subject createManyAndReturn
   */
  export type SubjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * The data used to create many Subjects.
     */
    data: SubjectCreateManyInput | SubjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subject update
   */
  export type SubjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Subject.
     */
    data: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
    /**
     * Choose, which Subject to update.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject updateMany
   */
  export type SubjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subjects.
     */
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyInput>
    /**
     * Filter which Subjects to update
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to update.
     */
    limit?: number
  }

  /**
   * Subject updateManyAndReturn
   */
  export type SubjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * The data used to update Subjects.
     */
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyInput>
    /**
     * Filter which Subjects to update
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subject upsert
   */
  export type SubjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Subject to update in case it exists.
     */
    where: SubjectWhereUniqueInput
    /**
     * In case the Subject found by the `where` argument doesn't exist, create a new Subject with this data.
     */
    create: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
    /**
     * In case the Subject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
  }

  /**
   * Subject delete
   */
  export type SubjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter which Subject to delete.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject deleteMany
   */
  export type SubjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subjects to delete
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to delete.
     */
    limit?: number
  }

  /**
   * Subject.classes
   */
  export type Subject$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSubject
     */
    omit?: ClassSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectInclude<ExtArgs> | null
    where?: ClassSubjectWhereInput
    orderBy?: ClassSubjectOrderByWithRelationInput | ClassSubjectOrderByWithRelationInput[]
    cursor?: ClassSubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassSubjectScalarFieldEnum | ClassSubjectScalarFieldEnum[]
  }

  /**
   * Subject.results
   */
  export type Subject$resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Result
     */
    select?: ResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Result
     */
    omit?: ResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultInclude<ExtArgs> | null
    where?: ResultWhereInput
    orderBy?: ResultOrderByWithRelationInput | ResultOrderByWithRelationInput[]
    cursor?: ResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResultScalarFieldEnum | ResultScalarFieldEnum[]
  }

  /**
   * Subject.students
   */
  export type Subject$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSubject
     */
    omit?: StudentSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectInclude<ExtArgs> | null
    where?: StudentSubjectWhereInput
    orderBy?: StudentSubjectOrderByWithRelationInput | StudentSubjectOrderByWithRelationInput[]
    cursor?: StudentSubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSubjectScalarFieldEnum | StudentSubjectScalarFieldEnum[]
  }

  /**
   * Subject.department
   */
  export type Subject$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Subject.level
   */
  export type Subject$levelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLevel
     */
    select?: SchoolLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolLevel
     */
    omit?: SchoolLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLevelInclude<ExtArgs> | null
    where?: SchoolLevelWhereInput
  }

  /**
   * Subject.teachers
   */
  export type Subject$teachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectTeacher
     */
    select?: SubjectTeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubjectTeacher
     */
    omit?: SubjectTeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectTeacherInclude<ExtArgs> | null
    where?: SubjectTeacherWhereInput
    orderBy?: SubjectTeacherOrderByWithRelationInput | SubjectTeacherOrderByWithRelationInput[]
    cursor?: SubjectTeacherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectTeacherScalarFieldEnum | SubjectTeacherScalarFieldEnum[]
  }

  /**
   * Subject without action
   */
  export type SubjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
  }


  /**
   * Model AcademicSession
   */

  export type AggregateAcademicSession = {
    _count: AcademicSessionCountAggregateOutputType | null
    _min: AcademicSessionMinAggregateOutputType | null
    _max: AcademicSessionMaxAggregateOutputType | null
  }

  export type AcademicSessionMinAggregateOutputType = {
    id: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    isCurrent: boolean | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AcademicSessionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    isCurrent: boolean | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AcademicSessionCountAggregateOutputType = {
    id: number
    name: number
    startDate: number
    endDate: number
    isCurrent: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AcademicSessionMinAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
    isCurrent?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AcademicSessionMaxAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
    isCurrent?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AcademicSessionCountAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
    isCurrent?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AcademicSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicSession to aggregate.
     */
    where?: AcademicSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicSessions to fetch.
     */
    orderBy?: AcademicSessionOrderByWithRelationInput | AcademicSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AcademicSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AcademicSessions
    **/
    _count?: true | AcademicSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AcademicSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AcademicSessionMaxAggregateInputType
  }

  export type GetAcademicSessionAggregateType<T extends AcademicSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateAcademicSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcademicSession[P]>
      : GetScalarType<T[P], AggregateAcademicSession[P]>
  }




  export type AcademicSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicSessionWhereInput
    orderBy?: AcademicSessionOrderByWithAggregationInput | AcademicSessionOrderByWithAggregationInput[]
    by: AcademicSessionScalarFieldEnum[] | AcademicSessionScalarFieldEnum
    having?: AcademicSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AcademicSessionCountAggregateInputType | true
    _min?: AcademicSessionMinAggregateInputType
    _max?: AcademicSessionMaxAggregateInputType
  }

  export type AcademicSessionGroupByOutputType = {
    id: string
    name: string
    startDate: Date
    endDate: Date
    isCurrent: boolean
    schoolId: string
    createdAt: Date
    updatedAt: Date
    _count: AcademicSessionCountAggregateOutputType | null
    _min: AcademicSessionMinAggregateOutputType | null
    _max: AcademicSessionMaxAggregateOutputType | null
  }

  type GetAcademicSessionGroupByPayload<T extends AcademicSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcademicSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AcademicSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AcademicSessionGroupByOutputType[P]>
            : GetScalarType<T[P], AcademicSessionGroupByOutputType[P]>
        }
      >
    >


  export type AcademicSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    isCurrent?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    attendance?: boolean | AcademicSession$attendanceArgs<ExtArgs>
    results?: boolean | AcademicSession$resultsArgs<ExtArgs>
    studentClasses?: boolean | AcademicSession$studentClassesArgs<ExtArgs>
    resultConfigurations?: boolean | AcademicSession$resultConfigurationsArgs<ExtArgs>
    _count?: boolean | AcademicSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academicSession"]>

  export type AcademicSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    isCurrent?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academicSession"]>

  export type AcademicSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    isCurrent?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academicSession"]>

  export type AcademicSessionSelectScalar = {
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    isCurrent?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AcademicSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "startDate" | "endDate" | "isCurrent" | "schoolId" | "createdAt" | "updatedAt", ExtArgs["result"]["academicSession"]>
  export type AcademicSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    attendance?: boolean | AcademicSession$attendanceArgs<ExtArgs>
    results?: boolean | AcademicSession$resultsArgs<ExtArgs>
    studentClasses?: boolean | AcademicSession$studentClassesArgs<ExtArgs>
    resultConfigurations?: boolean | AcademicSession$resultConfigurationsArgs<ExtArgs>
    _count?: boolean | AcademicSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AcademicSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type AcademicSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $AcademicSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AcademicSession"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      attendance: Prisma.$AttendancePayload<ExtArgs>[]
      results: Prisma.$ResultPayload<ExtArgs>[]
      studentClasses: Prisma.$StudentClassPayload<ExtArgs>[]
      resultConfigurations: Prisma.$ResultConfigurationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      startDate: Date
      endDate: Date
      isCurrent: boolean
      schoolId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["academicSession"]>
    composites: {}
  }

  type AcademicSessionGetPayload<S extends boolean | null | undefined | AcademicSessionDefaultArgs> = $Result.GetResult<Prisma.$AcademicSessionPayload, S>

  type AcademicSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AcademicSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AcademicSessionCountAggregateInputType | true
    }

  export interface AcademicSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AcademicSession'], meta: { name: 'AcademicSession' } }
    /**
     * Find zero or one AcademicSession that matches the filter.
     * @param {AcademicSessionFindUniqueArgs} args - Arguments to find a AcademicSession
     * @example
     * // Get one AcademicSession
     * const academicSession = await prisma.academicSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AcademicSessionFindUniqueArgs>(args: SelectSubset<T, AcademicSessionFindUniqueArgs<ExtArgs>>): Prisma__AcademicSessionClient<$Result.GetResult<Prisma.$AcademicSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AcademicSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AcademicSessionFindUniqueOrThrowArgs} args - Arguments to find a AcademicSession
     * @example
     * // Get one AcademicSession
     * const academicSession = await prisma.academicSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AcademicSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, AcademicSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AcademicSessionClient<$Result.GetResult<Prisma.$AcademicSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AcademicSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicSessionFindFirstArgs} args - Arguments to find a AcademicSession
     * @example
     * // Get one AcademicSession
     * const academicSession = await prisma.academicSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AcademicSessionFindFirstArgs>(args?: SelectSubset<T, AcademicSessionFindFirstArgs<ExtArgs>>): Prisma__AcademicSessionClient<$Result.GetResult<Prisma.$AcademicSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AcademicSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicSessionFindFirstOrThrowArgs} args - Arguments to find a AcademicSession
     * @example
     * // Get one AcademicSession
     * const academicSession = await prisma.academicSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AcademicSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, AcademicSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AcademicSessionClient<$Result.GetResult<Prisma.$AcademicSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AcademicSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AcademicSessions
     * const academicSessions = await prisma.academicSession.findMany()
     * 
     * // Get first 10 AcademicSessions
     * const academicSessions = await prisma.academicSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const academicSessionWithIdOnly = await prisma.academicSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AcademicSessionFindManyArgs>(args?: SelectSubset<T, AcademicSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AcademicSession.
     * @param {AcademicSessionCreateArgs} args - Arguments to create a AcademicSession.
     * @example
     * // Create one AcademicSession
     * const AcademicSession = await prisma.academicSession.create({
     *   data: {
     *     // ... data to create a AcademicSession
     *   }
     * })
     * 
     */
    create<T extends AcademicSessionCreateArgs>(args: SelectSubset<T, AcademicSessionCreateArgs<ExtArgs>>): Prisma__AcademicSessionClient<$Result.GetResult<Prisma.$AcademicSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AcademicSessions.
     * @param {AcademicSessionCreateManyArgs} args - Arguments to create many AcademicSessions.
     * @example
     * // Create many AcademicSessions
     * const academicSession = await prisma.academicSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AcademicSessionCreateManyArgs>(args?: SelectSubset<T, AcademicSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AcademicSessions and returns the data saved in the database.
     * @param {AcademicSessionCreateManyAndReturnArgs} args - Arguments to create many AcademicSessions.
     * @example
     * // Create many AcademicSessions
     * const academicSession = await prisma.academicSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AcademicSessions and only return the `id`
     * const academicSessionWithIdOnly = await prisma.academicSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AcademicSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, AcademicSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AcademicSession.
     * @param {AcademicSessionDeleteArgs} args - Arguments to delete one AcademicSession.
     * @example
     * // Delete one AcademicSession
     * const AcademicSession = await prisma.academicSession.delete({
     *   where: {
     *     // ... filter to delete one AcademicSession
     *   }
     * })
     * 
     */
    delete<T extends AcademicSessionDeleteArgs>(args: SelectSubset<T, AcademicSessionDeleteArgs<ExtArgs>>): Prisma__AcademicSessionClient<$Result.GetResult<Prisma.$AcademicSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AcademicSession.
     * @param {AcademicSessionUpdateArgs} args - Arguments to update one AcademicSession.
     * @example
     * // Update one AcademicSession
     * const academicSession = await prisma.academicSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AcademicSessionUpdateArgs>(args: SelectSubset<T, AcademicSessionUpdateArgs<ExtArgs>>): Prisma__AcademicSessionClient<$Result.GetResult<Prisma.$AcademicSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AcademicSessions.
     * @param {AcademicSessionDeleteManyArgs} args - Arguments to filter AcademicSessions to delete.
     * @example
     * // Delete a few AcademicSessions
     * const { count } = await prisma.academicSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AcademicSessionDeleteManyArgs>(args?: SelectSubset<T, AcademicSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AcademicSessions
     * const academicSession = await prisma.academicSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AcademicSessionUpdateManyArgs>(args: SelectSubset<T, AcademicSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicSessions and returns the data updated in the database.
     * @param {AcademicSessionUpdateManyAndReturnArgs} args - Arguments to update many AcademicSessions.
     * @example
     * // Update many AcademicSessions
     * const academicSession = await prisma.academicSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AcademicSessions and only return the `id`
     * const academicSessionWithIdOnly = await prisma.academicSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AcademicSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, AcademicSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AcademicSession.
     * @param {AcademicSessionUpsertArgs} args - Arguments to update or create a AcademicSession.
     * @example
     * // Update or create a AcademicSession
     * const academicSession = await prisma.academicSession.upsert({
     *   create: {
     *     // ... data to create a AcademicSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AcademicSession we want to update
     *   }
     * })
     */
    upsert<T extends AcademicSessionUpsertArgs>(args: SelectSubset<T, AcademicSessionUpsertArgs<ExtArgs>>): Prisma__AcademicSessionClient<$Result.GetResult<Prisma.$AcademicSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AcademicSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicSessionCountArgs} args - Arguments to filter AcademicSessions to count.
     * @example
     * // Count the number of AcademicSessions
     * const count = await prisma.academicSession.count({
     *   where: {
     *     // ... the filter for the AcademicSessions we want to count
     *   }
     * })
    **/
    count<T extends AcademicSessionCountArgs>(
      args?: Subset<T, AcademicSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AcademicSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AcademicSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AcademicSessionAggregateArgs>(args: Subset<T, AcademicSessionAggregateArgs>): Prisma.PrismaPromise<GetAcademicSessionAggregateType<T>>

    /**
     * Group by AcademicSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AcademicSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcademicSessionGroupByArgs['orderBy'] }
        : { orderBy?: AcademicSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AcademicSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcademicSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AcademicSession model
   */
  readonly fields: AcademicSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AcademicSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcademicSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attendance<T extends AcademicSession$attendanceArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSession$attendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    results<T extends AcademicSession$resultsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSession$resultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentClasses<T extends AcademicSession$studentClassesArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSession$studentClassesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    resultConfigurations<T extends AcademicSession$resultConfigurationsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSession$resultConfigurationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultConfigurationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AcademicSession model
   */ 
  interface AcademicSessionFieldRefs {
    readonly id: FieldRef<"AcademicSession", 'String'>
    readonly name: FieldRef<"AcademicSession", 'String'>
    readonly startDate: FieldRef<"AcademicSession", 'DateTime'>
    readonly endDate: FieldRef<"AcademicSession", 'DateTime'>
    readonly isCurrent: FieldRef<"AcademicSession", 'Boolean'>
    readonly schoolId: FieldRef<"AcademicSession", 'String'>
    readonly createdAt: FieldRef<"AcademicSession", 'DateTime'>
    readonly updatedAt: FieldRef<"AcademicSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AcademicSession findUnique
   */
  export type AcademicSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSession
     */
    select?: AcademicSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSession
     */
    omit?: AcademicSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSessionInclude<ExtArgs> | null
    /**
     * Filter, which AcademicSession to fetch.
     */
    where: AcademicSessionWhereUniqueInput
  }

  /**
   * AcademicSession findUniqueOrThrow
   */
  export type AcademicSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSession
     */
    select?: AcademicSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSession
     */
    omit?: AcademicSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSessionInclude<ExtArgs> | null
    /**
     * Filter, which AcademicSession to fetch.
     */
    where: AcademicSessionWhereUniqueInput
  }

  /**
   * AcademicSession findFirst
   */
  export type AcademicSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSession
     */
    select?: AcademicSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSession
     */
    omit?: AcademicSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSessionInclude<ExtArgs> | null
    /**
     * Filter, which AcademicSession to fetch.
     */
    where?: AcademicSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicSessions to fetch.
     */
    orderBy?: AcademicSessionOrderByWithRelationInput | AcademicSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicSessions.
     */
    cursor?: AcademicSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicSessions.
     */
    distinct?: AcademicSessionScalarFieldEnum | AcademicSessionScalarFieldEnum[]
  }

  /**
   * AcademicSession findFirstOrThrow
   */
  export type AcademicSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSession
     */
    select?: AcademicSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSession
     */
    omit?: AcademicSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSessionInclude<ExtArgs> | null
    /**
     * Filter, which AcademicSession to fetch.
     */
    where?: AcademicSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicSessions to fetch.
     */
    orderBy?: AcademicSessionOrderByWithRelationInput | AcademicSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicSessions.
     */
    cursor?: AcademicSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicSessions.
     */
    distinct?: AcademicSessionScalarFieldEnum | AcademicSessionScalarFieldEnum[]
  }

  /**
   * AcademicSession findMany
   */
  export type AcademicSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSession
     */
    select?: AcademicSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSession
     */
    omit?: AcademicSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSessionInclude<ExtArgs> | null
    /**
     * Filter, which AcademicSessions to fetch.
     */
    where?: AcademicSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicSessions to fetch.
     */
    orderBy?: AcademicSessionOrderByWithRelationInput | AcademicSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AcademicSessions.
     */
    cursor?: AcademicSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicSessions.
     */
    skip?: number
    distinct?: AcademicSessionScalarFieldEnum | AcademicSessionScalarFieldEnum[]
  }

  /**
   * AcademicSession create
   */
  export type AcademicSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSession
     */
    select?: AcademicSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSession
     */
    omit?: AcademicSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a AcademicSession.
     */
    data: XOR<AcademicSessionCreateInput, AcademicSessionUncheckedCreateInput>
  }

  /**
   * AcademicSession createMany
   */
  export type AcademicSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AcademicSessions.
     */
    data: AcademicSessionCreateManyInput | AcademicSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AcademicSession createManyAndReturn
   */
  export type AcademicSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSession
     */
    select?: AcademicSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSession
     */
    omit?: AcademicSessionOmit<ExtArgs> | null
    /**
     * The data used to create many AcademicSessions.
     */
    data: AcademicSessionCreateManyInput | AcademicSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AcademicSession update
   */
  export type AcademicSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSession
     */
    select?: AcademicSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSession
     */
    omit?: AcademicSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a AcademicSession.
     */
    data: XOR<AcademicSessionUpdateInput, AcademicSessionUncheckedUpdateInput>
    /**
     * Choose, which AcademicSession to update.
     */
    where: AcademicSessionWhereUniqueInput
  }

  /**
   * AcademicSession updateMany
   */
  export type AcademicSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AcademicSessions.
     */
    data: XOR<AcademicSessionUpdateManyMutationInput, AcademicSessionUncheckedUpdateManyInput>
    /**
     * Filter which AcademicSessions to update
     */
    where?: AcademicSessionWhereInput
    /**
     * Limit how many AcademicSessions to update.
     */
    limit?: number
  }

  /**
   * AcademicSession updateManyAndReturn
   */
  export type AcademicSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSession
     */
    select?: AcademicSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSession
     */
    omit?: AcademicSessionOmit<ExtArgs> | null
    /**
     * The data used to update AcademicSessions.
     */
    data: XOR<AcademicSessionUpdateManyMutationInput, AcademicSessionUncheckedUpdateManyInput>
    /**
     * Filter which AcademicSessions to update
     */
    where?: AcademicSessionWhereInput
    /**
     * Limit how many AcademicSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AcademicSession upsert
   */
  export type AcademicSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSession
     */
    select?: AcademicSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSession
     */
    omit?: AcademicSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the AcademicSession to update in case it exists.
     */
    where: AcademicSessionWhereUniqueInput
    /**
     * In case the AcademicSession found by the `where` argument doesn't exist, create a new AcademicSession with this data.
     */
    create: XOR<AcademicSessionCreateInput, AcademicSessionUncheckedCreateInput>
    /**
     * In case the AcademicSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AcademicSessionUpdateInput, AcademicSessionUncheckedUpdateInput>
  }

  /**
   * AcademicSession delete
   */
  export type AcademicSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSession
     */
    select?: AcademicSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSession
     */
    omit?: AcademicSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSessionInclude<ExtArgs> | null
    /**
     * Filter which AcademicSession to delete.
     */
    where: AcademicSessionWhereUniqueInput
  }

  /**
   * AcademicSession deleteMany
   */
  export type AcademicSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicSessions to delete
     */
    where?: AcademicSessionWhereInput
    /**
     * Limit how many AcademicSessions to delete.
     */
    limit?: number
  }

  /**
   * AcademicSession.attendance
   */
  export type AcademicSession$attendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * AcademicSession.results
   */
  export type AcademicSession$resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Result
     */
    select?: ResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Result
     */
    omit?: ResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultInclude<ExtArgs> | null
    where?: ResultWhereInput
    orderBy?: ResultOrderByWithRelationInput | ResultOrderByWithRelationInput[]
    cursor?: ResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResultScalarFieldEnum | ResultScalarFieldEnum[]
  }

  /**
   * AcademicSession.studentClasses
   */
  export type AcademicSession$studentClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentClass
     */
    select?: StudentClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentClass
     */
    omit?: StudentClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentClassInclude<ExtArgs> | null
    where?: StudentClassWhereInput
    orderBy?: StudentClassOrderByWithRelationInput | StudentClassOrderByWithRelationInput[]
    cursor?: StudentClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentClassScalarFieldEnum | StudentClassScalarFieldEnum[]
  }

  /**
   * AcademicSession.resultConfigurations
   */
  export type AcademicSession$resultConfigurationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultConfiguration
     */
    select?: ResultConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultConfiguration
     */
    omit?: ResultConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultConfigurationInclude<ExtArgs> | null
    where?: ResultConfigurationWhereInput
    orderBy?: ResultConfigurationOrderByWithRelationInput | ResultConfigurationOrderByWithRelationInput[]
    cursor?: ResultConfigurationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResultConfigurationScalarFieldEnum | ResultConfigurationScalarFieldEnum[]
  }

  /**
   * AcademicSession without action
   */
  export type AcademicSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSession
     */
    select?: AcademicSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSession
     */
    omit?: AcademicSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSessionInclude<ExtArgs> | null
  }


  /**
   * Model StudentClass
   */

  export type AggregateStudentClass = {
    _count: StudentClassCountAggregateOutputType | null
    _min: StudentClassMinAggregateOutputType | null
    _max: StudentClassMaxAggregateOutputType | null
  }

  export type StudentClassMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    classId: string | null
    sessionId: string | null
    rollNumber: string | null
    status: $Enums.EnrollmentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentClassMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    classId: string | null
    sessionId: string | null
    rollNumber: string | null
    status: $Enums.EnrollmentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentClassCountAggregateOutputType = {
    id: number
    studentId: number
    classId: number
    sessionId: number
    rollNumber: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentClassMinAggregateInputType = {
    id?: true
    studentId?: true
    classId?: true
    sessionId?: true
    rollNumber?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentClassMaxAggregateInputType = {
    id?: true
    studentId?: true
    classId?: true
    sessionId?: true
    rollNumber?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentClassCountAggregateInputType = {
    id?: true
    studentId?: true
    classId?: true
    sessionId?: true
    rollNumber?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentClass to aggregate.
     */
    where?: StudentClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentClasses to fetch.
     */
    orderBy?: StudentClassOrderByWithRelationInput | StudentClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentClasses
    **/
    _count?: true | StudentClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentClassMaxAggregateInputType
  }

  export type GetStudentClassAggregateType<T extends StudentClassAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentClass[P]>
      : GetScalarType<T[P], AggregateStudentClass[P]>
  }




  export type StudentClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentClassWhereInput
    orderBy?: StudentClassOrderByWithAggregationInput | StudentClassOrderByWithAggregationInput[]
    by: StudentClassScalarFieldEnum[] | StudentClassScalarFieldEnum
    having?: StudentClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentClassCountAggregateInputType | true
    _min?: StudentClassMinAggregateInputType
    _max?: StudentClassMaxAggregateInputType
  }

  export type StudentClassGroupByOutputType = {
    id: string
    studentId: string
    classId: string
    sessionId: string
    rollNumber: string | null
    status: $Enums.EnrollmentStatus
    createdAt: Date
    updatedAt: Date
    _count: StudentClassCountAggregateOutputType | null
    _min: StudentClassMinAggregateOutputType | null
    _max: StudentClassMaxAggregateOutputType | null
  }

  type GetStudentClassGroupByPayload<T extends StudentClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentClassGroupByOutputType[P]>
            : GetScalarType<T[P], StudentClassGroupByOutputType[P]>
        }
      >
    >


  export type StudentClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    classId?: boolean
    sessionId?: boolean
    rollNumber?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    session?: boolean | AcademicSessionDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentClass"]>

  export type StudentClassSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    classId?: boolean
    sessionId?: boolean
    rollNumber?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    session?: boolean | AcademicSessionDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentClass"]>

  export type StudentClassSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    classId?: boolean
    sessionId?: boolean
    rollNumber?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    session?: boolean | AcademicSessionDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentClass"]>

  export type StudentClassSelectScalar = {
    id?: boolean
    studentId?: boolean
    classId?: boolean
    sessionId?: boolean
    rollNumber?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentClassOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "classId" | "sessionId" | "rollNumber" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["studentClass"]>
  export type StudentClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    session?: boolean | AcademicSessionDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type StudentClassIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    session?: boolean | AcademicSessionDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type StudentClassIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    session?: boolean | AcademicSessionDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $StudentClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentClass"
    objects: {
      class: Prisma.$ClassPayload<ExtArgs>
      session: Prisma.$AcademicSessionPayload<ExtArgs>
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      classId: string
      sessionId: string
      rollNumber: string | null
      status: $Enums.EnrollmentStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studentClass"]>
    composites: {}
  }

  type StudentClassGetPayload<S extends boolean | null | undefined | StudentClassDefaultArgs> = $Result.GetResult<Prisma.$StudentClassPayload, S>

  type StudentClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentClassFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentClassCountAggregateInputType | true
    }

  export interface StudentClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentClass'], meta: { name: 'StudentClass' } }
    /**
     * Find zero or one StudentClass that matches the filter.
     * @param {StudentClassFindUniqueArgs} args - Arguments to find a StudentClass
     * @example
     * // Get one StudentClass
     * const studentClass = await prisma.studentClass.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentClassFindUniqueArgs>(args: SelectSubset<T, StudentClassFindUniqueArgs<ExtArgs>>): Prisma__StudentClassClient<$Result.GetResult<Prisma.$StudentClassPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentClass that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentClassFindUniqueOrThrowArgs} args - Arguments to find a StudentClass
     * @example
     * // Get one StudentClass
     * const studentClass = await prisma.studentClass.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentClassFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentClassClient<$Result.GetResult<Prisma.$StudentClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentClass that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentClassFindFirstArgs} args - Arguments to find a StudentClass
     * @example
     * // Get one StudentClass
     * const studentClass = await prisma.studentClass.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentClassFindFirstArgs>(args?: SelectSubset<T, StudentClassFindFirstArgs<ExtArgs>>): Prisma__StudentClassClient<$Result.GetResult<Prisma.$StudentClassPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentClass that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentClassFindFirstOrThrowArgs} args - Arguments to find a StudentClass
     * @example
     * // Get one StudentClass
     * const studentClass = await prisma.studentClass.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentClassFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentClassClient<$Result.GetResult<Prisma.$StudentClassPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentClasses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentClasses
     * const studentClasses = await prisma.studentClass.findMany()
     * 
     * // Get first 10 StudentClasses
     * const studentClasses = await prisma.studentClass.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentClassWithIdOnly = await prisma.studentClass.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentClassFindManyArgs>(args?: SelectSubset<T, StudentClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentClass.
     * @param {StudentClassCreateArgs} args - Arguments to create a StudentClass.
     * @example
     * // Create one StudentClass
     * const StudentClass = await prisma.studentClass.create({
     *   data: {
     *     // ... data to create a StudentClass
     *   }
     * })
     * 
     */
    create<T extends StudentClassCreateArgs>(args: SelectSubset<T, StudentClassCreateArgs<ExtArgs>>): Prisma__StudentClassClient<$Result.GetResult<Prisma.$StudentClassPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentClasses.
     * @param {StudentClassCreateManyArgs} args - Arguments to create many StudentClasses.
     * @example
     * // Create many StudentClasses
     * const studentClass = await prisma.studentClass.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentClassCreateManyArgs>(args?: SelectSubset<T, StudentClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentClasses and returns the data saved in the database.
     * @param {StudentClassCreateManyAndReturnArgs} args - Arguments to create many StudentClasses.
     * @example
     * // Create many StudentClasses
     * const studentClass = await prisma.studentClass.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentClasses and only return the `id`
     * const studentClassWithIdOnly = await prisma.studentClass.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentClassCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentClassCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentClassPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudentClass.
     * @param {StudentClassDeleteArgs} args - Arguments to delete one StudentClass.
     * @example
     * // Delete one StudentClass
     * const StudentClass = await prisma.studentClass.delete({
     *   where: {
     *     // ... filter to delete one StudentClass
     *   }
     * })
     * 
     */
    delete<T extends StudentClassDeleteArgs>(args: SelectSubset<T, StudentClassDeleteArgs<ExtArgs>>): Prisma__StudentClassClient<$Result.GetResult<Prisma.$StudentClassPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentClass.
     * @param {StudentClassUpdateArgs} args - Arguments to update one StudentClass.
     * @example
     * // Update one StudentClass
     * const studentClass = await prisma.studentClass.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentClassUpdateArgs>(args: SelectSubset<T, StudentClassUpdateArgs<ExtArgs>>): Prisma__StudentClassClient<$Result.GetResult<Prisma.$StudentClassPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentClasses.
     * @param {StudentClassDeleteManyArgs} args - Arguments to filter StudentClasses to delete.
     * @example
     * // Delete a few StudentClasses
     * const { count } = await prisma.studentClass.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentClassDeleteManyArgs>(args?: SelectSubset<T, StudentClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentClasses
     * const studentClass = await prisma.studentClass.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentClassUpdateManyArgs>(args: SelectSubset<T, StudentClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentClasses and returns the data updated in the database.
     * @param {StudentClassUpdateManyAndReturnArgs} args - Arguments to update many StudentClasses.
     * @example
     * // Update many StudentClasses
     * const studentClass = await prisma.studentClass.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudentClasses and only return the `id`
     * const studentClassWithIdOnly = await prisma.studentClass.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentClassUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentClassUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentClassPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudentClass.
     * @param {StudentClassUpsertArgs} args - Arguments to update or create a StudentClass.
     * @example
     * // Update or create a StudentClass
     * const studentClass = await prisma.studentClass.upsert({
     *   create: {
     *     // ... data to create a StudentClass
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentClass we want to update
     *   }
     * })
     */
    upsert<T extends StudentClassUpsertArgs>(args: SelectSubset<T, StudentClassUpsertArgs<ExtArgs>>): Prisma__StudentClassClient<$Result.GetResult<Prisma.$StudentClassPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentClassCountArgs} args - Arguments to filter StudentClasses to count.
     * @example
     * // Count the number of StudentClasses
     * const count = await prisma.studentClass.count({
     *   where: {
     *     // ... the filter for the StudentClasses we want to count
     *   }
     * })
    **/
    count<T extends StudentClassCountArgs>(
      args?: Subset<T, StudentClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentClass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentClassAggregateArgs>(args: Subset<T, StudentClassAggregateArgs>): Prisma.PrismaPromise<GetStudentClassAggregateType<T>>

    /**
     * Group by StudentClass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentClassGroupByArgs['orderBy'] }
        : { orderBy?: StudentClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentClass model
   */
  readonly fields: StudentClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentClass.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    session<T extends AcademicSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSessionDefaultArgs<ExtArgs>>): Prisma__AcademicSessionClient<$Result.GetResult<Prisma.$AcademicSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentClass model
   */ 
  interface StudentClassFieldRefs {
    readonly id: FieldRef<"StudentClass", 'String'>
    readonly studentId: FieldRef<"StudentClass", 'String'>
    readonly classId: FieldRef<"StudentClass", 'String'>
    readonly sessionId: FieldRef<"StudentClass", 'String'>
    readonly rollNumber: FieldRef<"StudentClass", 'String'>
    readonly status: FieldRef<"StudentClass", 'EnrollmentStatus'>
    readonly createdAt: FieldRef<"StudentClass", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentClass", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentClass findUnique
   */
  export type StudentClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentClass
     */
    select?: StudentClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentClass
     */
    omit?: StudentClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentClassInclude<ExtArgs> | null
    /**
     * Filter, which StudentClass to fetch.
     */
    where: StudentClassWhereUniqueInput
  }

  /**
   * StudentClass findUniqueOrThrow
   */
  export type StudentClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentClass
     */
    select?: StudentClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentClass
     */
    omit?: StudentClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentClassInclude<ExtArgs> | null
    /**
     * Filter, which StudentClass to fetch.
     */
    where: StudentClassWhereUniqueInput
  }

  /**
   * StudentClass findFirst
   */
  export type StudentClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentClass
     */
    select?: StudentClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentClass
     */
    omit?: StudentClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentClassInclude<ExtArgs> | null
    /**
     * Filter, which StudentClass to fetch.
     */
    where?: StudentClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentClasses to fetch.
     */
    orderBy?: StudentClassOrderByWithRelationInput | StudentClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentClasses.
     */
    cursor?: StudentClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentClasses.
     */
    distinct?: StudentClassScalarFieldEnum | StudentClassScalarFieldEnum[]
  }

  /**
   * StudentClass findFirstOrThrow
   */
  export type StudentClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentClass
     */
    select?: StudentClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentClass
     */
    omit?: StudentClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentClassInclude<ExtArgs> | null
    /**
     * Filter, which StudentClass to fetch.
     */
    where?: StudentClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentClasses to fetch.
     */
    orderBy?: StudentClassOrderByWithRelationInput | StudentClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentClasses.
     */
    cursor?: StudentClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentClasses.
     */
    distinct?: StudentClassScalarFieldEnum | StudentClassScalarFieldEnum[]
  }

  /**
   * StudentClass findMany
   */
  export type StudentClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentClass
     */
    select?: StudentClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentClass
     */
    omit?: StudentClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentClassInclude<ExtArgs> | null
    /**
     * Filter, which StudentClasses to fetch.
     */
    where?: StudentClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentClasses to fetch.
     */
    orderBy?: StudentClassOrderByWithRelationInput | StudentClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentClasses.
     */
    cursor?: StudentClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentClasses.
     */
    skip?: number
    distinct?: StudentClassScalarFieldEnum | StudentClassScalarFieldEnum[]
  }

  /**
   * StudentClass create
   */
  export type StudentClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentClass
     */
    select?: StudentClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentClass
     */
    omit?: StudentClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentClassInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentClass.
     */
    data: XOR<StudentClassCreateInput, StudentClassUncheckedCreateInput>
  }

  /**
   * StudentClass createMany
   */
  export type StudentClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentClasses.
     */
    data: StudentClassCreateManyInput | StudentClassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentClass createManyAndReturn
   */
  export type StudentClassCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentClass
     */
    select?: StudentClassSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentClass
     */
    omit?: StudentClassOmit<ExtArgs> | null
    /**
     * The data used to create many StudentClasses.
     */
    data: StudentClassCreateManyInput | StudentClassCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentClassIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentClass update
   */
  export type StudentClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentClass
     */
    select?: StudentClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentClass
     */
    omit?: StudentClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentClassInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentClass.
     */
    data: XOR<StudentClassUpdateInput, StudentClassUncheckedUpdateInput>
    /**
     * Choose, which StudentClass to update.
     */
    where: StudentClassWhereUniqueInput
  }

  /**
   * StudentClass updateMany
   */
  export type StudentClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentClasses.
     */
    data: XOR<StudentClassUpdateManyMutationInput, StudentClassUncheckedUpdateManyInput>
    /**
     * Filter which StudentClasses to update
     */
    where?: StudentClassWhereInput
    /**
     * Limit how many StudentClasses to update.
     */
    limit?: number
  }

  /**
   * StudentClass updateManyAndReturn
   */
  export type StudentClassUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentClass
     */
    select?: StudentClassSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentClass
     */
    omit?: StudentClassOmit<ExtArgs> | null
    /**
     * The data used to update StudentClasses.
     */
    data: XOR<StudentClassUpdateManyMutationInput, StudentClassUncheckedUpdateManyInput>
    /**
     * Filter which StudentClasses to update
     */
    where?: StudentClassWhereInput
    /**
     * Limit how many StudentClasses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentClassIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentClass upsert
   */
  export type StudentClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentClass
     */
    select?: StudentClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentClass
     */
    omit?: StudentClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentClassInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentClass to update in case it exists.
     */
    where: StudentClassWhereUniqueInput
    /**
     * In case the StudentClass found by the `where` argument doesn't exist, create a new StudentClass with this data.
     */
    create: XOR<StudentClassCreateInput, StudentClassUncheckedCreateInput>
    /**
     * In case the StudentClass was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentClassUpdateInput, StudentClassUncheckedUpdateInput>
  }

  /**
   * StudentClass delete
   */
  export type StudentClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentClass
     */
    select?: StudentClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentClass
     */
    omit?: StudentClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentClassInclude<ExtArgs> | null
    /**
     * Filter which StudentClass to delete.
     */
    where: StudentClassWhereUniqueInput
  }

  /**
   * StudentClass deleteMany
   */
  export type StudentClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentClasses to delete
     */
    where?: StudentClassWhereInput
    /**
     * Limit how many StudentClasses to delete.
     */
    limit?: number
  }

  /**
   * StudentClass without action
   */
  export type StudentClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentClass
     */
    select?: StudentClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentClass
     */
    omit?: StudentClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentClassInclude<ExtArgs> | null
  }


  /**
   * Model StudentParent
   */

  export type AggregateStudentParent = {
    _count: StudentParentCountAggregateOutputType | null
    _min: StudentParentMinAggregateOutputType | null
    _max: StudentParentMaxAggregateOutputType | null
  }

  export type StudentParentMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    parentId: string | null
    relation: string | null
    isPrimary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentParentMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    parentId: string | null
    relation: string | null
    isPrimary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentParentCountAggregateOutputType = {
    id: number
    studentId: number
    parentId: number
    relation: number
    isPrimary: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentParentMinAggregateInputType = {
    id?: true
    studentId?: true
    parentId?: true
    relation?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentParentMaxAggregateInputType = {
    id?: true
    studentId?: true
    parentId?: true
    relation?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentParentCountAggregateInputType = {
    id?: true
    studentId?: true
    parentId?: true
    relation?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentParentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentParent to aggregate.
     */
    where?: StudentParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentParents to fetch.
     */
    orderBy?: StudentParentOrderByWithRelationInput | StudentParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentParents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentParents
    **/
    _count?: true | StudentParentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentParentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentParentMaxAggregateInputType
  }

  export type GetStudentParentAggregateType<T extends StudentParentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentParent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentParent[P]>
      : GetScalarType<T[P], AggregateStudentParent[P]>
  }




  export type StudentParentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentParentWhereInput
    orderBy?: StudentParentOrderByWithAggregationInput | StudentParentOrderByWithAggregationInput[]
    by: StudentParentScalarFieldEnum[] | StudentParentScalarFieldEnum
    having?: StudentParentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentParentCountAggregateInputType | true
    _min?: StudentParentMinAggregateInputType
    _max?: StudentParentMaxAggregateInputType
  }

  export type StudentParentGroupByOutputType = {
    id: string
    studentId: string
    parentId: string
    relation: string | null
    isPrimary: boolean
    createdAt: Date
    updatedAt: Date
    _count: StudentParentCountAggregateOutputType | null
    _min: StudentParentMinAggregateOutputType | null
    _max: StudentParentMaxAggregateOutputType | null
  }

  type GetStudentParentGroupByPayload<T extends StudentParentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentParentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentParentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentParentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentParentGroupByOutputType[P]>
        }
      >
    >


  export type StudentParentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    parentId?: boolean
    relation?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | ParentDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentParent"]>

  export type StudentParentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    parentId?: boolean
    relation?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | ParentDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentParent"]>

  export type StudentParentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    parentId?: boolean
    relation?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | ParentDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentParent"]>

  export type StudentParentSelectScalar = {
    id?: boolean
    studentId?: boolean
    parentId?: boolean
    relation?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentParentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "parentId" | "relation" | "isPrimary" | "createdAt" | "updatedAt", ExtArgs["result"]["studentParent"]>
  export type StudentParentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | ParentDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type StudentParentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | ParentDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type StudentParentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | ParentDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $StudentParentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentParent"
    objects: {
      parent: Prisma.$ParentPayload<ExtArgs>
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      parentId: string
      relation: string | null
      isPrimary: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studentParent"]>
    composites: {}
  }

  type StudentParentGetPayload<S extends boolean | null | undefined | StudentParentDefaultArgs> = $Result.GetResult<Prisma.$StudentParentPayload, S>

  type StudentParentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentParentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentParentCountAggregateInputType | true
    }

  export interface StudentParentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentParent'], meta: { name: 'StudentParent' } }
    /**
     * Find zero or one StudentParent that matches the filter.
     * @param {StudentParentFindUniqueArgs} args - Arguments to find a StudentParent
     * @example
     * // Get one StudentParent
     * const studentParent = await prisma.studentParent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentParentFindUniqueArgs>(args: SelectSubset<T, StudentParentFindUniqueArgs<ExtArgs>>): Prisma__StudentParentClient<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentParent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentParentFindUniqueOrThrowArgs} args - Arguments to find a StudentParent
     * @example
     * // Get one StudentParent
     * const studentParent = await prisma.studentParent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentParentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentParentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentParentClient<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentParent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentFindFirstArgs} args - Arguments to find a StudentParent
     * @example
     * // Get one StudentParent
     * const studentParent = await prisma.studentParent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentParentFindFirstArgs>(args?: SelectSubset<T, StudentParentFindFirstArgs<ExtArgs>>): Prisma__StudentParentClient<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentParent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentFindFirstOrThrowArgs} args - Arguments to find a StudentParent
     * @example
     * // Get one StudentParent
     * const studentParent = await prisma.studentParent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentParentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentParentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentParentClient<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentParents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentParents
     * const studentParents = await prisma.studentParent.findMany()
     * 
     * // Get first 10 StudentParents
     * const studentParents = await prisma.studentParent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentParentWithIdOnly = await prisma.studentParent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentParentFindManyArgs>(args?: SelectSubset<T, StudentParentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentParent.
     * @param {StudentParentCreateArgs} args - Arguments to create a StudentParent.
     * @example
     * // Create one StudentParent
     * const StudentParent = await prisma.studentParent.create({
     *   data: {
     *     // ... data to create a StudentParent
     *   }
     * })
     * 
     */
    create<T extends StudentParentCreateArgs>(args: SelectSubset<T, StudentParentCreateArgs<ExtArgs>>): Prisma__StudentParentClient<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentParents.
     * @param {StudentParentCreateManyArgs} args - Arguments to create many StudentParents.
     * @example
     * // Create many StudentParents
     * const studentParent = await prisma.studentParent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentParentCreateManyArgs>(args?: SelectSubset<T, StudentParentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentParents and returns the data saved in the database.
     * @param {StudentParentCreateManyAndReturnArgs} args - Arguments to create many StudentParents.
     * @example
     * // Create many StudentParents
     * const studentParent = await prisma.studentParent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentParents and only return the `id`
     * const studentParentWithIdOnly = await prisma.studentParent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentParentCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentParentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudentParent.
     * @param {StudentParentDeleteArgs} args - Arguments to delete one StudentParent.
     * @example
     * // Delete one StudentParent
     * const StudentParent = await prisma.studentParent.delete({
     *   where: {
     *     // ... filter to delete one StudentParent
     *   }
     * })
     * 
     */
    delete<T extends StudentParentDeleteArgs>(args: SelectSubset<T, StudentParentDeleteArgs<ExtArgs>>): Prisma__StudentParentClient<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentParent.
     * @param {StudentParentUpdateArgs} args - Arguments to update one StudentParent.
     * @example
     * // Update one StudentParent
     * const studentParent = await prisma.studentParent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentParentUpdateArgs>(args: SelectSubset<T, StudentParentUpdateArgs<ExtArgs>>): Prisma__StudentParentClient<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentParents.
     * @param {StudentParentDeleteManyArgs} args - Arguments to filter StudentParents to delete.
     * @example
     * // Delete a few StudentParents
     * const { count } = await prisma.studentParent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentParentDeleteManyArgs>(args?: SelectSubset<T, StudentParentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentParents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentParents
     * const studentParent = await prisma.studentParent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentParentUpdateManyArgs>(args: SelectSubset<T, StudentParentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentParents and returns the data updated in the database.
     * @param {StudentParentUpdateManyAndReturnArgs} args - Arguments to update many StudentParents.
     * @example
     * // Update many StudentParents
     * const studentParent = await prisma.studentParent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudentParents and only return the `id`
     * const studentParentWithIdOnly = await prisma.studentParent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentParentUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentParentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudentParent.
     * @param {StudentParentUpsertArgs} args - Arguments to update or create a StudentParent.
     * @example
     * // Update or create a StudentParent
     * const studentParent = await prisma.studentParent.upsert({
     *   create: {
     *     // ... data to create a StudentParent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentParent we want to update
     *   }
     * })
     */
    upsert<T extends StudentParentUpsertArgs>(args: SelectSubset<T, StudentParentUpsertArgs<ExtArgs>>): Prisma__StudentParentClient<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentParents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentCountArgs} args - Arguments to filter StudentParents to count.
     * @example
     * // Count the number of StudentParents
     * const count = await prisma.studentParent.count({
     *   where: {
     *     // ... the filter for the StudentParents we want to count
     *   }
     * })
    **/
    count<T extends StudentParentCountArgs>(
      args?: Subset<T, StudentParentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentParentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentParent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentParentAggregateArgs>(args: Subset<T, StudentParentAggregateArgs>): Prisma.PrismaPromise<GetStudentParentAggregateType<T>>

    /**
     * Group by StudentParent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentParentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentParentGroupByArgs['orderBy'] }
        : { orderBy?: StudentParentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentParentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentParentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentParent model
   */
  readonly fields: StudentParentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentParent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentParentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends ParentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParentDefaultArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentParent model
   */ 
  interface StudentParentFieldRefs {
    readonly id: FieldRef<"StudentParent", 'String'>
    readonly studentId: FieldRef<"StudentParent", 'String'>
    readonly parentId: FieldRef<"StudentParent", 'String'>
    readonly relation: FieldRef<"StudentParent", 'String'>
    readonly isPrimary: FieldRef<"StudentParent", 'Boolean'>
    readonly createdAt: FieldRef<"StudentParent", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentParent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentParent findUnique
   */
  export type StudentParentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    /**
     * Filter, which StudentParent to fetch.
     */
    where: StudentParentWhereUniqueInput
  }

  /**
   * StudentParent findUniqueOrThrow
   */
  export type StudentParentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    /**
     * Filter, which StudentParent to fetch.
     */
    where: StudentParentWhereUniqueInput
  }

  /**
   * StudentParent findFirst
   */
  export type StudentParentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    /**
     * Filter, which StudentParent to fetch.
     */
    where?: StudentParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentParents to fetch.
     */
    orderBy?: StudentParentOrderByWithRelationInput | StudentParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentParents.
     */
    cursor?: StudentParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentParents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentParents.
     */
    distinct?: StudentParentScalarFieldEnum | StudentParentScalarFieldEnum[]
  }

  /**
   * StudentParent findFirstOrThrow
   */
  export type StudentParentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    /**
     * Filter, which StudentParent to fetch.
     */
    where?: StudentParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentParents to fetch.
     */
    orderBy?: StudentParentOrderByWithRelationInput | StudentParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentParents.
     */
    cursor?: StudentParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentParents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentParents.
     */
    distinct?: StudentParentScalarFieldEnum | StudentParentScalarFieldEnum[]
  }

  /**
   * StudentParent findMany
   */
  export type StudentParentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    /**
     * Filter, which StudentParents to fetch.
     */
    where?: StudentParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentParents to fetch.
     */
    orderBy?: StudentParentOrderByWithRelationInput | StudentParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentParents.
     */
    cursor?: StudentParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentParents.
     */
    skip?: number
    distinct?: StudentParentScalarFieldEnum | StudentParentScalarFieldEnum[]
  }

  /**
   * StudentParent create
   */
  export type StudentParentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentParent.
     */
    data: XOR<StudentParentCreateInput, StudentParentUncheckedCreateInput>
  }

  /**
   * StudentParent createMany
   */
  export type StudentParentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentParents.
     */
    data: StudentParentCreateManyInput | StudentParentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentParent createManyAndReturn
   */
  export type StudentParentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * The data used to create many StudentParents.
     */
    data: StudentParentCreateManyInput | StudentParentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentParent update
   */
  export type StudentParentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentParent.
     */
    data: XOR<StudentParentUpdateInput, StudentParentUncheckedUpdateInput>
    /**
     * Choose, which StudentParent to update.
     */
    where: StudentParentWhereUniqueInput
  }

  /**
   * StudentParent updateMany
   */
  export type StudentParentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentParents.
     */
    data: XOR<StudentParentUpdateManyMutationInput, StudentParentUncheckedUpdateManyInput>
    /**
     * Filter which StudentParents to update
     */
    where?: StudentParentWhereInput
    /**
     * Limit how many StudentParents to update.
     */
    limit?: number
  }

  /**
   * StudentParent updateManyAndReturn
   */
  export type StudentParentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * The data used to update StudentParents.
     */
    data: XOR<StudentParentUpdateManyMutationInput, StudentParentUncheckedUpdateManyInput>
    /**
     * Filter which StudentParents to update
     */
    where?: StudentParentWhereInput
    /**
     * Limit how many StudentParents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentParent upsert
   */
  export type StudentParentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentParent to update in case it exists.
     */
    where: StudentParentWhereUniqueInput
    /**
     * In case the StudentParent found by the `where` argument doesn't exist, create a new StudentParent with this data.
     */
    create: XOR<StudentParentCreateInput, StudentParentUncheckedCreateInput>
    /**
     * In case the StudentParent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentParentUpdateInput, StudentParentUncheckedUpdateInput>
  }

  /**
   * StudentParent delete
   */
  export type StudentParentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    /**
     * Filter which StudentParent to delete.
     */
    where: StudentParentWhereUniqueInput
  }

  /**
   * StudentParent deleteMany
   */
  export type StudentParentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentParents to delete
     */
    where?: StudentParentWhereInput
    /**
     * Limit how many StudentParents to delete.
     */
    limit?: number
  }

  /**
   * StudentParent without action
   */
  export type StudentParentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
  }


  /**
   * Model SubjectTeacher
   */

  export type AggregateSubjectTeacher = {
    _count: SubjectTeacherCountAggregateOutputType | null
    _min: SubjectTeacherMinAggregateOutputType | null
    _max: SubjectTeacherMaxAggregateOutputType | null
  }

  export type SubjectTeacherMinAggregateOutputType = {
    id: string | null
    subjectId: string | null
    teacherId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubjectTeacherMaxAggregateOutputType = {
    id: string | null
    subjectId: string | null
    teacherId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubjectTeacherCountAggregateOutputType = {
    id: number
    subjectId: number
    teacherId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubjectTeacherMinAggregateInputType = {
    id?: true
    subjectId?: true
    teacherId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubjectTeacherMaxAggregateInputType = {
    id?: true
    subjectId?: true
    teacherId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubjectTeacherCountAggregateInputType = {
    id?: true
    subjectId?: true
    teacherId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubjectTeacherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubjectTeacher to aggregate.
     */
    where?: SubjectTeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubjectTeachers to fetch.
     */
    orderBy?: SubjectTeacherOrderByWithRelationInput | SubjectTeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubjectTeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubjectTeachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubjectTeachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubjectTeachers
    **/
    _count?: true | SubjectTeacherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubjectTeacherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubjectTeacherMaxAggregateInputType
  }

  export type GetSubjectTeacherAggregateType<T extends SubjectTeacherAggregateArgs> = {
        [P in keyof T & keyof AggregateSubjectTeacher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubjectTeacher[P]>
      : GetScalarType<T[P], AggregateSubjectTeacher[P]>
  }




  export type SubjectTeacherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectTeacherWhereInput
    orderBy?: SubjectTeacherOrderByWithAggregationInput | SubjectTeacherOrderByWithAggregationInput[]
    by: SubjectTeacherScalarFieldEnum[] | SubjectTeacherScalarFieldEnum
    having?: SubjectTeacherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubjectTeacherCountAggregateInputType | true
    _min?: SubjectTeacherMinAggregateInputType
    _max?: SubjectTeacherMaxAggregateInputType
  }

  export type SubjectTeacherGroupByOutputType = {
    id: string
    subjectId: string
    teacherId: string
    createdAt: Date
    updatedAt: Date
    _count: SubjectTeacherCountAggregateOutputType | null
    _min: SubjectTeacherMinAggregateOutputType | null
    _max: SubjectTeacherMaxAggregateOutputType | null
  }

  type GetSubjectTeacherGroupByPayload<T extends SubjectTeacherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubjectTeacherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubjectTeacherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectTeacherGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectTeacherGroupByOutputType[P]>
        }
      >
    >


  export type SubjectTeacherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subjectId?: boolean
    teacherId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subjectTeacher"]>

  export type SubjectTeacherSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subjectId?: boolean
    teacherId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subjectTeacher"]>

  export type SubjectTeacherSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subjectId?: boolean
    teacherId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subjectTeacher"]>

  export type SubjectTeacherSelectScalar = {
    id?: boolean
    subjectId?: boolean
    teacherId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubjectTeacherOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subjectId" | "teacherId" | "createdAt" | "updatedAt", ExtArgs["result"]["subjectTeacher"]>
  export type SubjectTeacherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }
  export type SubjectTeacherIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }
  export type SubjectTeacherIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }

  export type $SubjectTeacherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubjectTeacher"
    objects: {
      subject: Prisma.$SubjectPayload<ExtArgs>
      teacher: Prisma.$TeacherPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subjectId: string
      teacherId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subjectTeacher"]>
    composites: {}
  }

  type SubjectTeacherGetPayload<S extends boolean | null | undefined | SubjectTeacherDefaultArgs> = $Result.GetResult<Prisma.$SubjectTeacherPayload, S>

  type SubjectTeacherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubjectTeacherFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubjectTeacherCountAggregateInputType | true
    }

  export interface SubjectTeacherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubjectTeacher'], meta: { name: 'SubjectTeacher' } }
    /**
     * Find zero or one SubjectTeacher that matches the filter.
     * @param {SubjectTeacherFindUniqueArgs} args - Arguments to find a SubjectTeacher
     * @example
     * // Get one SubjectTeacher
     * const subjectTeacher = await prisma.subjectTeacher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubjectTeacherFindUniqueArgs>(args: SelectSubset<T, SubjectTeacherFindUniqueArgs<ExtArgs>>): Prisma__SubjectTeacherClient<$Result.GetResult<Prisma.$SubjectTeacherPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubjectTeacher that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubjectTeacherFindUniqueOrThrowArgs} args - Arguments to find a SubjectTeacher
     * @example
     * // Get one SubjectTeacher
     * const subjectTeacher = await prisma.subjectTeacher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubjectTeacherFindUniqueOrThrowArgs>(args: SelectSubset<T, SubjectTeacherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubjectTeacherClient<$Result.GetResult<Prisma.$SubjectTeacherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubjectTeacher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectTeacherFindFirstArgs} args - Arguments to find a SubjectTeacher
     * @example
     * // Get one SubjectTeacher
     * const subjectTeacher = await prisma.subjectTeacher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubjectTeacherFindFirstArgs>(args?: SelectSubset<T, SubjectTeacherFindFirstArgs<ExtArgs>>): Prisma__SubjectTeacherClient<$Result.GetResult<Prisma.$SubjectTeacherPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubjectTeacher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectTeacherFindFirstOrThrowArgs} args - Arguments to find a SubjectTeacher
     * @example
     * // Get one SubjectTeacher
     * const subjectTeacher = await prisma.subjectTeacher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubjectTeacherFindFirstOrThrowArgs>(args?: SelectSubset<T, SubjectTeacherFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubjectTeacherClient<$Result.GetResult<Prisma.$SubjectTeacherPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubjectTeachers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectTeacherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubjectTeachers
     * const subjectTeachers = await prisma.subjectTeacher.findMany()
     * 
     * // Get first 10 SubjectTeachers
     * const subjectTeachers = await prisma.subjectTeacher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subjectTeacherWithIdOnly = await prisma.subjectTeacher.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubjectTeacherFindManyArgs>(args?: SelectSubset<T, SubjectTeacherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectTeacherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubjectTeacher.
     * @param {SubjectTeacherCreateArgs} args - Arguments to create a SubjectTeacher.
     * @example
     * // Create one SubjectTeacher
     * const SubjectTeacher = await prisma.subjectTeacher.create({
     *   data: {
     *     // ... data to create a SubjectTeacher
     *   }
     * })
     * 
     */
    create<T extends SubjectTeacherCreateArgs>(args: SelectSubset<T, SubjectTeacherCreateArgs<ExtArgs>>): Prisma__SubjectTeacherClient<$Result.GetResult<Prisma.$SubjectTeacherPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubjectTeachers.
     * @param {SubjectTeacherCreateManyArgs} args - Arguments to create many SubjectTeachers.
     * @example
     * // Create many SubjectTeachers
     * const subjectTeacher = await prisma.subjectTeacher.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubjectTeacherCreateManyArgs>(args?: SelectSubset<T, SubjectTeacherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubjectTeachers and returns the data saved in the database.
     * @param {SubjectTeacherCreateManyAndReturnArgs} args - Arguments to create many SubjectTeachers.
     * @example
     * // Create many SubjectTeachers
     * const subjectTeacher = await prisma.subjectTeacher.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubjectTeachers and only return the `id`
     * const subjectTeacherWithIdOnly = await prisma.subjectTeacher.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubjectTeacherCreateManyAndReturnArgs>(args?: SelectSubset<T, SubjectTeacherCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectTeacherPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubjectTeacher.
     * @param {SubjectTeacherDeleteArgs} args - Arguments to delete one SubjectTeacher.
     * @example
     * // Delete one SubjectTeacher
     * const SubjectTeacher = await prisma.subjectTeacher.delete({
     *   where: {
     *     // ... filter to delete one SubjectTeacher
     *   }
     * })
     * 
     */
    delete<T extends SubjectTeacherDeleteArgs>(args: SelectSubset<T, SubjectTeacherDeleteArgs<ExtArgs>>): Prisma__SubjectTeacherClient<$Result.GetResult<Prisma.$SubjectTeacherPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubjectTeacher.
     * @param {SubjectTeacherUpdateArgs} args - Arguments to update one SubjectTeacher.
     * @example
     * // Update one SubjectTeacher
     * const subjectTeacher = await prisma.subjectTeacher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubjectTeacherUpdateArgs>(args: SelectSubset<T, SubjectTeacherUpdateArgs<ExtArgs>>): Prisma__SubjectTeacherClient<$Result.GetResult<Prisma.$SubjectTeacherPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubjectTeachers.
     * @param {SubjectTeacherDeleteManyArgs} args - Arguments to filter SubjectTeachers to delete.
     * @example
     * // Delete a few SubjectTeachers
     * const { count } = await prisma.subjectTeacher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubjectTeacherDeleteManyArgs>(args?: SelectSubset<T, SubjectTeacherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubjectTeachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectTeacherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubjectTeachers
     * const subjectTeacher = await prisma.subjectTeacher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubjectTeacherUpdateManyArgs>(args: SelectSubset<T, SubjectTeacherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubjectTeachers and returns the data updated in the database.
     * @param {SubjectTeacherUpdateManyAndReturnArgs} args - Arguments to update many SubjectTeachers.
     * @example
     * // Update many SubjectTeachers
     * const subjectTeacher = await prisma.subjectTeacher.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubjectTeachers and only return the `id`
     * const subjectTeacherWithIdOnly = await prisma.subjectTeacher.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubjectTeacherUpdateManyAndReturnArgs>(args: SelectSubset<T, SubjectTeacherUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectTeacherPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubjectTeacher.
     * @param {SubjectTeacherUpsertArgs} args - Arguments to update or create a SubjectTeacher.
     * @example
     * // Update or create a SubjectTeacher
     * const subjectTeacher = await prisma.subjectTeacher.upsert({
     *   create: {
     *     // ... data to create a SubjectTeacher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubjectTeacher we want to update
     *   }
     * })
     */
    upsert<T extends SubjectTeacherUpsertArgs>(args: SelectSubset<T, SubjectTeacherUpsertArgs<ExtArgs>>): Prisma__SubjectTeacherClient<$Result.GetResult<Prisma.$SubjectTeacherPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubjectTeachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectTeacherCountArgs} args - Arguments to filter SubjectTeachers to count.
     * @example
     * // Count the number of SubjectTeachers
     * const count = await prisma.subjectTeacher.count({
     *   where: {
     *     // ... the filter for the SubjectTeachers we want to count
     *   }
     * })
    **/
    count<T extends SubjectTeacherCountArgs>(
      args?: Subset<T, SubjectTeacherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubjectTeacherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubjectTeacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectTeacherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubjectTeacherAggregateArgs>(args: Subset<T, SubjectTeacherAggregateArgs>): Prisma.PrismaPromise<GetSubjectTeacherAggregateType<T>>

    /**
     * Group by SubjectTeacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectTeacherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubjectTeacherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubjectTeacherGroupByArgs['orderBy'] }
        : { orderBy?: SubjectTeacherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubjectTeacherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubjectTeacherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubjectTeacher model
   */
  readonly fields: SubjectTeacherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubjectTeacher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubjectTeacherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    teacher<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubjectTeacher model
   */ 
  interface SubjectTeacherFieldRefs {
    readonly id: FieldRef<"SubjectTeacher", 'String'>
    readonly subjectId: FieldRef<"SubjectTeacher", 'String'>
    readonly teacherId: FieldRef<"SubjectTeacher", 'String'>
    readonly createdAt: FieldRef<"SubjectTeacher", 'DateTime'>
    readonly updatedAt: FieldRef<"SubjectTeacher", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubjectTeacher findUnique
   */
  export type SubjectTeacherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectTeacher
     */
    select?: SubjectTeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubjectTeacher
     */
    omit?: SubjectTeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectTeacherInclude<ExtArgs> | null
    /**
     * Filter, which SubjectTeacher to fetch.
     */
    where: SubjectTeacherWhereUniqueInput
  }

  /**
   * SubjectTeacher findUniqueOrThrow
   */
  export type SubjectTeacherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectTeacher
     */
    select?: SubjectTeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubjectTeacher
     */
    omit?: SubjectTeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectTeacherInclude<ExtArgs> | null
    /**
     * Filter, which SubjectTeacher to fetch.
     */
    where: SubjectTeacherWhereUniqueInput
  }

  /**
   * SubjectTeacher findFirst
   */
  export type SubjectTeacherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectTeacher
     */
    select?: SubjectTeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubjectTeacher
     */
    omit?: SubjectTeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectTeacherInclude<ExtArgs> | null
    /**
     * Filter, which SubjectTeacher to fetch.
     */
    where?: SubjectTeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubjectTeachers to fetch.
     */
    orderBy?: SubjectTeacherOrderByWithRelationInput | SubjectTeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubjectTeachers.
     */
    cursor?: SubjectTeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubjectTeachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubjectTeachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubjectTeachers.
     */
    distinct?: SubjectTeacherScalarFieldEnum | SubjectTeacherScalarFieldEnum[]
  }

  /**
   * SubjectTeacher findFirstOrThrow
   */
  export type SubjectTeacherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectTeacher
     */
    select?: SubjectTeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubjectTeacher
     */
    omit?: SubjectTeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectTeacherInclude<ExtArgs> | null
    /**
     * Filter, which SubjectTeacher to fetch.
     */
    where?: SubjectTeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubjectTeachers to fetch.
     */
    orderBy?: SubjectTeacherOrderByWithRelationInput | SubjectTeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubjectTeachers.
     */
    cursor?: SubjectTeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubjectTeachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubjectTeachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubjectTeachers.
     */
    distinct?: SubjectTeacherScalarFieldEnum | SubjectTeacherScalarFieldEnum[]
  }

  /**
   * SubjectTeacher findMany
   */
  export type SubjectTeacherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectTeacher
     */
    select?: SubjectTeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubjectTeacher
     */
    omit?: SubjectTeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectTeacherInclude<ExtArgs> | null
    /**
     * Filter, which SubjectTeachers to fetch.
     */
    where?: SubjectTeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubjectTeachers to fetch.
     */
    orderBy?: SubjectTeacherOrderByWithRelationInput | SubjectTeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubjectTeachers.
     */
    cursor?: SubjectTeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubjectTeachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubjectTeachers.
     */
    skip?: number
    distinct?: SubjectTeacherScalarFieldEnum | SubjectTeacherScalarFieldEnum[]
  }

  /**
   * SubjectTeacher create
   */
  export type SubjectTeacherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectTeacher
     */
    select?: SubjectTeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubjectTeacher
     */
    omit?: SubjectTeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectTeacherInclude<ExtArgs> | null
    /**
     * The data needed to create a SubjectTeacher.
     */
    data: XOR<SubjectTeacherCreateInput, SubjectTeacherUncheckedCreateInput>
  }

  /**
   * SubjectTeacher createMany
   */
  export type SubjectTeacherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubjectTeachers.
     */
    data: SubjectTeacherCreateManyInput | SubjectTeacherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubjectTeacher createManyAndReturn
   */
  export type SubjectTeacherCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectTeacher
     */
    select?: SubjectTeacherSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubjectTeacher
     */
    omit?: SubjectTeacherOmit<ExtArgs> | null
    /**
     * The data used to create many SubjectTeachers.
     */
    data: SubjectTeacherCreateManyInput | SubjectTeacherCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectTeacherIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubjectTeacher update
   */
  export type SubjectTeacherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectTeacher
     */
    select?: SubjectTeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubjectTeacher
     */
    omit?: SubjectTeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectTeacherInclude<ExtArgs> | null
    /**
     * The data needed to update a SubjectTeacher.
     */
    data: XOR<SubjectTeacherUpdateInput, SubjectTeacherUncheckedUpdateInput>
    /**
     * Choose, which SubjectTeacher to update.
     */
    where: SubjectTeacherWhereUniqueInput
  }

  /**
   * SubjectTeacher updateMany
   */
  export type SubjectTeacherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubjectTeachers.
     */
    data: XOR<SubjectTeacherUpdateManyMutationInput, SubjectTeacherUncheckedUpdateManyInput>
    /**
     * Filter which SubjectTeachers to update
     */
    where?: SubjectTeacherWhereInput
    /**
     * Limit how many SubjectTeachers to update.
     */
    limit?: number
  }

  /**
   * SubjectTeacher updateManyAndReturn
   */
  export type SubjectTeacherUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectTeacher
     */
    select?: SubjectTeacherSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubjectTeacher
     */
    omit?: SubjectTeacherOmit<ExtArgs> | null
    /**
     * The data used to update SubjectTeachers.
     */
    data: XOR<SubjectTeacherUpdateManyMutationInput, SubjectTeacherUncheckedUpdateManyInput>
    /**
     * Filter which SubjectTeachers to update
     */
    where?: SubjectTeacherWhereInput
    /**
     * Limit how many SubjectTeachers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectTeacherIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubjectTeacher upsert
   */
  export type SubjectTeacherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectTeacher
     */
    select?: SubjectTeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubjectTeacher
     */
    omit?: SubjectTeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectTeacherInclude<ExtArgs> | null
    /**
     * The filter to search for the SubjectTeacher to update in case it exists.
     */
    where: SubjectTeacherWhereUniqueInput
    /**
     * In case the SubjectTeacher found by the `where` argument doesn't exist, create a new SubjectTeacher with this data.
     */
    create: XOR<SubjectTeacherCreateInput, SubjectTeacherUncheckedCreateInput>
    /**
     * In case the SubjectTeacher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubjectTeacherUpdateInput, SubjectTeacherUncheckedUpdateInput>
  }

  /**
   * SubjectTeacher delete
   */
  export type SubjectTeacherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectTeacher
     */
    select?: SubjectTeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubjectTeacher
     */
    omit?: SubjectTeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectTeacherInclude<ExtArgs> | null
    /**
     * Filter which SubjectTeacher to delete.
     */
    where: SubjectTeacherWhereUniqueInput
  }

  /**
   * SubjectTeacher deleteMany
   */
  export type SubjectTeacherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubjectTeachers to delete
     */
    where?: SubjectTeacherWhereInput
    /**
     * Limit how many SubjectTeachers to delete.
     */
    limit?: number
  }

  /**
   * SubjectTeacher without action
   */
  export type SubjectTeacherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectTeacher
     */
    select?: SubjectTeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubjectTeacher
     */
    omit?: SubjectTeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectTeacherInclude<ExtArgs> | null
  }


  /**
   * Model ClassSubject
   */

  export type AggregateClassSubject = {
    _count: ClassSubjectCountAggregateOutputType | null
    _min: ClassSubjectMinAggregateOutputType | null
    _max: ClassSubjectMaxAggregateOutputType | null
  }

  export type ClassSubjectMinAggregateOutputType = {
    id: string | null
    classId: string | null
    subjectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassSubjectMaxAggregateOutputType = {
    id: string | null
    classId: string | null
    subjectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassSubjectCountAggregateOutputType = {
    id: number
    classId: number
    subjectId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClassSubjectMinAggregateInputType = {
    id?: true
    classId?: true
    subjectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassSubjectMaxAggregateInputType = {
    id?: true
    classId?: true
    subjectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassSubjectCountAggregateInputType = {
    id?: true
    classId?: true
    subjectId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClassSubjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassSubject to aggregate.
     */
    where?: ClassSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSubjects to fetch.
     */
    orderBy?: ClassSubjectOrderByWithRelationInput | ClassSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassSubjects
    **/
    _count?: true | ClassSubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassSubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassSubjectMaxAggregateInputType
  }

  export type GetClassSubjectAggregateType<T extends ClassSubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateClassSubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassSubject[P]>
      : GetScalarType<T[P], AggregateClassSubject[P]>
  }




  export type ClassSubjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassSubjectWhereInput
    orderBy?: ClassSubjectOrderByWithAggregationInput | ClassSubjectOrderByWithAggregationInput[]
    by: ClassSubjectScalarFieldEnum[] | ClassSubjectScalarFieldEnum
    having?: ClassSubjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassSubjectCountAggregateInputType | true
    _min?: ClassSubjectMinAggregateInputType
    _max?: ClassSubjectMaxAggregateInputType
  }

  export type ClassSubjectGroupByOutputType = {
    id: string
    classId: string
    subjectId: string
    createdAt: Date
    updatedAt: Date
    _count: ClassSubjectCountAggregateOutputType | null
    _min: ClassSubjectMinAggregateOutputType | null
    _max: ClassSubjectMaxAggregateOutputType | null
  }

  type GetClassSubjectGroupByPayload<T extends ClassSubjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassSubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassSubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassSubjectGroupByOutputType[P]>
            : GetScalarType<T[P], ClassSubjectGroupByOutputType[P]>
        }
      >
    >


  export type ClassSubjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    subjectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classSubject"]>

  export type ClassSubjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    subjectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classSubject"]>

  export type ClassSubjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    subjectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classSubject"]>

  export type ClassSubjectSelectScalar = {
    id?: boolean
    classId?: boolean
    subjectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClassSubjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "classId" | "subjectId" | "createdAt" | "updatedAt", ExtArgs["result"]["classSubject"]>
  export type ClassSubjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }
  export type ClassSubjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }
  export type ClassSubjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }

  export type $ClassSubjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClassSubject"
    objects: {
      class: Prisma.$ClassPayload<ExtArgs>
      subject: Prisma.$SubjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      classId: string
      subjectId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["classSubject"]>
    composites: {}
  }

  type ClassSubjectGetPayload<S extends boolean | null | undefined | ClassSubjectDefaultArgs> = $Result.GetResult<Prisma.$ClassSubjectPayload, S>

  type ClassSubjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassSubjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassSubjectCountAggregateInputType | true
    }

  export interface ClassSubjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClassSubject'], meta: { name: 'ClassSubject' } }
    /**
     * Find zero or one ClassSubject that matches the filter.
     * @param {ClassSubjectFindUniqueArgs} args - Arguments to find a ClassSubject
     * @example
     * // Get one ClassSubject
     * const classSubject = await prisma.classSubject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassSubjectFindUniqueArgs>(args: SelectSubset<T, ClassSubjectFindUniqueArgs<ExtArgs>>): Prisma__ClassSubjectClient<$Result.GetResult<Prisma.$ClassSubjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClassSubject that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassSubjectFindUniqueOrThrowArgs} args - Arguments to find a ClassSubject
     * @example
     * // Get one ClassSubject
     * const classSubject = await prisma.classSubject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassSubjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassSubjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassSubjectClient<$Result.GetResult<Prisma.$ClassSubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassSubject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSubjectFindFirstArgs} args - Arguments to find a ClassSubject
     * @example
     * // Get one ClassSubject
     * const classSubject = await prisma.classSubject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassSubjectFindFirstArgs>(args?: SelectSubset<T, ClassSubjectFindFirstArgs<ExtArgs>>): Prisma__ClassSubjectClient<$Result.GetResult<Prisma.$ClassSubjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassSubject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSubjectFindFirstOrThrowArgs} args - Arguments to find a ClassSubject
     * @example
     * // Get one ClassSubject
     * const classSubject = await prisma.classSubject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassSubjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassSubjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassSubjectClient<$Result.GetResult<Prisma.$ClassSubjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClassSubjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSubjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassSubjects
     * const classSubjects = await prisma.classSubject.findMany()
     * 
     * // Get first 10 ClassSubjects
     * const classSubjects = await prisma.classSubject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classSubjectWithIdOnly = await prisma.classSubject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassSubjectFindManyArgs>(args?: SelectSubset<T, ClassSubjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClassSubject.
     * @param {ClassSubjectCreateArgs} args - Arguments to create a ClassSubject.
     * @example
     * // Create one ClassSubject
     * const ClassSubject = await prisma.classSubject.create({
     *   data: {
     *     // ... data to create a ClassSubject
     *   }
     * })
     * 
     */
    create<T extends ClassSubjectCreateArgs>(args: SelectSubset<T, ClassSubjectCreateArgs<ExtArgs>>): Prisma__ClassSubjectClient<$Result.GetResult<Prisma.$ClassSubjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClassSubjects.
     * @param {ClassSubjectCreateManyArgs} args - Arguments to create many ClassSubjects.
     * @example
     * // Create many ClassSubjects
     * const classSubject = await prisma.classSubject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassSubjectCreateManyArgs>(args?: SelectSubset<T, ClassSubjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClassSubjects and returns the data saved in the database.
     * @param {ClassSubjectCreateManyAndReturnArgs} args - Arguments to create many ClassSubjects.
     * @example
     * // Create many ClassSubjects
     * const classSubject = await prisma.classSubject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClassSubjects and only return the `id`
     * const classSubjectWithIdOnly = await prisma.classSubject.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassSubjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassSubjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSubjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClassSubject.
     * @param {ClassSubjectDeleteArgs} args - Arguments to delete one ClassSubject.
     * @example
     * // Delete one ClassSubject
     * const ClassSubject = await prisma.classSubject.delete({
     *   where: {
     *     // ... filter to delete one ClassSubject
     *   }
     * })
     * 
     */
    delete<T extends ClassSubjectDeleteArgs>(args: SelectSubset<T, ClassSubjectDeleteArgs<ExtArgs>>): Prisma__ClassSubjectClient<$Result.GetResult<Prisma.$ClassSubjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClassSubject.
     * @param {ClassSubjectUpdateArgs} args - Arguments to update one ClassSubject.
     * @example
     * // Update one ClassSubject
     * const classSubject = await prisma.classSubject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassSubjectUpdateArgs>(args: SelectSubset<T, ClassSubjectUpdateArgs<ExtArgs>>): Prisma__ClassSubjectClient<$Result.GetResult<Prisma.$ClassSubjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClassSubjects.
     * @param {ClassSubjectDeleteManyArgs} args - Arguments to filter ClassSubjects to delete.
     * @example
     * // Delete a few ClassSubjects
     * const { count } = await prisma.classSubject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassSubjectDeleteManyArgs>(args?: SelectSubset<T, ClassSubjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassSubjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSubjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassSubjects
     * const classSubject = await prisma.classSubject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassSubjectUpdateManyArgs>(args: SelectSubset<T, ClassSubjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassSubjects and returns the data updated in the database.
     * @param {ClassSubjectUpdateManyAndReturnArgs} args - Arguments to update many ClassSubjects.
     * @example
     * // Update many ClassSubjects
     * const classSubject = await prisma.classSubject.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClassSubjects and only return the `id`
     * const classSubjectWithIdOnly = await prisma.classSubject.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClassSubjectUpdateManyAndReturnArgs>(args: SelectSubset<T, ClassSubjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSubjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClassSubject.
     * @param {ClassSubjectUpsertArgs} args - Arguments to update or create a ClassSubject.
     * @example
     * // Update or create a ClassSubject
     * const classSubject = await prisma.classSubject.upsert({
     *   create: {
     *     // ... data to create a ClassSubject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassSubject we want to update
     *   }
     * })
     */
    upsert<T extends ClassSubjectUpsertArgs>(args: SelectSubset<T, ClassSubjectUpsertArgs<ExtArgs>>): Prisma__ClassSubjectClient<$Result.GetResult<Prisma.$ClassSubjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClassSubjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSubjectCountArgs} args - Arguments to filter ClassSubjects to count.
     * @example
     * // Count the number of ClassSubjects
     * const count = await prisma.classSubject.count({
     *   where: {
     *     // ... the filter for the ClassSubjects we want to count
     *   }
     * })
    **/
    count<T extends ClassSubjectCountArgs>(
      args?: Subset<T, ClassSubjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassSubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassSubject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassSubjectAggregateArgs>(args: Subset<T, ClassSubjectAggregateArgs>): Prisma.PrismaPromise<GetClassSubjectAggregateType<T>>

    /**
     * Group by ClassSubject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassSubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassSubjectGroupByArgs['orderBy'] }
        : { orderBy?: ClassSubjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassSubjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassSubjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClassSubject model
   */
  readonly fields: ClassSubjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassSubject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassSubjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClassSubject model
   */ 
  interface ClassSubjectFieldRefs {
    readonly id: FieldRef<"ClassSubject", 'String'>
    readonly classId: FieldRef<"ClassSubject", 'String'>
    readonly subjectId: FieldRef<"ClassSubject", 'String'>
    readonly createdAt: FieldRef<"ClassSubject", 'DateTime'>
    readonly updatedAt: FieldRef<"ClassSubject", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClassSubject findUnique
   */
  export type ClassSubjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSubject
     */
    omit?: ClassSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectInclude<ExtArgs> | null
    /**
     * Filter, which ClassSubject to fetch.
     */
    where: ClassSubjectWhereUniqueInput
  }

  /**
   * ClassSubject findUniqueOrThrow
   */
  export type ClassSubjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSubject
     */
    omit?: ClassSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectInclude<ExtArgs> | null
    /**
     * Filter, which ClassSubject to fetch.
     */
    where: ClassSubjectWhereUniqueInput
  }

  /**
   * ClassSubject findFirst
   */
  export type ClassSubjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSubject
     */
    omit?: ClassSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectInclude<ExtArgs> | null
    /**
     * Filter, which ClassSubject to fetch.
     */
    where?: ClassSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSubjects to fetch.
     */
    orderBy?: ClassSubjectOrderByWithRelationInput | ClassSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassSubjects.
     */
    cursor?: ClassSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassSubjects.
     */
    distinct?: ClassSubjectScalarFieldEnum | ClassSubjectScalarFieldEnum[]
  }

  /**
   * ClassSubject findFirstOrThrow
   */
  export type ClassSubjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSubject
     */
    omit?: ClassSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectInclude<ExtArgs> | null
    /**
     * Filter, which ClassSubject to fetch.
     */
    where?: ClassSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSubjects to fetch.
     */
    orderBy?: ClassSubjectOrderByWithRelationInput | ClassSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassSubjects.
     */
    cursor?: ClassSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassSubjects.
     */
    distinct?: ClassSubjectScalarFieldEnum | ClassSubjectScalarFieldEnum[]
  }

  /**
   * ClassSubject findMany
   */
  export type ClassSubjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSubject
     */
    omit?: ClassSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectInclude<ExtArgs> | null
    /**
     * Filter, which ClassSubjects to fetch.
     */
    where?: ClassSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSubjects to fetch.
     */
    orderBy?: ClassSubjectOrderByWithRelationInput | ClassSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassSubjects.
     */
    cursor?: ClassSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSubjects.
     */
    skip?: number
    distinct?: ClassSubjectScalarFieldEnum | ClassSubjectScalarFieldEnum[]
  }

  /**
   * ClassSubject create
   */
  export type ClassSubjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSubject
     */
    omit?: ClassSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectInclude<ExtArgs> | null
    /**
     * The data needed to create a ClassSubject.
     */
    data: XOR<ClassSubjectCreateInput, ClassSubjectUncheckedCreateInput>
  }

  /**
   * ClassSubject createMany
   */
  export type ClassSubjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClassSubjects.
     */
    data: ClassSubjectCreateManyInput | ClassSubjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClassSubject createManyAndReturn
   */
  export type ClassSubjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSubject
     */
    omit?: ClassSubjectOmit<ExtArgs> | null
    /**
     * The data used to create many ClassSubjects.
     */
    data: ClassSubjectCreateManyInput | ClassSubjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClassSubject update
   */
  export type ClassSubjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSubject
     */
    omit?: ClassSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectInclude<ExtArgs> | null
    /**
     * The data needed to update a ClassSubject.
     */
    data: XOR<ClassSubjectUpdateInput, ClassSubjectUncheckedUpdateInput>
    /**
     * Choose, which ClassSubject to update.
     */
    where: ClassSubjectWhereUniqueInput
  }

  /**
   * ClassSubject updateMany
   */
  export type ClassSubjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClassSubjects.
     */
    data: XOR<ClassSubjectUpdateManyMutationInput, ClassSubjectUncheckedUpdateManyInput>
    /**
     * Filter which ClassSubjects to update
     */
    where?: ClassSubjectWhereInput
    /**
     * Limit how many ClassSubjects to update.
     */
    limit?: number
  }

  /**
   * ClassSubject updateManyAndReturn
   */
  export type ClassSubjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSubject
     */
    omit?: ClassSubjectOmit<ExtArgs> | null
    /**
     * The data used to update ClassSubjects.
     */
    data: XOR<ClassSubjectUpdateManyMutationInput, ClassSubjectUncheckedUpdateManyInput>
    /**
     * Filter which ClassSubjects to update
     */
    where?: ClassSubjectWhereInput
    /**
     * Limit how many ClassSubjects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClassSubject upsert
   */
  export type ClassSubjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSubject
     */
    omit?: ClassSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectInclude<ExtArgs> | null
    /**
     * The filter to search for the ClassSubject to update in case it exists.
     */
    where: ClassSubjectWhereUniqueInput
    /**
     * In case the ClassSubject found by the `where` argument doesn't exist, create a new ClassSubject with this data.
     */
    create: XOR<ClassSubjectCreateInput, ClassSubjectUncheckedCreateInput>
    /**
     * In case the ClassSubject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassSubjectUpdateInput, ClassSubjectUncheckedUpdateInput>
  }

  /**
   * ClassSubject delete
   */
  export type ClassSubjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSubject
     */
    omit?: ClassSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectInclude<ExtArgs> | null
    /**
     * Filter which ClassSubject to delete.
     */
    where: ClassSubjectWhereUniqueInput
  }

  /**
   * ClassSubject deleteMany
   */
  export type ClassSubjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassSubjects to delete
     */
    where?: ClassSubjectWhereInput
    /**
     * Limit how many ClassSubjects to delete.
     */
    limit?: number
  }

  /**
   * ClassSubject without action
   */
  export type ClassSubjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSubject
     */
    omit?: ClassSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectInclude<ExtArgs> | null
  }


  /**
   * Model Attendance
   */

  export type AggregateAttendance = {
    _count: AttendanceCountAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  export type AttendanceMinAggregateOutputType = {
    id: string | null
    date: Date | null
    status: $Enums.AttendanceStatus | null
    studentId: string | null
    sessionId: string | null
    remarks: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    status: $Enums.AttendanceStatus | null
    studentId: string | null
    sessionId: string | null
    remarks: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceCountAggregateOutputType = {
    id: number
    date: number
    status: number
    studentId: number
    sessionId: number
    remarks: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AttendanceMinAggregateInputType = {
    id?: true
    date?: true
    status?: true
    studentId?: true
    sessionId?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceMaxAggregateInputType = {
    id?: true
    date?: true
    status?: true
    studentId?: true
    sessionId?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceCountAggregateInputType = {
    id?: true
    date?: true
    status?: true
    studentId?: true
    sessionId?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendance to aggregate.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attendances
    **/
    _count?: true | AttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceMaxAggregateInputType
  }

  export type GetAttendanceAggregateType<T extends AttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendance[P]>
      : GetScalarType<T[P], AggregateAttendance[P]>
  }




  export type AttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithAggregationInput | AttendanceOrderByWithAggregationInput[]
    by: AttendanceScalarFieldEnum[] | AttendanceScalarFieldEnum
    having?: AttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceCountAggregateInputType | true
    _min?: AttendanceMinAggregateInputType
    _max?: AttendanceMaxAggregateInputType
  }

  export type AttendanceGroupByOutputType = {
    id: string
    date: Date
    status: $Enums.AttendanceStatus
    studentId: string
    sessionId: string
    remarks: string | null
    createdAt: Date
    updatedAt: Date
    _count: AttendanceCountAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  type GetAttendanceGroupByPayload<T extends AttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    status?: boolean
    studentId?: boolean
    sessionId?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | AcademicSessionDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    status?: boolean
    studentId?: boolean
    sessionId?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | AcademicSessionDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    status?: boolean
    studentId?: boolean
    sessionId?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | AcademicSessionDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectScalar = {
    id?: boolean
    date?: boolean
    status?: boolean
    studentId?: boolean
    sessionId?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AttendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "status" | "studentId" | "sessionId" | "remarks" | "createdAt" | "updatedAt", ExtArgs["result"]["attendance"]>
  export type AttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | AcademicSessionDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type AttendanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | AcademicSessionDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type AttendanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | AcademicSessionDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $AttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attendance"
    objects: {
      session: Prisma.$AcademicSessionPayload<ExtArgs>
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      status: $Enums.AttendanceStatus
      studentId: string
      sessionId: string
      remarks: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["attendance"]>
    composites: {}
  }

  type AttendanceGetPayload<S extends boolean | null | undefined | AttendanceDefaultArgs> = $Result.GetResult<Prisma.$AttendancePayload, S>

  type AttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceCountAggregateInputType | true
    }

  export interface AttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attendance'], meta: { name: 'Attendance' } }
    /**
     * Find zero or one Attendance that matches the filter.
     * @param {AttendanceFindUniqueArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceFindUniqueArgs>(args: SelectSubset<T, AttendanceFindUniqueArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceFindUniqueOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceFindFirstArgs>(args?: SelectSubset<T, AttendanceFindFirstArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendances
     * const attendances = await prisma.attendance.findMany()
     * 
     * // Get first 10 Attendances
     * const attendances = await prisma.attendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceWithIdOnly = await prisma.attendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceFindManyArgs>(args?: SelectSubset<T, AttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attendance.
     * @param {AttendanceCreateArgs} args - Arguments to create a Attendance.
     * @example
     * // Create one Attendance
     * const Attendance = await prisma.attendance.create({
     *   data: {
     *     // ... data to create a Attendance
     *   }
     * })
     * 
     */
    create<T extends AttendanceCreateArgs>(args: SelectSubset<T, AttendanceCreateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attendances.
     * @param {AttendanceCreateManyArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceCreateManyArgs>(args?: SelectSubset<T, AttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attendances and returns the data saved in the database.
     * @param {AttendanceCreateManyAndReturnArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Attendance.
     * @param {AttendanceDeleteArgs} args - Arguments to delete one Attendance.
     * @example
     * // Delete one Attendance
     * const Attendance = await prisma.attendance.delete({
     *   where: {
     *     // ... filter to delete one Attendance
     *   }
     * })
     * 
     */
    delete<T extends AttendanceDeleteArgs>(args: SelectSubset<T, AttendanceDeleteArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attendance.
     * @param {AttendanceUpdateArgs} args - Arguments to update one Attendance.
     * @example
     * // Update one Attendance
     * const attendance = await prisma.attendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceUpdateArgs>(args: SelectSubset<T, AttendanceUpdateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attendances.
     * @param {AttendanceDeleteManyArgs} args - Arguments to filter Attendances to delete.
     * @example
     * // Delete a few Attendances
     * const { count } = await prisma.attendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceDeleteManyArgs>(args?: SelectSubset<T, AttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceUpdateManyArgs>(args: SelectSubset<T, AttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances and returns the data updated in the database.
     * @param {AttendanceUpdateManyAndReturnArgs} args - Arguments to update many Attendances.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Attendance.
     * @param {AttendanceUpsertArgs} args - Arguments to update or create a Attendance.
     * @example
     * // Update or create a Attendance
     * const attendance = await prisma.attendance.upsert({
     *   create: {
     *     // ... data to create a Attendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendance we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceUpsertArgs>(args: SelectSubset<T, AttendanceUpsertArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCountArgs} args - Arguments to filter Attendances to count.
     * @example
     * // Count the number of Attendances
     * const count = await prisma.attendance.count({
     *   where: {
     *     // ... the filter for the Attendances we want to count
     *   }
     * })
    **/
    count<T extends AttendanceCountArgs>(
      args?: Subset<T, AttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceAggregateArgs>(args: Subset<T, AttendanceAggregateArgs>): Prisma.PrismaPromise<GetAttendanceAggregateType<T>>

    /**
     * Group by Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attendance model
   */
  readonly fields: AttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends AcademicSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSessionDefaultArgs<ExtArgs>>): Prisma__AcademicSessionClient<$Result.GetResult<Prisma.$AcademicSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attendance model
   */ 
  interface AttendanceFieldRefs {
    readonly id: FieldRef<"Attendance", 'String'>
    readonly date: FieldRef<"Attendance", 'DateTime'>
    readonly status: FieldRef<"Attendance", 'AttendanceStatus'>
    readonly studentId: FieldRef<"Attendance", 'String'>
    readonly sessionId: FieldRef<"Attendance", 'String'>
    readonly remarks: FieldRef<"Attendance", 'String'>
    readonly createdAt: FieldRef<"Attendance", 'DateTime'>
    readonly updatedAt: FieldRef<"Attendance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attendance findUnique
   */
  export type AttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findUniqueOrThrow
   */
  export type AttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findFirst
   */
  export type AttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findFirstOrThrow
   */
  export type AttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findMany
   */
  export type AttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendances to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance create
   */
  export type AttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Attendance.
     */
    data: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
  }

  /**
   * Attendance createMany
   */
  export type AttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attendance createManyAndReturn
   */
  export type AttendanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance update
   */
  export type AttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Attendance.
     */
    data: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
    /**
     * Choose, which Attendance to update.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance updateMany
   */
  export type AttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
  }

  /**
   * Attendance updateManyAndReturn
   */
  export type AttendanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance upsert
   */
  export type AttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Attendance to update in case it exists.
     */
    where: AttendanceWhereUniqueInput
    /**
     * In case the Attendance found by the `where` argument doesn't exist, create a new Attendance with this data.
     */
    create: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
    /**
     * In case the Attendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
  }

  /**
   * Attendance delete
   */
  export type AttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter which Attendance to delete.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance deleteMany
   */
  export type AttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendances to delete
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to delete.
     */
    limit?: number
  }

  /**
   * Attendance without action
   */
  export type AttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
  }


  /**
   * Model Result
   */

  export type AggregateResult = {
    _count: ResultCountAggregateOutputType | null
    _avg: ResultAvgAggregateOutputType | null
    _sum: ResultSumAggregateOutputType | null
    _min: ResultMinAggregateOutputType | null
    _max: ResultMaxAggregateOutputType | null
  }

  export type ResultAvgAggregateOutputType = {
    total: number | null
    cumulativeAverage: number | null
  }

  export type ResultSumAggregateOutputType = {
    total: number | null
    cumulativeAverage: number | null
  }

  export type ResultMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    subjectId: string | null
    periodId: string | null
    sessionId: string | null
    total: number | null
    grade: string | null
    remark: string | null
    cumulativeAverage: number | null
    teacherComment: string | null
    adminComment: string | null
    approvedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResultMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    subjectId: string | null
    periodId: string | null
    sessionId: string | null
    total: number | null
    grade: string | null
    remark: string | null
    cumulativeAverage: number | null
    teacherComment: string | null
    adminComment: string | null
    approvedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResultCountAggregateOutputType = {
    id: number
    studentId: number
    subjectId: number
    periodId: number
    sessionId: number
    total: number
    grade: number
    remark: number
    cumulativeAverage: number
    affectiveTraits: number
    psychomotorSkills: number
    customFields: number
    teacherComment: number
    adminComment: number
    approvedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ResultAvgAggregateInputType = {
    total?: true
    cumulativeAverage?: true
  }

  export type ResultSumAggregateInputType = {
    total?: true
    cumulativeAverage?: true
  }

  export type ResultMinAggregateInputType = {
    id?: true
    studentId?: true
    subjectId?: true
    periodId?: true
    sessionId?: true
    total?: true
    grade?: true
    remark?: true
    cumulativeAverage?: true
    teacherComment?: true
    adminComment?: true
    approvedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResultMaxAggregateInputType = {
    id?: true
    studentId?: true
    subjectId?: true
    periodId?: true
    sessionId?: true
    total?: true
    grade?: true
    remark?: true
    cumulativeAverage?: true
    teacherComment?: true
    adminComment?: true
    approvedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResultCountAggregateInputType = {
    id?: true
    studentId?: true
    subjectId?: true
    periodId?: true
    sessionId?: true
    total?: true
    grade?: true
    remark?: true
    cumulativeAverage?: true
    affectiveTraits?: true
    psychomotorSkills?: true
    customFields?: true
    teacherComment?: true
    adminComment?: true
    approvedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Result to aggregate.
     */
    where?: ResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Results to fetch.
     */
    orderBy?: ResultOrderByWithRelationInput | ResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Results
    **/
    _count?: true | ResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResultMaxAggregateInputType
  }

  export type GetResultAggregateType<T extends ResultAggregateArgs> = {
        [P in keyof T & keyof AggregateResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResult[P]>
      : GetScalarType<T[P], AggregateResult[P]>
  }




  export type ResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResultWhereInput
    orderBy?: ResultOrderByWithAggregationInput | ResultOrderByWithAggregationInput[]
    by: ResultScalarFieldEnum[] | ResultScalarFieldEnum
    having?: ResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResultCountAggregateInputType | true
    _avg?: ResultAvgAggregateInputType
    _sum?: ResultSumAggregateInputType
    _min?: ResultMinAggregateInputType
    _max?: ResultMaxAggregateInputType
  }

  export type ResultGroupByOutputType = {
    id: string
    studentId: string
    subjectId: string
    periodId: string
    sessionId: string
    total: number
    grade: string
    remark: string
    cumulativeAverage: number | null
    affectiveTraits: JsonValue | null
    psychomotorSkills: JsonValue | null
    customFields: JsonValue | null
    teacherComment: string | null
    adminComment: string | null
    approvedById: string | null
    createdAt: Date
    updatedAt: Date
    _count: ResultCountAggregateOutputType | null
    _avg: ResultAvgAggregateOutputType | null
    _sum: ResultSumAggregateOutputType | null
    _min: ResultMinAggregateOutputType | null
    _max: ResultMaxAggregateOutputType | null
  }

  type GetResultGroupByPayload<T extends ResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResultGroupByOutputType[P]>
            : GetScalarType<T[P], ResultGroupByOutputType[P]>
        }
      >
    >


  export type ResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    subjectId?: boolean
    periodId?: boolean
    sessionId?: boolean
    total?: boolean
    grade?: boolean
    remark?: boolean
    cumulativeAverage?: boolean
    affectiveTraits?: boolean
    psychomotorSkills?: boolean
    customFields?: boolean
    teacherComment?: boolean
    adminComment?: boolean
    approvedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    componentScores?: boolean | Result$componentScoresArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    period?: boolean | ResultPeriodDefaultArgs<ExtArgs>
    session?: boolean | AcademicSessionDefaultArgs<ExtArgs>
    approvedBy?: boolean | Result$approvedByArgs<ExtArgs>
    _count?: boolean | ResultCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["result"]>

  export type ResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    subjectId?: boolean
    periodId?: boolean
    sessionId?: boolean
    total?: boolean
    grade?: boolean
    remark?: boolean
    cumulativeAverage?: boolean
    affectiveTraits?: boolean
    psychomotorSkills?: boolean
    customFields?: boolean
    teacherComment?: boolean
    adminComment?: boolean
    approvedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    period?: boolean | ResultPeriodDefaultArgs<ExtArgs>
    session?: boolean | AcademicSessionDefaultArgs<ExtArgs>
    approvedBy?: boolean | Result$approvedByArgs<ExtArgs>
  }, ExtArgs["result"]["result"]>

  export type ResultSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    subjectId?: boolean
    periodId?: boolean
    sessionId?: boolean
    total?: boolean
    grade?: boolean
    remark?: boolean
    cumulativeAverage?: boolean
    affectiveTraits?: boolean
    psychomotorSkills?: boolean
    customFields?: boolean
    teacherComment?: boolean
    adminComment?: boolean
    approvedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    period?: boolean | ResultPeriodDefaultArgs<ExtArgs>
    session?: boolean | AcademicSessionDefaultArgs<ExtArgs>
    approvedBy?: boolean | Result$approvedByArgs<ExtArgs>
  }, ExtArgs["result"]["result"]>

  export type ResultSelectScalar = {
    id?: boolean
    studentId?: boolean
    subjectId?: boolean
    periodId?: boolean
    sessionId?: boolean
    total?: boolean
    grade?: boolean
    remark?: boolean
    cumulativeAverage?: boolean
    affectiveTraits?: boolean
    psychomotorSkills?: boolean
    customFields?: boolean
    teacherComment?: boolean
    adminComment?: boolean
    approvedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "subjectId" | "periodId" | "sessionId" | "total" | "grade" | "remark" | "cumulativeAverage" | "affectiveTraits" | "psychomotorSkills" | "customFields" | "teacherComment" | "adminComment" | "approvedById" | "createdAt" | "updatedAt", ExtArgs["result"]["result"]>
  export type ResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    componentScores?: boolean | Result$componentScoresArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    period?: boolean | ResultPeriodDefaultArgs<ExtArgs>
    session?: boolean | AcademicSessionDefaultArgs<ExtArgs>
    approvedBy?: boolean | Result$approvedByArgs<ExtArgs>
    _count?: boolean | ResultCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    period?: boolean | ResultPeriodDefaultArgs<ExtArgs>
    session?: boolean | AcademicSessionDefaultArgs<ExtArgs>
    approvedBy?: boolean | Result$approvedByArgs<ExtArgs>
  }
  export type ResultIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    period?: boolean | ResultPeriodDefaultArgs<ExtArgs>
    session?: boolean | AcademicSessionDefaultArgs<ExtArgs>
    approvedBy?: boolean | Result$approvedByArgs<ExtArgs>
  }

  export type $ResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Result"
    objects: {
      componentScores: Prisma.$ComponentScorePayload<ExtArgs>[]
      student: Prisma.$StudentPayload<ExtArgs>
      subject: Prisma.$SubjectPayload<ExtArgs>
      period: Prisma.$ResultPeriodPayload<ExtArgs>
      session: Prisma.$AcademicSessionPayload<ExtArgs>
      approvedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      subjectId: string
      periodId: string
      sessionId: string
      total: number
      grade: string
      remark: string
      cumulativeAverage: number | null
      affectiveTraits: Prisma.JsonValue | null
      psychomotorSkills: Prisma.JsonValue | null
      customFields: Prisma.JsonValue | null
      teacherComment: string | null
      adminComment: string | null
      approvedById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["result"]>
    composites: {}
  }

  type ResultGetPayload<S extends boolean | null | undefined | ResultDefaultArgs> = $Result.GetResult<Prisma.$ResultPayload, S>

  type ResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResultCountAggregateInputType | true
    }

  export interface ResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Result'], meta: { name: 'Result' } }
    /**
     * Find zero or one Result that matches the filter.
     * @param {ResultFindUniqueArgs} args - Arguments to find a Result
     * @example
     * // Get one Result
     * const result = await prisma.result.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResultFindUniqueArgs>(args: SelectSubset<T, ResultFindUniqueArgs<ExtArgs>>): Prisma__ResultClient<$Result.GetResult<Prisma.$ResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Result that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResultFindUniqueOrThrowArgs} args - Arguments to find a Result
     * @example
     * // Get one Result
     * const result = await prisma.result.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResultFindUniqueOrThrowArgs>(args: SelectSubset<T, ResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResultClient<$Result.GetResult<Prisma.$ResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Result that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultFindFirstArgs} args - Arguments to find a Result
     * @example
     * // Get one Result
     * const result = await prisma.result.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResultFindFirstArgs>(args?: SelectSubset<T, ResultFindFirstArgs<ExtArgs>>): Prisma__ResultClient<$Result.GetResult<Prisma.$ResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Result that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultFindFirstOrThrowArgs} args - Arguments to find a Result
     * @example
     * // Get one Result
     * const result = await prisma.result.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResultFindFirstOrThrowArgs>(args?: SelectSubset<T, ResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResultClient<$Result.GetResult<Prisma.$ResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Results that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Results
     * const results = await prisma.result.findMany()
     * 
     * // Get first 10 Results
     * const results = await prisma.result.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resultWithIdOnly = await prisma.result.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResultFindManyArgs>(args?: SelectSubset<T, ResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Result.
     * @param {ResultCreateArgs} args - Arguments to create a Result.
     * @example
     * // Create one Result
     * const Result = await prisma.result.create({
     *   data: {
     *     // ... data to create a Result
     *   }
     * })
     * 
     */
    create<T extends ResultCreateArgs>(args: SelectSubset<T, ResultCreateArgs<ExtArgs>>): Prisma__ResultClient<$Result.GetResult<Prisma.$ResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Results.
     * @param {ResultCreateManyArgs} args - Arguments to create many Results.
     * @example
     * // Create many Results
     * const result = await prisma.result.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResultCreateManyArgs>(args?: SelectSubset<T, ResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Results and returns the data saved in the database.
     * @param {ResultCreateManyAndReturnArgs} args - Arguments to create many Results.
     * @example
     * // Create many Results
     * const result = await prisma.result.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Results and only return the `id`
     * const resultWithIdOnly = await prisma.result.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResultCreateManyAndReturnArgs>(args?: SelectSubset<T, ResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Result.
     * @param {ResultDeleteArgs} args - Arguments to delete one Result.
     * @example
     * // Delete one Result
     * const Result = await prisma.result.delete({
     *   where: {
     *     // ... filter to delete one Result
     *   }
     * })
     * 
     */
    delete<T extends ResultDeleteArgs>(args: SelectSubset<T, ResultDeleteArgs<ExtArgs>>): Prisma__ResultClient<$Result.GetResult<Prisma.$ResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Result.
     * @param {ResultUpdateArgs} args - Arguments to update one Result.
     * @example
     * // Update one Result
     * const result = await prisma.result.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResultUpdateArgs>(args: SelectSubset<T, ResultUpdateArgs<ExtArgs>>): Prisma__ResultClient<$Result.GetResult<Prisma.$ResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Results.
     * @param {ResultDeleteManyArgs} args - Arguments to filter Results to delete.
     * @example
     * // Delete a few Results
     * const { count } = await prisma.result.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResultDeleteManyArgs>(args?: SelectSubset<T, ResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Results
     * const result = await prisma.result.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResultUpdateManyArgs>(args: SelectSubset<T, ResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Results and returns the data updated in the database.
     * @param {ResultUpdateManyAndReturnArgs} args - Arguments to update many Results.
     * @example
     * // Update many Results
     * const result = await prisma.result.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Results and only return the `id`
     * const resultWithIdOnly = await prisma.result.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResultUpdateManyAndReturnArgs>(args: SelectSubset<T, ResultUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Result.
     * @param {ResultUpsertArgs} args - Arguments to update or create a Result.
     * @example
     * // Update or create a Result
     * const result = await prisma.result.upsert({
     *   create: {
     *     // ... data to create a Result
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Result we want to update
     *   }
     * })
     */
    upsert<T extends ResultUpsertArgs>(args: SelectSubset<T, ResultUpsertArgs<ExtArgs>>): Prisma__ResultClient<$Result.GetResult<Prisma.$ResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultCountArgs} args - Arguments to filter Results to count.
     * @example
     * // Count the number of Results
     * const count = await prisma.result.count({
     *   where: {
     *     // ... the filter for the Results we want to count
     *   }
     * })
    **/
    count<T extends ResultCountArgs>(
      args?: Subset<T, ResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Result.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResultAggregateArgs>(args: Subset<T, ResultAggregateArgs>): Prisma.PrismaPromise<GetResultAggregateType<T>>

    /**
     * Group by Result.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResultGroupByArgs['orderBy'] }
        : { orderBy?: ResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Result model
   */
  readonly fields: ResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Result.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    componentScores<T extends Result$componentScoresArgs<ExtArgs> = {}>(args?: Subset<T, Result$componentScoresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComponentScorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    period<T extends ResultPeriodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResultPeriodDefaultArgs<ExtArgs>>): Prisma__ResultPeriodClient<$Result.GetResult<Prisma.$ResultPeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    session<T extends AcademicSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSessionDefaultArgs<ExtArgs>>): Prisma__AcademicSessionClient<$Result.GetResult<Prisma.$AcademicSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    approvedBy<T extends Result$approvedByArgs<ExtArgs> = {}>(args?: Subset<T, Result$approvedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Result model
   */ 
  interface ResultFieldRefs {
    readonly id: FieldRef<"Result", 'String'>
    readonly studentId: FieldRef<"Result", 'String'>
    readonly subjectId: FieldRef<"Result", 'String'>
    readonly periodId: FieldRef<"Result", 'String'>
    readonly sessionId: FieldRef<"Result", 'String'>
    readonly total: FieldRef<"Result", 'Float'>
    readonly grade: FieldRef<"Result", 'String'>
    readonly remark: FieldRef<"Result", 'String'>
    readonly cumulativeAverage: FieldRef<"Result", 'Float'>
    readonly affectiveTraits: FieldRef<"Result", 'Json'>
    readonly psychomotorSkills: FieldRef<"Result", 'Json'>
    readonly customFields: FieldRef<"Result", 'Json'>
    readonly teacherComment: FieldRef<"Result", 'String'>
    readonly adminComment: FieldRef<"Result", 'String'>
    readonly approvedById: FieldRef<"Result", 'String'>
    readonly createdAt: FieldRef<"Result", 'DateTime'>
    readonly updatedAt: FieldRef<"Result", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Result findUnique
   */
  export type ResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Result
     */
    select?: ResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Result
     */
    omit?: ResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultInclude<ExtArgs> | null
    /**
     * Filter, which Result to fetch.
     */
    where: ResultWhereUniqueInput
  }

  /**
   * Result findUniqueOrThrow
   */
  export type ResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Result
     */
    select?: ResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Result
     */
    omit?: ResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultInclude<ExtArgs> | null
    /**
     * Filter, which Result to fetch.
     */
    where: ResultWhereUniqueInput
  }

  /**
   * Result findFirst
   */
  export type ResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Result
     */
    select?: ResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Result
     */
    omit?: ResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultInclude<ExtArgs> | null
    /**
     * Filter, which Result to fetch.
     */
    where?: ResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Results to fetch.
     */
    orderBy?: ResultOrderByWithRelationInput | ResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Results.
     */
    cursor?: ResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Results.
     */
    distinct?: ResultScalarFieldEnum | ResultScalarFieldEnum[]
  }

  /**
   * Result findFirstOrThrow
   */
  export type ResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Result
     */
    select?: ResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Result
     */
    omit?: ResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultInclude<ExtArgs> | null
    /**
     * Filter, which Result to fetch.
     */
    where?: ResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Results to fetch.
     */
    orderBy?: ResultOrderByWithRelationInput | ResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Results.
     */
    cursor?: ResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Results.
     */
    distinct?: ResultScalarFieldEnum | ResultScalarFieldEnum[]
  }

  /**
   * Result findMany
   */
  export type ResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Result
     */
    select?: ResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Result
     */
    omit?: ResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultInclude<ExtArgs> | null
    /**
     * Filter, which Results to fetch.
     */
    where?: ResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Results to fetch.
     */
    orderBy?: ResultOrderByWithRelationInput | ResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Results.
     */
    cursor?: ResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Results.
     */
    skip?: number
    distinct?: ResultScalarFieldEnum | ResultScalarFieldEnum[]
  }

  /**
   * Result create
   */
  export type ResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Result
     */
    select?: ResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Result
     */
    omit?: ResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultInclude<ExtArgs> | null
    /**
     * The data needed to create a Result.
     */
    data: XOR<ResultCreateInput, ResultUncheckedCreateInput>
  }

  /**
   * Result createMany
   */
  export type ResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Results.
     */
    data: ResultCreateManyInput | ResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Result createManyAndReturn
   */
  export type ResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Result
     */
    select?: ResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Result
     */
    omit?: ResultOmit<ExtArgs> | null
    /**
     * The data used to create many Results.
     */
    data: ResultCreateManyInput | ResultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Result update
   */
  export type ResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Result
     */
    select?: ResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Result
     */
    omit?: ResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultInclude<ExtArgs> | null
    /**
     * The data needed to update a Result.
     */
    data: XOR<ResultUpdateInput, ResultUncheckedUpdateInput>
    /**
     * Choose, which Result to update.
     */
    where: ResultWhereUniqueInput
  }

  /**
   * Result updateMany
   */
  export type ResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Results.
     */
    data: XOR<ResultUpdateManyMutationInput, ResultUncheckedUpdateManyInput>
    /**
     * Filter which Results to update
     */
    where?: ResultWhereInput
    /**
     * Limit how many Results to update.
     */
    limit?: number
  }

  /**
   * Result updateManyAndReturn
   */
  export type ResultUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Result
     */
    select?: ResultSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Result
     */
    omit?: ResultOmit<ExtArgs> | null
    /**
     * The data used to update Results.
     */
    data: XOR<ResultUpdateManyMutationInput, ResultUncheckedUpdateManyInput>
    /**
     * Filter which Results to update
     */
    where?: ResultWhereInput
    /**
     * Limit how many Results to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Result upsert
   */
  export type ResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Result
     */
    select?: ResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Result
     */
    omit?: ResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultInclude<ExtArgs> | null
    /**
     * The filter to search for the Result to update in case it exists.
     */
    where: ResultWhereUniqueInput
    /**
     * In case the Result found by the `where` argument doesn't exist, create a new Result with this data.
     */
    create: XOR<ResultCreateInput, ResultUncheckedCreateInput>
    /**
     * In case the Result was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResultUpdateInput, ResultUncheckedUpdateInput>
  }

  /**
   * Result delete
   */
  export type ResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Result
     */
    select?: ResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Result
     */
    omit?: ResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultInclude<ExtArgs> | null
    /**
     * Filter which Result to delete.
     */
    where: ResultWhereUniqueInput
  }

  /**
   * Result deleteMany
   */
  export type ResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Results to delete
     */
    where?: ResultWhereInput
    /**
     * Limit how many Results to delete.
     */
    limit?: number
  }

  /**
   * Result.componentScores
   */
  export type Result$componentScoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentScore
     */
    select?: ComponentScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentScore
     */
    omit?: ComponentScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentScoreInclude<ExtArgs> | null
    where?: ComponentScoreWhereInput
    orderBy?: ComponentScoreOrderByWithRelationInput | ComponentScoreOrderByWithRelationInput[]
    cursor?: ComponentScoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComponentScoreScalarFieldEnum | ComponentScoreScalarFieldEnum[]
  }

  /**
   * Result.approvedBy
   */
  export type Result$approvedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Result without action
   */
  export type ResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Result
     */
    select?: ResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Result
     */
    omit?: ResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultInclude<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    location: string | null
    isPublic: boolean | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    location: string | null
    isPublic: boolean | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    title: number
    description: number
    startDate: number
    endDate: number
    location: number
    isPublic: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startDate?: true
    endDate?: true
    location?: true
    isPublic?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startDate?: true
    endDate?: true
    location?: true
    isPublic?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startDate?: true
    endDate?: true
    location?: true
    isPublic?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: string
    title: string
    description: string | null
    startDate: Date
    endDate: Date | null
    location: string | null
    isPublic: boolean
    schoolId: string
    createdAt: Date
    updatedAt: Date
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    location?: boolean
    isPublic?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    location?: boolean
    isPublic?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    location?: boolean
    isPublic?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    location?: boolean
    isPublic?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "startDate" | "endDate" | "location" | "isPublic" | "schoolId" | "createdAt" | "updatedAt", ExtArgs["result"]["event"]>
  export type EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type EventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type EventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      startDate: Date
      endDate: Date | null
      location: string | null
      isPublic: boolean
      schoolId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {EventCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventCreateManyAndReturnArgs>(args?: SelectSubset<T, EventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events and returns the data updated in the database.
     * @param {EventUpdateManyAndReturnArgs} args - Arguments to update many Events.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventUpdateManyAndReturnArgs>(args: SelectSubset<T, EventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */ 
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", 'String'>
    readonly title: FieldRef<"Event", 'String'>
    readonly description: FieldRef<"Event", 'String'>
    readonly startDate: FieldRef<"Event", 'DateTime'>
    readonly endDate: FieldRef<"Event", 'DateTime'>
    readonly location: FieldRef<"Event", 'String'>
    readonly isPublic: FieldRef<"Event", 'Boolean'>
    readonly schoolId: FieldRef<"Event", 'String'>
    readonly createdAt: FieldRef<"Event", 'DateTime'>
    readonly updatedAt: FieldRef<"Event", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event createManyAndReturn
   */
  export type EventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Event updateManyAndReturn
   */
  export type EventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to delete.
     */
    limit?: number
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
  }


  /**
   * Model StudentSubject
   */

  export type AggregateStudentSubject = {
    _count: StudentSubjectCountAggregateOutputType | null
    _min: StudentSubjectMinAggregateOutputType | null
    _max: StudentSubjectMaxAggregateOutputType | null
  }

  export type StudentSubjectMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    subjectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentSubjectMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    subjectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentSubjectCountAggregateOutputType = {
    id: number
    studentId: number
    subjectId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentSubjectMinAggregateInputType = {
    id?: true
    studentId?: true
    subjectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentSubjectMaxAggregateInputType = {
    id?: true
    studentId?: true
    subjectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentSubjectCountAggregateInputType = {
    id?: true
    studentId?: true
    subjectId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentSubjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSubject to aggregate.
     */
    where?: StudentSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSubjects to fetch.
     */
    orderBy?: StudentSubjectOrderByWithRelationInput | StudentSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentSubjects
    **/
    _count?: true | StudentSubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentSubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentSubjectMaxAggregateInputType
  }

  export type GetStudentSubjectAggregateType<T extends StudentSubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentSubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentSubject[P]>
      : GetScalarType<T[P], AggregateStudentSubject[P]>
  }




  export type StudentSubjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSubjectWhereInput
    orderBy?: StudentSubjectOrderByWithAggregationInput | StudentSubjectOrderByWithAggregationInput[]
    by: StudentSubjectScalarFieldEnum[] | StudentSubjectScalarFieldEnum
    having?: StudentSubjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentSubjectCountAggregateInputType | true
    _min?: StudentSubjectMinAggregateInputType
    _max?: StudentSubjectMaxAggregateInputType
  }

  export type StudentSubjectGroupByOutputType = {
    id: string
    studentId: string
    subjectId: string
    createdAt: Date
    updatedAt: Date
    _count: StudentSubjectCountAggregateOutputType | null
    _min: StudentSubjectMinAggregateOutputType | null
    _max: StudentSubjectMaxAggregateOutputType | null
  }

  type GetStudentSubjectGroupByPayload<T extends StudentSubjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentSubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentSubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentSubjectGroupByOutputType[P]>
            : GetScalarType<T[P], StudentSubjectGroupByOutputType[P]>
        }
      >
    >


  export type StudentSubjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    subjectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentSubject"]>

  export type StudentSubjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    subjectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentSubject"]>

  export type StudentSubjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    subjectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentSubject"]>

  export type StudentSubjectSelectScalar = {
    id?: boolean
    studentId?: boolean
    subjectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentSubjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "subjectId" | "createdAt" | "updatedAt", ExtArgs["result"]["studentSubject"]>
  export type StudentSubjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }
  export type StudentSubjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }
  export type StudentSubjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }

  export type $StudentSubjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentSubject"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      subject: Prisma.$SubjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      subjectId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studentSubject"]>
    composites: {}
  }

  type StudentSubjectGetPayload<S extends boolean | null | undefined | StudentSubjectDefaultArgs> = $Result.GetResult<Prisma.$StudentSubjectPayload, S>

  type StudentSubjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentSubjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentSubjectCountAggregateInputType | true
    }

  export interface StudentSubjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentSubject'], meta: { name: 'StudentSubject' } }
    /**
     * Find zero or one StudentSubject that matches the filter.
     * @param {StudentSubjectFindUniqueArgs} args - Arguments to find a StudentSubject
     * @example
     * // Get one StudentSubject
     * const studentSubject = await prisma.studentSubject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentSubjectFindUniqueArgs>(args: SelectSubset<T, StudentSubjectFindUniqueArgs<ExtArgs>>): Prisma__StudentSubjectClient<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentSubject that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentSubjectFindUniqueOrThrowArgs} args - Arguments to find a StudentSubject
     * @example
     * // Get one StudentSubject
     * const studentSubject = await prisma.studentSubject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentSubjectFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentSubjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentSubjectClient<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentSubject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSubjectFindFirstArgs} args - Arguments to find a StudentSubject
     * @example
     * // Get one StudentSubject
     * const studentSubject = await prisma.studentSubject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentSubjectFindFirstArgs>(args?: SelectSubset<T, StudentSubjectFindFirstArgs<ExtArgs>>): Prisma__StudentSubjectClient<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentSubject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSubjectFindFirstOrThrowArgs} args - Arguments to find a StudentSubject
     * @example
     * // Get one StudentSubject
     * const studentSubject = await prisma.studentSubject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentSubjectFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentSubjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentSubjectClient<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentSubjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSubjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentSubjects
     * const studentSubjects = await prisma.studentSubject.findMany()
     * 
     * // Get first 10 StudentSubjects
     * const studentSubjects = await prisma.studentSubject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentSubjectWithIdOnly = await prisma.studentSubject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentSubjectFindManyArgs>(args?: SelectSubset<T, StudentSubjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentSubject.
     * @param {StudentSubjectCreateArgs} args - Arguments to create a StudentSubject.
     * @example
     * // Create one StudentSubject
     * const StudentSubject = await prisma.studentSubject.create({
     *   data: {
     *     // ... data to create a StudentSubject
     *   }
     * })
     * 
     */
    create<T extends StudentSubjectCreateArgs>(args: SelectSubset<T, StudentSubjectCreateArgs<ExtArgs>>): Prisma__StudentSubjectClient<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentSubjects.
     * @param {StudentSubjectCreateManyArgs} args - Arguments to create many StudentSubjects.
     * @example
     * // Create many StudentSubjects
     * const studentSubject = await prisma.studentSubject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentSubjectCreateManyArgs>(args?: SelectSubset<T, StudentSubjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentSubjects and returns the data saved in the database.
     * @param {StudentSubjectCreateManyAndReturnArgs} args - Arguments to create many StudentSubjects.
     * @example
     * // Create many StudentSubjects
     * const studentSubject = await prisma.studentSubject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentSubjects and only return the `id`
     * const studentSubjectWithIdOnly = await prisma.studentSubject.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentSubjectCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentSubjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudentSubject.
     * @param {StudentSubjectDeleteArgs} args - Arguments to delete one StudentSubject.
     * @example
     * // Delete one StudentSubject
     * const StudentSubject = await prisma.studentSubject.delete({
     *   where: {
     *     // ... filter to delete one StudentSubject
     *   }
     * })
     * 
     */
    delete<T extends StudentSubjectDeleteArgs>(args: SelectSubset<T, StudentSubjectDeleteArgs<ExtArgs>>): Prisma__StudentSubjectClient<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentSubject.
     * @param {StudentSubjectUpdateArgs} args - Arguments to update one StudentSubject.
     * @example
     * // Update one StudentSubject
     * const studentSubject = await prisma.studentSubject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentSubjectUpdateArgs>(args: SelectSubset<T, StudentSubjectUpdateArgs<ExtArgs>>): Prisma__StudentSubjectClient<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentSubjects.
     * @param {StudentSubjectDeleteManyArgs} args - Arguments to filter StudentSubjects to delete.
     * @example
     * // Delete a few StudentSubjects
     * const { count } = await prisma.studentSubject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentSubjectDeleteManyArgs>(args?: SelectSubset<T, StudentSubjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentSubjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSubjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentSubjects
     * const studentSubject = await prisma.studentSubject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentSubjectUpdateManyArgs>(args: SelectSubset<T, StudentSubjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentSubjects and returns the data updated in the database.
     * @param {StudentSubjectUpdateManyAndReturnArgs} args - Arguments to update many StudentSubjects.
     * @example
     * // Update many StudentSubjects
     * const studentSubject = await prisma.studentSubject.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudentSubjects and only return the `id`
     * const studentSubjectWithIdOnly = await prisma.studentSubject.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentSubjectUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentSubjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudentSubject.
     * @param {StudentSubjectUpsertArgs} args - Arguments to update or create a StudentSubject.
     * @example
     * // Update or create a StudentSubject
     * const studentSubject = await prisma.studentSubject.upsert({
     *   create: {
     *     // ... data to create a StudentSubject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentSubject we want to update
     *   }
     * })
     */
    upsert<T extends StudentSubjectUpsertArgs>(args: SelectSubset<T, StudentSubjectUpsertArgs<ExtArgs>>): Prisma__StudentSubjectClient<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentSubjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSubjectCountArgs} args - Arguments to filter StudentSubjects to count.
     * @example
     * // Count the number of StudentSubjects
     * const count = await prisma.studentSubject.count({
     *   where: {
     *     // ... the filter for the StudentSubjects we want to count
     *   }
     * })
    **/
    count<T extends StudentSubjectCountArgs>(
      args?: Subset<T, StudentSubjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentSubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentSubject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentSubjectAggregateArgs>(args: Subset<T, StudentSubjectAggregateArgs>): Prisma.PrismaPromise<GetStudentSubjectAggregateType<T>>

    /**
     * Group by StudentSubject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentSubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentSubjectGroupByArgs['orderBy'] }
        : { orderBy?: StudentSubjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentSubjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentSubjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentSubject model
   */
  readonly fields: StudentSubjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentSubject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentSubjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentSubject model
   */ 
  interface StudentSubjectFieldRefs {
    readonly id: FieldRef<"StudentSubject", 'String'>
    readonly studentId: FieldRef<"StudentSubject", 'String'>
    readonly subjectId: FieldRef<"StudentSubject", 'String'>
    readonly createdAt: FieldRef<"StudentSubject", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentSubject", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentSubject findUnique
   */
  export type StudentSubjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSubject
     */
    omit?: StudentSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectInclude<ExtArgs> | null
    /**
     * Filter, which StudentSubject to fetch.
     */
    where: StudentSubjectWhereUniqueInput
  }

  /**
   * StudentSubject findUniqueOrThrow
   */
  export type StudentSubjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSubject
     */
    omit?: StudentSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectInclude<ExtArgs> | null
    /**
     * Filter, which StudentSubject to fetch.
     */
    where: StudentSubjectWhereUniqueInput
  }

  /**
   * StudentSubject findFirst
   */
  export type StudentSubjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSubject
     */
    omit?: StudentSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectInclude<ExtArgs> | null
    /**
     * Filter, which StudentSubject to fetch.
     */
    where?: StudentSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSubjects to fetch.
     */
    orderBy?: StudentSubjectOrderByWithRelationInput | StudentSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSubjects.
     */
    cursor?: StudentSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSubjects.
     */
    distinct?: StudentSubjectScalarFieldEnum | StudentSubjectScalarFieldEnum[]
  }

  /**
   * StudentSubject findFirstOrThrow
   */
  export type StudentSubjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSubject
     */
    omit?: StudentSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectInclude<ExtArgs> | null
    /**
     * Filter, which StudentSubject to fetch.
     */
    where?: StudentSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSubjects to fetch.
     */
    orderBy?: StudentSubjectOrderByWithRelationInput | StudentSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSubjects.
     */
    cursor?: StudentSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSubjects.
     */
    distinct?: StudentSubjectScalarFieldEnum | StudentSubjectScalarFieldEnum[]
  }

  /**
   * StudentSubject findMany
   */
  export type StudentSubjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSubject
     */
    omit?: StudentSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectInclude<ExtArgs> | null
    /**
     * Filter, which StudentSubjects to fetch.
     */
    where?: StudentSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSubjects to fetch.
     */
    orderBy?: StudentSubjectOrderByWithRelationInput | StudentSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentSubjects.
     */
    cursor?: StudentSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSubjects.
     */
    skip?: number
    distinct?: StudentSubjectScalarFieldEnum | StudentSubjectScalarFieldEnum[]
  }

  /**
   * StudentSubject create
   */
  export type StudentSubjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSubject
     */
    omit?: StudentSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentSubject.
     */
    data: XOR<StudentSubjectCreateInput, StudentSubjectUncheckedCreateInput>
  }

  /**
   * StudentSubject createMany
   */
  export type StudentSubjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentSubjects.
     */
    data: StudentSubjectCreateManyInput | StudentSubjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentSubject createManyAndReturn
   */
  export type StudentSubjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSubject
     */
    omit?: StudentSubjectOmit<ExtArgs> | null
    /**
     * The data used to create many StudentSubjects.
     */
    data: StudentSubjectCreateManyInput | StudentSubjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentSubject update
   */
  export type StudentSubjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSubject
     */
    omit?: StudentSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentSubject.
     */
    data: XOR<StudentSubjectUpdateInput, StudentSubjectUncheckedUpdateInput>
    /**
     * Choose, which StudentSubject to update.
     */
    where: StudentSubjectWhereUniqueInput
  }

  /**
   * StudentSubject updateMany
   */
  export type StudentSubjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentSubjects.
     */
    data: XOR<StudentSubjectUpdateManyMutationInput, StudentSubjectUncheckedUpdateManyInput>
    /**
     * Filter which StudentSubjects to update
     */
    where?: StudentSubjectWhereInput
    /**
     * Limit how many StudentSubjects to update.
     */
    limit?: number
  }

  /**
   * StudentSubject updateManyAndReturn
   */
  export type StudentSubjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSubject
     */
    omit?: StudentSubjectOmit<ExtArgs> | null
    /**
     * The data used to update StudentSubjects.
     */
    data: XOR<StudentSubjectUpdateManyMutationInput, StudentSubjectUncheckedUpdateManyInput>
    /**
     * Filter which StudentSubjects to update
     */
    where?: StudentSubjectWhereInput
    /**
     * Limit how many StudentSubjects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentSubject upsert
   */
  export type StudentSubjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSubject
     */
    omit?: StudentSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentSubject to update in case it exists.
     */
    where: StudentSubjectWhereUniqueInput
    /**
     * In case the StudentSubject found by the `where` argument doesn't exist, create a new StudentSubject with this data.
     */
    create: XOR<StudentSubjectCreateInput, StudentSubjectUncheckedCreateInput>
    /**
     * In case the StudentSubject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentSubjectUpdateInput, StudentSubjectUncheckedUpdateInput>
  }

  /**
   * StudentSubject delete
   */
  export type StudentSubjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSubject
     */
    omit?: StudentSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectInclude<ExtArgs> | null
    /**
     * Filter which StudentSubject to delete.
     */
    where: StudentSubjectWhereUniqueInput
  }

  /**
   * StudentSubject deleteMany
   */
  export type StudentSubjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSubjects to delete
     */
    where?: StudentSubjectWhereInput
    /**
     * Limit how many StudentSubjects to delete.
     */
    limit?: number
  }

  /**
   * StudentSubject without action
   */
  export type StudentSubjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSubject
     */
    omit?: StudentSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectInclude<ExtArgs> | null
  }


  /**
   * Model Bill
   */

  export type AggregateBill = {
    _count: BillCountAggregateOutputType | null
    _avg: BillAvgAggregateOutputType | null
    _sum: BillSumAggregateOutputType | null
    _min: BillMinAggregateOutputType | null
    _max: BillMaxAggregateOutputType | null
  }

  export type BillAvgAggregateOutputType = {
    amount: number | null
  }

  export type BillSumAggregateOutputType = {
    amount: number | null
  }

  export type BillMinAggregateOutputType = {
    id: string | null
    name: string | null
    amount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    schoolId: string | null
    accountId: string | null
  }

  export type BillMaxAggregateOutputType = {
    id: string | null
    name: string | null
    amount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    schoolId: string | null
    accountId: string | null
  }

  export type BillCountAggregateOutputType = {
    id: number
    name: number
    amount: number
    createdAt: number
    updatedAt: number
    schoolId: number
    accountId: number
    _all: number
  }


  export type BillAvgAggregateInputType = {
    amount?: true
  }

  export type BillSumAggregateInputType = {
    amount?: true
  }

  export type BillMinAggregateInputType = {
    id?: true
    name?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
    schoolId?: true
    accountId?: true
  }

  export type BillMaxAggregateInputType = {
    id?: true
    name?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
    schoolId?: true
    accountId?: true
  }

  export type BillCountAggregateInputType = {
    id?: true
    name?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
    schoolId?: true
    accountId?: true
    _all?: true
  }

  export type BillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bill to aggregate.
     */
    where?: BillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bills
    **/
    _count?: true | BillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillMaxAggregateInputType
  }

  export type GetBillAggregateType<T extends BillAggregateArgs> = {
        [P in keyof T & keyof AggregateBill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBill[P]>
      : GetScalarType<T[P], AggregateBill[P]>
  }




  export type BillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillWhereInput
    orderBy?: BillOrderByWithAggregationInput | BillOrderByWithAggregationInput[]
    by: BillScalarFieldEnum[] | BillScalarFieldEnum
    having?: BillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillCountAggregateInputType | true
    _avg?: BillAvgAggregateInputType
    _sum?: BillSumAggregateInputType
    _min?: BillMinAggregateInputType
    _max?: BillMaxAggregateInputType
  }

  export type BillGroupByOutputType = {
    id: string
    name: string
    amount: number
    createdAt: Date
    updatedAt: Date
    schoolId: string
    accountId: string
    _count: BillCountAggregateOutputType | null
    _avg: BillAvgAggregateOutputType | null
    _sum: BillSumAggregateOutputType | null
    _min: BillMinAggregateOutputType | null
    _max: BillMaxAggregateOutputType | null
  }

  type GetBillGroupByPayload<T extends BillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillGroupByOutputType[P]>
            : GetScalarType<T[P], BillGroupByOutputType[P]>
        }
      >
    >


  export type BillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    schoolId?: boolean
    accountId?: boolean
    account?: boolean | PaymentAccountDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    assignments?: boolean | Bill$assignmentsArgs<ExtArgs>
    items?: boolean | Bill$itemsArgs<ExtArgs>
    paymentRequests?: boolean | Bill$paymentRequestsArgs<ExtArgs>
    _count?: boolean | BillCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bill"]>

  export type BillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    schoolId?: boolean
    accountId?: boolean
    account?: boolean | PaymentAccountDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bill"]>

  export type BillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    schoolId?: boolean
    accountId?: boolean
    account?: boolean | PaymentAccountDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bill"]>

  export type BillSelectScalar = {
    id?: boolean
    name?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    schoolId?: boolean
    accountId?: boolean
  }

  export type BillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "amount" | "createdAt" | "updatedAt" | "schoolId" | "accountId", ExtArgs["result"]["bill"]>
  export type BillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | PaymentAccountDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    assignments?: boolean | Bill$assignmentsArgs<ExtArgs>
    items?: boolean | Bill$itemsArgs<ExtArgs>
    paymentRequests?: boolean | Bill$paymentRequestsArgs<ExtArgs>
    _count?: boolean | BillCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | PaymentAccountDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type BillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | PaymentAccountDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $BillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bill"
    objects: {
      account: Prisma.$PaymentAccountPayload<ExtArgs>
      school: Prisma.$SchoolPayload<ExtArgs>
      assignments: Prisma.$BillAssignmentPayload<ExtArgs>[]
      items: Prisma.$BillItemPayload<ExtArgs>[]
      paymentRequests: Prisma.$PaymentRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      amount: number
      createdAt: Date
      updatedAt: Date
      schoolId: string
      accountId: string
    }, ExtArgs["result"]["bill"]>
    composites: {}
  }

  type BillGetPayload<S extends boolean | null | undefined | BillDefaultArgs> = $Result.GetResult<Prisma.$BillPayload, S>

  type BillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BillCountAggregateInputType | true
    }

  export interface BillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bill'], meta: { name: 'Bill' } }
    /**
     * Find zero or one Bill that matches the filter.
     * @param {BillFindUniqueArgs} args - Arguments to find a Bill
     * @example
     * // Get one Bill
     * const bill = await prisma.bill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillFindUniqueArgs>(args: SelectSubset<T, BillFindUniqueArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BillFindUniqueOrThrowArgs} args - Arguments to find a Bill
     * @example
     * // Get one Bill
     * const bill = await prisma.bill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillFindUniqueOrThrowArgs>(args: SelectSubset<T, BillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillFindFirstArgs} args - Arguments to find a Bill
     * @example
     * // Get one Bill
     * const bill = await prisma.bill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillFindFirstArgs>(args?: SelectSubset<T, BillFindFirstArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillFindFirstOrThrowArgs} args - Arguments to find a Bill
     * @example
     * // Get one Bill
     * const bill = await prisma.bill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillFindFirstOrThrowArgs>(args?: SelectSubset<T, BillFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bills
     * const bills = await prisma.bill.findMany()
     * 
     * // Get first 10 Bills
     * const bills = await prisma.bill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billWithIdOnly = await prisma.bill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillFindManyArgs>(args?: SelectSubset<T, BillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bill.
     * @param {BillCreateArgs} args - Arguments to create a Bill.
     * @example
     * // Create one Bill
     * const Bill = await prisma.bill.create({
     *   data: {
     *     // ... data to create a Bill
     *   }
     * })
     * 
     */
    create<T extends BillCreateArgs>(args: SelectSubset<T, BillCreateArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bills.
     * @param {BillCreateManyArgs} args - Arguments to create many Bills.
     * @example
     * // Create many Bills
     * const bill = await prisma.bill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillCreateManyArgs>(args?: SelectSubset<T, BillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bills and returns the data saved in the database.
     * @param {BillCreateManyAndReturnArgs} args - Arguments to create many Bills.
     * @example
     * // Create many Bills
     * const bill = await prisma.bill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bills and only return the `id`
     * const billWithIdOnly = await prisma.bill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BillCreateManyAndReturnArgs>(args?: SelectSubset<T, BillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bill.
     * @param {BillDeleteArgs} args - Arguments to delete one Bill.
     * @example
     * // Delete one Bill
     * const Bill = await prisma.bill.delete({
     *   where: {
     *     // ... filter to delete one Bill
     *   }
     * })
     * 
     */
    delete<T extends BillDeleteArgs>(args: SelectSubset<T, BillDeleteArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bill.
     * @param {BillUpdateArgs} args - Arguments to update one Bill.
     * @example
     * // Update one Bill
     * const bill = await prisma.bill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillUpdateArgs>(args: SelectSubset<T, BillUpdateArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bills.
     * @param {BillDeleteManyArgs} args - Arguments to filter Bills to delete.
     * @example
     * // Delete a few Bills
     * const { count } = await prisma.bill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillDeleteManyArgs>(args?: SelectSubset<T, BillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bills
     * const bill = await prisma.bill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillUpdateManyArgs>(args: SelectSubset<T, BillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bills and returns the data updated in the database.
     * @param {BillUpdateManyAndReturnArgs} args - Arguments to update many Bills.
     * @example
     * // Update many Bills
     * const bill = await prisma.bill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bills and only return the `id`
     * const billWithIdOnly = await prisma.bill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BillUpdateManyAndReturnArgs>(args: SelectSubset<T, BillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bill.
     * @param {BillUpsertArgs} args - Arguments to update or create a Bill.
     * @example
     * // Update or create a Bill
     * const bill = await prisma.bill.upsert({
     *   create: {
     *     // ... data to create a Bill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bill we want to update
     *   }
     * })
     */
    upsert<T extends BillUpsertArgs>(args: SelectSubset<T, BillUpsertArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillCountArgs} args - Arguments to filter Bills to count.
     * @example
     * // Count the number of Bills
     * const count = await prisma.bill.count({
     *   where: {
     *     // ... the filter for the Bills we want to count
     *   }
     * })
    **/
    count<T extends BillCountArgs>(
      args?: Subset<T, BillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillAggregateArgs>(args: Subset<T, BillAggregateArgs>): Prisma.PrismaPromise<GetBillAggregateType<T>>

    /**
     * Group by Bill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillGroupByArgs['orderBy'] }
        : { orderBy?: BillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bill model
   */
  readonly fields: BillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends PaymentAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentAccountDefaultArgs<ExtArgs>>): Prisma__PaymentAccountClient<$Result.GetResult<Prisma.$PaymentAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignments<T extends Bill$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Bill$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    items<T extends Bill$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Bill$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymentRequests<T extends Bill$paymentRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Bill$paymentRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bill model
   */ 
  interface BillFieldRefs {
    readonly id: FieldRef<"Bill", 'String'>
    readonly name: FieldRef<"Bill", 'String'>
    readonly amount: FieldRef<"Bill", 'Float'>
    readonly createdAt: FieldRef<"Bill", 'DateTime'>
    readonly updatedAt: FieldRef<"Bill", 'DateTime'>
    readonly schoolId: FieldRef<"Bill", 'String'>
    readonly accountId: FieldRef<"Bill", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Bill findUnique
   */
  export type BillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter, which Bill to fetch.
     */
    where: BillWhereUniqueInput
  }

  /**
   * Bill findUniqueOrThrow
   */
  export type BillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter, which Bill to fetch.
     */
    where: BillWhereUniqueInput
  }

  /**
   * Bill findFirst
   */
  export type BillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter, which Bill to fetch.
     */
    where?: BillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bills.
     */
    cursor?: BillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bills.
     */
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * Bill findFirstOrThrow
   */
  export type BillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter, which Bill to fetch.
     */
    where?: BillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bills.
     */
    cursor?: BillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bills.
     */
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * Bill findMany
   */
  export type BillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter, which Bills to fetch.
     */
    where?: BillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bills.
     */
    cursor?: BillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * Bill create
   */
  export type BillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * The data needed to create a Bill.
     */
    data: XOR<BillCreateInput, BillUncheckedCreateInput>
  }

  /**
   * Bill createMany
   */
  export type BillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bills.
     */
    data: BillCreateManyInput | BillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bill createManyAndReturn
   */
  export type BillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * The data used to create many Bills.
     */
    data: BillCreateManyInput | BillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bill update
   */
  export type BillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * The data needed to update a Bill.
     */
    data: XOR<BillUpdateInput, BillUncheckedUpdateInput>
    /**
     * Choose, which Bill to update.
     */
    where: BillWhereUniqueInput
  }

  /**
   * Bill updateMany
   */
  export type BillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bills.
     */
    data: XOR<BillUpdateManyMutationInput, BillUncheckedUpdateManyInput>
    /**
     * Filter which Bills to update
     */
    where?: BillWhereInput
    /**
     * Limit how many Bills to update.
     */
    limit?: number
  }

  /**
   * Bill updateManyAndReturn
   */
  export type BillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * The data used to update Bills.
     */
    data: XOR<BillUpdateManyMutationInput, BillUncheckedUpdateManyInput>
    /**
     * Filter which Bills to update
     */
    where?: BillWhereInput
    /**
     * Limit how many Bills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bill upsert
   */
  export type BillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * The filter to search for the Bill to update in case it exists.
     */
    where: BillWhereUniqueInput
    /**
     * In case the Bill found by the `where` argument doesn't exist, create a new Bill with this data.
     */
    create: XOR<BillCreateInput, BillUncheckedCreateInput>
    /**
     * In case the Bill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillUpdateInput, BillUncheckedUpdateInput>
  }

  /**
   * Bill delete
   */
  export type BillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter which Bill to delete.
     */
    where: BillWhereUniqueInput
  }

  /**
   * Bill deleteMany
   */
  export type BillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bills to delete
     */
    where?: BillWhereInput
    /**
     * Limit how many Bills to delete.
     */
    limit?: number
  }

  /**
   * Bill.assignments
   */
  export type Bill$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillAssignment
     */
    select?: BillAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillAssignment
     */
    omit?: BillAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillAssignmentInclude<ExtArgs> | null
    where?: BillAssignmentWhereInput
    orderBy?: BillAssignmentOrderByWithRelationInput | BillAssignmentOrderByWithRelationInput[]
    cursor?: BillAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillAssignmentScalarFieldEnum | BillAssignmentScalarFieldEnum[]
  }

  /**
   * Bill.items
   */
  export type Bill$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillItem
     */
    select?: BillItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillItem
     */
    omit?: BillItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillItemInclude<ExtArgs> | null
    where?: BillItemWhereInput
    orderBy?: BillItemOrderByWithRelationInput | BillItemOrderByWithRelationInput[]
    cursor?: BillItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillItemScalarFieldEnum | BillItemScalarFieldEnum[]
  }

  /**
   * Bill.paymentRequests
   */
  export type Bill$paymentRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRequest
     */
    select?: PaymentRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRequest
     */
    omit?: PaymentRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRequestInclude<ExtArgs> | null
    where?: PaymentRequestWhereInput
    orderBy?: PaymentRequestOrderByWithRelationInput | PaymentRequestOrderByWithRelationInput[]
    cursor?: PaymentRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentRequestScalarFieldEnum | PaymentRequestScalarFieldEnum[]
  }

  /**
   * Bill without action
   */
  export type BillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
  }


  /**
   * Model BillItem
   */

  export type AggregateBillItem = {
    _count: BillItemCountAggregateOutputType | null
    _avg: BillItemAvgAggregateOutputType | null
    _sum: BillItemSumAggregateOutputType | null
    _min: BillItemMinAggregateOutputType | null
    _max: BillItemMaxAggregateOutputType | null
  }

  export type BillItemAvgAggregateOutputType = {
    amount: number | null
  }

  export type BillItemSumAggregateOutputType = {
    amount: number | null
  }

  export type BillItemMinAggregateOutputType = {
    id: string | null
    billId: string | null
    name: string | null
    amount: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillItemMaxAggregateOutputType = {
    id: string | null
    billId: string | null
    name: string | null
    amount: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillItemCountAggregateOutputType = {
    id: number
    billId: number
    name: number
    amount: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BillItemAvgAggregateInputType = {
    amount?: true
  }

  export type BillItemSumAggregateInputType = {
    amount?: true
  }

  export type BillItemMinAggregateInputType = {
    id?: true
    billId?: true
    name?: true
    amount?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillItemMaxAggregateInputType = {
    id?: true
    billId?: true
    name?: true
    amount?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillItemCountAggregateInputType = {
    id?: true
    billId?: true
    name?: true
    amount?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BillItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillItem to aggregate.
     */
    where?: BillItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillItems to fetch.
     */
    orderBy?: BillItemOrderByWithRelationInput | BillItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BillItems
    **/
    _count?: true | BillItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillItemMaxAggregateInputType
  }

  export type GetBillItemAggregateType<T extends BillItemAggregateArgs> = {
        [P in keyof T & keyof AggregateBillItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillItem[P]>
      : GetScalarType<T[P], AggregateBillItem[P]>
  }




  export type BillItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillItemWhereInput
    orderBy?: BillItemOrderByWithAggregationInput | BillItemOrderByWithAggregationInput[]
    by: BillItemScalarFieldEnum[] | BillItemScalarFieldEnum
    having?: BillItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillItemCountAggregateInputType | true
    _avg?: BillItemAvgAggregateInputType
    _sum?: BillItemSumAggregateInputType
    _min?: BillItemMinAggregateInputType
    _max?: BillItemMaxAggregateInputType
  }

  export type BillItemGroupByOutputType = {
    id: string
    billId: string
    name: string
    amount: number
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: BillItemCountAggregateOutputType | null
    _avg: BillItemAvgAggregateOutputType | null
    _sum: BillItemSumAggregateOutputType | null
    _min: BillItemMinAggregateOutputType | null
    _max: BillItemMaxAggregateOutputType | null
  }

  type GetBillItemGroupByPayload<T extends BillItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillItemGroupByOutputType[P]>
            : GetScalarType<T[P], BillItemGroupByOutputType[P]>
        }
      >
    >


  export type BillItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billId?: boolean
    name?: boolean
    amount?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bill?: boolean | BillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billItem"]>

  export type BillItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billId?: boolean
    name?: boolean
    amount?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bill?: boolean | BillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billItem"]>

  export type BillItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billId?: boolean
    name?: boolean
    amount?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bill?: boolean | BillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billItem"]>

  export type BillItemSelectScalar = {
    id?: boolean
    billId?: boolean
    name?: boolean
    amount?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BillItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "billId" | "name" | "amount" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["billItem"]>
  export type BillItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bill?: boolean | BillDefaultArgs<ExtArgs>
  }
  export type BillItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bill?: boolean | BillDefaultArgs<ExtArgs>
  }
  export type BillItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bill?: boolean | BillDefaultArgs<ExtArgs>
  }

  export type $BillItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BillItem"
    objects: {
      bill: Prisma.$BillPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      billId: string
      name: string
      amount: number
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["billItem"]>
    composites: {}
  }

  type BillItemGetPayload<S extends boolean | null | undefined | BillItemDefaultArgs> = $Result.GetResult<Prisma.$BillItemPayload, S>

  type BillItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BillItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BillItemCountAggregateInputType | true
    }

  export interface BillItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BillItem'], meta: { name: 'BillItem' } }
    /**
     * Find zero or one BillItem that matches the filter.
     * @param {BillItemFindUniqueArgs} args - Arguments to find a BillItem
     * @example
     * // Get one BillItem
     * const billItem = await prisma.billItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillItemFindUniqueArgs>(args: SelectSubset<T, BillItemFindUniqueArgs<ExtArgs>>): Prisma__BillItemClient<$Result.GetResult<Prisma.$BillItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BillItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BillItemFindUniqueOrThrowArgs} args - Arguments to find a BillItem
     * @example
     * // Get one BillItem
     * const billItem = await prisma.billItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillItemFindUniqueOrThrowArgs>(args: SelectSubset<T, BillItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillItemClient<$Result.GetResult<Prisma.$BillItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillItemFindFirstArgs} args - Arguments to find a BillItem
     * @example
     * // Get one BillItem
     * const billItem = await prisma.billItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillItemFindFirstArgs>(args?: SelectSubset<T, BillItemFindFirstArgs<ExtArgs>>): Prisma__BillItemClient<$Result.GetResult<Prisma.$BillItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillItemFindFirstOrThrowArgs} args - Arguments to find a BillItem
     * @example
     * // Get one BillItem
     * const billItem = await prisma.billItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillItemFindFirstOrThrowArgs>(args?: SelectSubset<T, BillItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillItemClient<$Result.GetResult<Prisma.$BillItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BillItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BillItems
     * const billItems = await prisma.billItem.findMany()
     * 
     * // Get first 10 BillItems
     * const billItems = await prisma.billItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billItemWithIdOnly = await prisma.billItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillItemFindManyArgs>(args?: SelectSubset<T, BillItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BillItem.
     * @param {BillItemCreateArgs} args - Arguments to create a BillItem.
     * @example
     * // Create one BillItem
     * const BillItem = await prisma.billItem.create({
     *   data: {
     *     // ... data to create a BillItem
     *   }
     * })
     * 
     */
    create<T extends BillItemCreateArgs>(args: SelectSubset<T, BillItemCreateArgs<ExtArgs>>): Prisma__BillItemClient<$Result.GetResult<Prisma.$BillItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BillItems.
     * @param {BillItemCreateManyArgs} args - Arguments to create many BillItems.
     * @example
     * // Create many BillItems
     * const billItem = await prisma.billItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillItemCreateManyArgs>(args?: SelectSubset<T, BillItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BillItems and returns the data saved in the database.
     * @param {BillItemCreateManyAndReturnArgs} args - Arguments to create many BillItems.
     * @example
     * // Create many BillItems
     * const billItem = await prisma.billItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BillItems and only return the `id`
     * const billItemWithIdOnly = await prisma.billItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BillItemCreateManyAndReturnArgs>(args?: SelectSubset<T, BillItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BillItem.
     * @param {BillItemDeleteArgs} args - Arguments to delete one BillItem.
     * @example
     * // Delete one BillItem
     * const BillItem = await prisma.billItem.delete({
     *   where: {
     *     // ... filter to delete one BillItem
     *   }
     * })
     * 
     */
    delete<T extends BillItemDeleteArgs>(args: SelectSubset<T, BillItemDeleteArgs<ExtArgs>>): Prisma__BillItemClient<$Result.GetResult<Prisma.$BillItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BillItem.
     * @param {BillItemUpdateArgs} args - Arguments to update one BillItem.
     * @example
     * // Update one BillItem
     * const billItem = await prisma.billItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillItemUpdateArgs>(args: SelectSubset<T, BillItemUpdateArgs<ExtArgs>>): Prisma__BillItemClient<$Result.GetResult<Prisma.$BillItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BillItems.
     * @param {BillItemDeleteManyArgs} args - Arguments to filter BillItems to delete.
     * @example
     * // Delete a few BillItems
     * const { count } = await prisma.billItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillItemDeleteManyArgs>(args?: SelectSubset<T, BillItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BillItems
     * const billItem = await prisma.billItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillItemUpdateManyArgs>(args: SelectSubset<T, BillItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillItems and returns the data updated in the database.
     * @param {BillItemUpdateManyAndReturnArgs} args - Arguments to update many BillItems.
     * @example
     * // Update many BillItems
     * const billItem = await prisma.billItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BillItems and only return the `id`
     * const billItemWithIdOnly = await prisma.billItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BillItemUpdateManyAndReturnArgs>(args: SelectSubset<T, BillItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BillItem.
     * @param {BillItemUpsertArgs} args - Arguments to update or create a BillItem.
     * @example
     * // Update or create a BillItem
     * const billItem = await prisma.billItem.upsert({
     *   create: {
     *     // ... data to create a BillItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BillItem we want to update
     *   }
     * })
     */
    upsert<T extends BillItemUpsertArgs>(args: SelectSubset<T, BillItemUpsertArgs<ExtArgs>>): Prisma__BillItemClient<$Result.GetResult<Prisma.$BillItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BillItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillItemCountArgs} args - Arguments to filter BillItems to count.
     * @example
     * // Count the number of BillItems
     * const count = await prisma.billItem.count({
     *   where: {
     *     // ... the filter for the BillItems we want to count
     *   }
     * })
    **/
    count<T extends BillItemCountArgs>(
      args?: Subset<T, BillItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BillItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillItemAggregateArgs>(args: Subset<T, BillItemAggregateArgs>): Prisma.PrismaPromise<GetBillItemAggregateType<T>>

    /**
     * Group by BillItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillItemGroupByArgs['orderBy'] }
        : { orderBy?: BillItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BillItem model
   */
  readonly fields: BillItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BillItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bill<T extends BillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BillDefaultArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BillItem model
   */ 
  interface BillItemFieldRefs {
    readonly id: FieldRef<"BillItem", 'String'>
    readonly billId: FieldRef<"BillItem", 'String'>
    readonly name: FieldRef<"BillItem", 'String'>
    readonly amount: FieldRef<"BillItem", 'Float'>
    readonly description: FieldRef<"BillItem", 'String'>
    readonly createdAt: FieldRef<"BillItem", 'DateTime'>
    readonly updatedAt: FieldRef<"BillItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BillItem findUnique
   */
  export type BillItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillItem
     */
    select?: BillItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillItem
     */
    omit?: BillItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillItemInclude<ExtArgs> | null
    /**
     * Filter, which BillItem to fetch.
     */
    where: BillItemWhereUniqueInput
  }

  /**
   * BillItem findUniqueOrThrow
   */
  export type BillItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillItem
     */
    select?: BillItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillItem
     */
    omit?: BillItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillItemInclude<ExtArgs> | null
    /**
     * Filter, which BillItem to fetch.
     */
    where: BillItemWhereUniqueInput
  }

  /**
   * BillItem findFirst
   */
  export type BillItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillItem
     */
    select?: BillItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillItem
     */
    omit?: BillItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillItemInclude<ExtArgs> | null
    /**
     * Filter, which BillItem to fetch.
     */
    where?: BillItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillItems to fetch.
     */
    orderBy?: BillItemOrderByWithRelationInput | BillItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillItems.
     */
    cursor?: BillItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillItems.
     */
    distinct?: BillItemScalarFieldEnum | BillItemScalarFieldEnum[]
  }

  /**
   * BillItem findFirstOrThrow
   */
  export type BillItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillItem
     */
    select?: BillItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillItem
     */
    omit?: BillItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillItemInclude<ExtArgs> | null
    /**
     * Filter, which BillItem to fetch.
     */
    where?: BillItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillItems to fetch.
     */
    orderBy?: BillItemOrderByWithRelationInput | BillItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillItems.
     */
    cursor?: BillItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillItems.
     */
    distinct?: BillItemScalarFieldEnum | BillItemScalarFieldEnum[]
  }

  /**
   * BillItem findMany
   */
  export type BillItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillItem
     */
    select?: BillItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillItem
     */
    omit?: BillItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillItemInclude<ExtArgs> | null
    /**
     * Filter, which BillItems to fetch.
     */
    where?: BillItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillItems to fetch.
     */
    orderBy?: BillItemOrderByWithRelationInput | BillItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BillItems.
     */
    cursor?: BillItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillItems.
     */
    skip?: number
    distinct?: BillItemScalarFieldEnum | BillItemScalarFieldEnum[]
  }

  /**
   * BillItem create
   */
  export type BillItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillItem
     */
    select?: BillItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillItem
     */
    omit?: BillItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillItemInclude<ExtArgs> | null
    /**
     * The data needed to create a BillItem.
     */
    data: XOR<BillItemCreateInput, BillItemUncheckedCreateInput>
  }

  /**
   * BillItem createMany
   */
  export type BillItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BillItems.
     */
    data: BillItemCreateManyInput | BillItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BillItem createManyAndReturn
   */
  export type BillItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillItem
     */
    select?: BillItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillItem
     */
    omit?: BillItemOmit<ExtArgs> | null
    /**
     * The data used to create many BillItems.
     */
    data: BillItemCreateManyInput | BillItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillItem update
   */
  export type BillItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillItem
     */
    select?: BillItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillItem
     */
    omit?: BillItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillItemInclude<ExtArgs> | null
    /**
     * The data needed to update a BillItem.
     */
    data: XOR<BillItemUpdateInput, BillItemUncheckedUpdateInput>
    /**
     * Choose, which BillItem to update.
     */
    where: BillItemWhereUniqueInput
  }

  /**
   * BillItem updateMany
   */
  export type BillItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BillItems.
     */
    data: XOR<BillItemUpdateManyMutationInput, BillItemUncheckedUpdateManyInput>
    /**
     * Filter which BillItems to update
     */
    where?: BillItemWhereInput
    /**
     * Limit how many BillItems to update.
     */
    limit?: number
  }

  /**
   * BillItem updateManyAndReturn
   */
  export type BillItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillItem
     */
    select?: BillItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillItem
     */
    omit?: BillItemOmit<ExtArgs> | null
    /**
     * The data used to update BillItems.
     */
    data: XOR<BillItemUpdateManyMutationInput, BillItemUncheckedUpdateManyInput>
    /**
     * Filter which BillItems to update
     */
    where?: BillItemWhereInput
    /**
     * Limit how many BillItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillItem upsert
   */
  export type BillItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillItem
     */
    select?: BillItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillItem
     */
    omit?: BillItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillItemInclude<ExtArgs> | null
    /**
     * The filter to search for the BillItem to update in case it exists.
     */
    where: BillItemWhereUniqueInput
    /**
     * In case the BillItem found by the `where` argument doesn't exist, create a new BillItem with this data.
     */
    create: XOR<BillItemCreateInput, BillItemUncheckedCreateInput>
    /**
     * In case the BillItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillItemUpdateInput, BillItemUncheckedUpdateInput>
  }

  /**
   * BillItem delete
   */
  export type BillItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillItem
     */
    select?: BillItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillItem
     */
    omit?: BillItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillItemInclude<ExtArgs> | null
    /**
     * Filter which BillItem to delete.
     */
    where: BillItemWhereUniqueInput
  }

  /**
   * BillItem deleteMany
   */
  export type BillItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillItems to delete
     */
    where?: BillItemWhereInput
    /**
     * Limit how many BillItems to delete.
     */
    limit?: number
  }

  /**
   * BillItem without action
   */
  export type BillItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillItem
     */
    select?: BillItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillItem
     */
    omit?: BillItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillItemInclude<ExtArgs> | null
  }


  /**
   * Model PaymentAccount
   */

  export type AggregatePaymentAccount = {
    _count: PaymentAccountCountAggregateOutputType | null
    _min: PaymentAccountMinAggregateOutputType | null
    _max: PaymentAccountMaxAggregateOutputType | null
  }

  export type PaymentAccountMinAggregateOutputType = {
    id: string | null
    name: string | null
    accountNo: string | null
    bankName: string | null
    branchCode: string | null
    description: string | null
    isActive: boolean | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentAccountMaxAggregateOutputType = {
    id: string | null
    name: string | null
    accountNo: string | null
    bankName: string | null
    branchCode: string | null
    description: string | null
    isActive: boolean | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentAccountCountAggregateOutputType = {
    id: number
    name: number
    accountNo: number
    bankName: number
    branchCode: number
    description: number
    isActive: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAccountMinAggregateInputType = {
    id?: true
    name?: true
    accountNo?: true
    bankName?: true
    branchCode?: true
    description?: true
    isActive?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentAccountMaxAggregateInputType = {
    id?: true
    name?: true
    accountNo?: true
    bankName?: true
    branchCode?: true
    description?: true
    isActive?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentAccountCountAggregateInputType = {
    id?: true
    name?: true
    accountNo?: true
    bankName?: true
    branchCode?: true
    description?: true
    isActive?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentAccount to aggregate.
     */
    where?: PaymentAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentAccounts to fetch.
     */
    orderBy?: PaymentAccountOrderByWithRelationInput | PaymentAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentAccounts
    **/
    _count?: true | PaymentAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentAccountMaxAggregateInputType
  }

  export type GetPaymentAccountAggregateType<T extends PaymentAccountAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentAccount[P]>
      : GetScalarType<T[P], AggregatePaymentAccount[P]>
  }




  export type PaymentAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentAccountWhereInput
    orderBy?: PaymentAccountOrderByWithAggregationInput | PaymentAccountOrderByWithAggregationInput[]
    by: PaymentAccountScalarFieldEnum[] | PaymentAccountScalarFieldEnum
    having?: PaymentAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentAccountCountAggregateInputType | true
    _min?: PaymentAccountMinAggregateInputType
    _max?: PaymentAccountMaxAggregateInputType
  }

  export type PaymentAccountGroupByOutputType = {
    id: string
    name: string
    accountNo: string
    bankName: string
    branchCode: string | null
    description: string | null
    isActive: boolean
    schoolId: string
    createdAt: Date
    updatedAt: Date
    _count: PaymentAccountCountAggregateOutputType | null
    _min: PaymentAccountMinAggregateOutputType | null
    _max: PaymentAccountMaxAggregateOutputType | null
  }

  type GetPaymentAccountGroupByPayload<T extends PaymentAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentAccountGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentAccountGroupByOutputType[P]>
        }
      >
    >


  export type PaymentAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    accountNo?: boolean
    bankName?: boolean
    branchCode?: boolean
    description?: boolean
    isActive?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bills?: boolean | PaymentAccount$billsArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    _count?: boolean | PaymentAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentAccount"]>

  export type PaymentAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    accountNo?: boolean
    bankName?: boolean
    branchCode?: boolean
    description?: boolean
    isActive?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentAccount"]>

  export type PaymentAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    accountNo?: boolean
    bankName?: boolean
    branchCode?: boolean
    description?: boolean
    isActive?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentAccount"]>

  export type PaymentAccountSelectScalar = {
    id?: boolean
    name?: boolean
    accountNo?: boolean
    bankName?: boolean
    branchCode?: boolean
    description?: boolean
    isActive?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "accountNo" | "bankName" | "branchCode" | "description" | "isActive" | "schoolId" | "createdAt" | "updatedAt", ExtArgs["result"]["paymentAccount"]>
  export type PaymentAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bills?: boolean | PaymentAccount$billsArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    _count?: boolean | PaymentAccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type PaymentAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $PaymentAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentAccount"
    objects: {
      bills: Prisma.$BillPayload<ExtArgs>[]
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      accountNo: string
      bankName: string
      branchCode: string | null
      description: string | null
      isActive: boolean
      schoolId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentAccount"]>
    composites: {}
  }

  type PaymentAccountGetPayload<S extends boolean | null | undefined | PaymentAccountDefaultArgs> = $Result.GetResult<Prisma.$PaymentAccountPayload, S>

  type PaymentAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentAccountCountAggregateInputType | true
    }

  export interface PaymentAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentAccount'], meta: { name: 'PaymentAccount' } }
    /**
     * Find zero or one PaymentAccount that matches the filter.
     * @param {PaymentAccountFindUniqueArgs} args - Arguments to find a PaymentAccount
     * @example
     * // Get one PaymentAccount
     * const paymentAccount = await prisma.paymentAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentAccountFindUniqueArgs>(args: SelectSubset<T, PaymentAccountFindUniqueArgs<ExtArgs>>): Prisma__PaymentAccountClient<$Result.GetResult<Prisma.$PaymentAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentAccountFindUniqueOrThrowArgs} args - Arguments to find a PaymentAccount
     * @example
     * // Get one PaymentAccount
     * const paymentAccount = await prisma.paymentAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentAccountClient<$Result.GetResult<Prisma.$PaymentAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAccountFindFirstArgs} args - Arguments to find a PaymentAccount
     * @example
     * // Get one PaymentAccount
     * const paymentAccount = await prisma.paymentAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentAccountFindFirstArgs>(args?: SelectSubset<T, PaymentAccountFindFirstArgs<ExtArgs>>): Prisma__PaymentAccountClient<$Result.GetResult<Prisma.$PaymentAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAccountFindFirstOrThrowArgs} args - Arguments to find a PaymentAccount
     * @example
     * // Get one PaymentAccount
     * const paymentAccount = await prisma.paymentAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentAccountClient<$Result.GetResult<Prisma.$PaymentAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentAccounts
     * const paymentAccounts = await prisma.paymentAccount.findMany()
     * 
     * // Get first 10 PaymentAccounts
     * const paymentAccounts = await prisma.paymentAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentAccountWithIdOnly = await prisma.paymentAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentAccountFindManyArgs>(args?: SelectSubset<T, PaymentAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentAccount.
     * @param {PaymentAccountCreateArgs} args - Arguments to create a PaymentAccount.
     * @example
     * // Create one PaymentAccount
     * const PaymentAccount = await prisma.paymentAccount.create({
     *   data: {
     *     // ... data to create a PaymentAccount
     *   }
     * })
     * 
     */
    create<T extends PaymentAccountCreateArgs>(args: SelectSubset<T, PaymentAccountCreateArgs<ExtArgs>>): Prisma__PaymentAccountClient<$Result.GetResult<Prisma.$PaymentAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentAccounts.
     * @param {PaymentAccountCreateManyArgs} args - Arguments to create many PaymentAccounts.
     * @example
     * // Create many PaymentAccounts
     * const paymentAccount = await prisma.paymentAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentAccountCreateManyArgs>(args?: SelectSubset<T, PaymentAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentAccounts and returns the data saved in the database.
     * @param {PaymentAccountCreateManyAndReturnArgs} args - Arguments to create many PaymentAccounts.
     * @example
     * // Create many PaymentAccounts
     * const paymentAccount = await prisma.paymentAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentAccounts and only return the `id`
     * const paymentAccountWithIdOnly = await prisma.paymentAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentAccount.
     * @param {PaymentAccountDeleteArgs} args - Arguments to delete one PaymentAccount.
     * @example
     * // Delete one PaymentAccount
     * const PaymentAccount = await prisma.paymentAccount.delete({
     *   where: {
     *     // ... filter to delete one PaymentAccount
     *   }
     * })
     * 
     */
    delete<T extends PaymentAccountDeleteArgs>(args: SelectSubset<T, PaymentAccountDeleteArgs<ExtArgs>>): Prisma__PaymentAccountClient<$Result.GetResult<Prisma.$PaymentAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentAccount.
     * @param {PaymentAccountUpdateArgs} args - Arguments to update one PaymentAccount.
     * @example
     * // Update one PaymentAccount
     * const paymentAccount = await prisma.paymentAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentAccountUpdateArgs>(args: SelectSubset<T, PaymentAccountUpdateArgs<ExtArgs>>): Prisma__PaymentAccountClient<$Result.GetResult<Prisma.$PaymentAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentAccounts.
     * @param {PaymentAccountDeleteManyArgs} args - Arguments to filter PaymentAccounts to delete.
     * @example
     * // Delete a few PaymentAccounts
     * const { count } = await prisma.paymentAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentAccountDeleteManyArgs>(args?: SelectSubset<T, PaymentAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentAccounts
     * const paymentAccount = await prisma.paymentAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentAccountUpdateManyArgs>(args: SelectSubset<T, PaymentAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentAccounts and returns the data updated in the database.
     * @param {PaymentAccountUpdateManyAndReturnArgs} args - Arguments to update many PaymentAccounts.
     * @example
     * // Update many PaymentAccounts
     * const paymentAccount = await prisma.paymentAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentAccounts and only return the `id`
     * const paymentAccountWithIdOnly = await prisma.paymentAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentAccount.
     * @param {PaymentAccountUpsertArgs} args - Arguments to update or create a PaymentAccount.
     * @example
     * // Update or create a PaymentAccount
     * const paymentAccount = await prisma.paymentAccount.upsert({
     *   create: {
     *     // ... data to create a PaymentAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentAccount we want to update
     *   }
     * })
     */
    upsert<T extends PaymentAccountUpsertArgs>(args: SelectSubset<T, PaymentAccountUpsertArgs<ExtArgs>>): Prisma__PaymentAccountClient<$Result.GetResult<Prisma.$PaymentAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAccountCountArgs} args - Arguments to filter PaymentAccounts to count.
     * @example
     * // Count the number of PaymentAccounts
     * const count = await prisma.paymentAccount.count({
     *   where: {
     *     // ... the filter for the PaymentAccounts we want to count
     *   }
     * })
    **/
    count<T extends PaymentAccountCountArgs>(
      args?: Subset<T, PaymentAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAccountAggregateArgs>(args: Subset<T, PaymentAccountAggregateArgs>): Prisma.PrismaPromise<GetPaymentAccountAggregateType<T>>

    /**
     * Group by PaymentAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentAccountGroupByArgs['orderBy'] }
        : { orderBy?: PaymentAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentAccount model
   */
  readonly fields: PaymentAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bills<T extends PaymentAccount$billsArgs<ExtArgs> = {}>(args?: Subset<T, PaymentAccount$billsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentAccount model
   */ 
  interface PaymentAccountFieldRefs {
    readonly id: FieldRef<"PaymentAccount", 'String'>
    readonly name: FieldRef<"PaymentAccount", 'String'>
    readonly accountNo: FieldRef<"PaymentAccount", 'String'>
    readonly bankName: FieldRef<"PaymentAccount", 'String'>
    readonly branchCode: FieldRef<"PaymentAccount", 'String'>
    readonly description: FieldRef<"PaymentAccount", 'String'>
    readonly isActive: FieldRef<"PaymentAccount", 'Boolean'>
    readonly schoolId: FieldRef<"PaymentAccount", 'String'>
    readonly createdAt: FieldRef<"PaymentAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentAccount findUnique
   */
  export type PaymentAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAccount
     */
    select?: PaymentAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAccount
     */
    omit?: PaymentAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAccountInclude<ExtArgs> | null
    /**
     * Filter, which PaymentAccount to fetch.
     */
    where: PaymentAccountWhereUniqueInput
  }

  /**
   * PaymentAccount findUniqueOrThrow
   */
  export type PaymentAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAccount
     */
    select?: PaymentAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAccount
     */
    omit?: PaymentAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAccountInclude<ExtArgs> | null
    /**
     * Filter, which PaymentAccount to fetch.
     */
    where: PaymentAccountWhereUniqueInput
  }

  /**
   * PaymentAccount findFirst
   */
  export type PaymentAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAccount
     */
    select?: PaymentAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAccount
     */
    omit?: PaymentAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAccountInclude<ExtArgs> | null
    /**
     * Filter, which PaymentAccount to fetch.
     */
    where?: PaymentAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentAccounts to fetch.
     */
    orderBy?: PaymentAccountOrderByWithRelationInput | PaymentAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentAccounts.
     */
    cursor?: PaymentAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentAccounts.
     */
    distinct?: PaymentAccountScalarFieldEnum | PaymentAccountScalarFieldEnum[]
  }

  /**
   * PaymentAccount findFirstOrThrow
   */
  export type PaymentAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAccount
     */
    select?: PaymentAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAccount
     */
    omit?: PaymentAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAccountInclude<ExtArgs> | null
    /**
     * Filter, which PaymentAccount to fetch.
     */
    where?: PaymentAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentAccounts to fetch.
     */
    orderBy?: PaymentAccountOrderByWithRelationInput | PaymentAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentAccounts.
     */
    cursor?: PaymentAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentAccounts.
     */
    distinct?: PaymentAccountScalarFieldEnum | PaymentAccountScalarFieldEnum[]
  }

  /**
   * PaymentAccount findMany
   */
  export type PaymentAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAccount
     */
    select?: PaymentAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAccount
     */
    omit?: PaymentAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAccountInclude<ExtArgs> | null
    /**
     * Filter, which PaymentAccounts to fetch.
     */
    where?: PaymentAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentAccounts to fetch.
     */
    orderBy?: PaymentAccountOrderByWithRelationInput | PaymentAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentAccounts.
     */
    cursor?: PaymentAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentAccounts.
     */
    skip?: number
    distinct?: PaymentAccountScalarFieldEnum | PaymentAccountScalarFieldEnum[]
  }

  /**
   * PaymentAccount create
   */
  export type PaymentAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAccount
     */
    select?: PaymentAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAccount
     */
    omit?: PaymentAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentAccount.
     */
    data: XOR<PaymentAccountCreateInput, PaymentAccountUncheckedCreateInput>
  }

  /**
   * PaymentAccount createMany
   */
  export type PaymentAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentAccounts.
     */
    data: PaymentAccountCreateManyInput | PaymentAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentAccount createManyAndReturn
   */
  export type PaymentAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAccount
     */
    select?: PaymentAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAccount
     */
    omit?: PaymentAccountOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentAccounts.
     */
    data: PaymentAccountCreateManyInput | PaymentAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentAccount update
   */
  export type PaymentAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAccount
     */
    select?: PaymentAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAccount
     */
    omit?: PaymentAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentAccount.
     */
    data: XOR<PaymentAccountUpdateInput, PaymentAccountUncheckedUpdateInput>
    /**
     * Choose, which PaymentAccount to update.
     */
    where: PaymentAccountWhereUniqueInput
  }

  /**
   * PaymentAccount updateMany
   */
  export type PaymentAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentAccounts.
     */
    data: XOR<PaymentAccountUpdateManyMutationInput, PaymentAccountUncheckedUpdateManyInput>
    /**
     * Filter which PaymentAccounts to update
     */
    where?: PaymentAccountWhereInput
    /**
     * Limit how many PaymentAccounts to update.
     */
    limit?: number
  }

  /**
   * PaymentAccount updateManyAndReturn
   */
  export type PaymentAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAccount
     */
    select?: PaymentAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAccount
     */
    omit?: PaymentAccountOmit<ExtArgs> | null
    /**
     * The data used to update PaymentAccounts.
     */
    data: XOR<PaymentAccountUpdateManyMutationInput, PaymentAccountUncheckedUpdateManyInput>
    /**
     * Filter which PaymentAccounts to update
     */
    where?: PaymentAccountWhereInput
    /**
     * Limit how many PaymentAccounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentAccount upsert
   */
  export type PaymentAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAccount
     */
    select?: PaymentAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAccount
     */
    omit?: PaymentAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentAccount to update in case it exists.
     */
    where: PaymentAccountWhereUniqueInput
    /**
     * In case the PaymentAccount found by the `where` argument doesn't exist, create a new PaymentAccount with this data.
     */
    create: XOR<PaymentAccountCreateInput, PaymentAccountUncheckedCreateInput>
    /**
     * In case the PaymentAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentAccountUpdateInput, PaymentAccountUncheckedUpdateInput>
  }

  /**
   * PaymentAccount delete
   */
  export type PaymentAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAccount
     */
    select?: PaymentAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAccount
     */
    omit?: PaymentAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAccountInclude<ExtArgs> | null
    /**
     * Filter which PaymentAccount to delete.
     */
    where: PaymentAccountWhereUniqueInput
  }

  /**
   * PaymentAccount deleteMany
   */
  export type PaymentAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentAccounts to delete
     */
    where?: PaymentAccountWhereInput
    /**
     * Limit how many PaymentAccounts to delete.
     */
    limit?: number
  }

  /**
   * PaymentAccount.bills
   */
  export type PaymentAccount$billsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    where?: BillWhereInput
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    cursor?: BillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * PaymentAccount without action
   */
  export type PaymentAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAccount
     */
    select?: PaymentAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAccount
     */
    omit?: PaymentAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAccountInclude<ExtArgs> | null
  }


  /**
   * Model BillAssignment
   */

  export type AggregateBillAssignment = {
    _count: BillAssignmentCountAggregateOutputType | null
    _min: BillAssignmentMinAggregateOutputType | null
    _max: BillAssignmentMaxAggregateOutputType | null
  }

  export type BillAssignmentMinAggregateOutputType = {
    id: string | null
    billId: string | null
    targetType: $Enums.BillAssignmentType | null
    targetId: string | null
    dueDate: Date | null
    status: $Enums.BillStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillAssignmentMaxAggregateOutputType = {
    id: string | null
    billId: string | null
    targetType: $Enums.BillAssignmentType | null
    targetId: string | null
    dueDate: Date | null
    status: $Enums.BillStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillAssignmentCountAggregateOutputType = {
    id: number
    billId: number
    targetType: number
    targetId: number
    dueDate: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BillAssignmentMinAggregateInputType = {
    id?: true
    billId?: true
    targetType?: true
    targetId?: true
    dueDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillAssignmentMaxAggregateInputType = {
    id?: true
    billId?: true
    targetType?: true
    targetId?: true
    dueDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillAssignmentCountAggregateInputType = {
    id?: true
    billId?: true
    targetType?: true
    targetId?: true
    dueDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BillAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillAssignment to aggregate.
     */
    where?: BillAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillAssignments to fetch.
     */
    orderBy?: BillAssignmentOrderByWithRelationInput | BillAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BillAssignments
    **/
    _count?: true | BillAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillAssignmentMaxAggregateInputType
  }

  export type GetBillAssignmentAggregateType<T extends BillAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateBillAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillAssignment[P]>
      : GetScalarType<T[P], AggregateBillAssignment[P]>
  }




  export type BillAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillAssignmentWhereInput
    orderBy?: BillAssignmentOrderByWithAggregationInput | BillAssignmentOrderByWithAggregationInput[]
    by: BillAssignmentScalarFieldEnum[] | BillAssignmentScalarFieldEnum
    having?: BillAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillAssignmentCountAggregateInputType | true
    _min?: BillAssignmentMinAggregateInputType
    _max?: BillAssignmentMaxAggregateInputType
  }

  export type BillAssignmentGroupByOutputType = {
    id: string
    billId: string
    targetType: $Enums.BillAssignmentType
    targetId: string
    dueDate: Date
    status: $Enums.BillStatus
    createdAt: Date
    updatedAt: Date
    _count: BillAssignmentCountAggregateOutputType | null
    _min: BillAssignmentMinAggregateOutputType | null
    _max: BillAssignmentMaxAggregateOutputType | null
  }

  type GetBillAssignmentGroupByPayload<T extends BillAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], BillAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type BillAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billId?: boolean
    targetType?: boolean
    targetId?: boolean
    dueDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bill?: boolean | BillDefaultArgs<ExtArgs>
    paymentRequests?: boolean | BillAssignment$paymentRequestsArgs<ExtArgs>
    studentPayments?: boolean | BillAssignment$studentPaymentsArgs<ExtArgs>
    _count?: boolean | BillAssignmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billAssignment"]>

  export type BillAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billId?: boolean
    targetType?: boolean
    targetId?: boolean
    dueDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bill?: boolean | BillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billAssignment"]>

  export type BillAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billId?: boolean
    targetType?: boolean
    targetId?: boolean
    dueDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bill?: boolean | BillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billAssignment"]>

  export type BillAssignmentSelectScalar = {
    id?: boolean
    billId?: boolean
    targetType?: boolean
    targetId?: boolean
    dueDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BillAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "billId" | "targetType" | "targetId" | "dueDate" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["billAssignment"]>
  export type BillAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bill?: boolean | BillDefaultArgs<ExtArgs>
    paymentRequests?: boolean | BillAssignment$paymentRequestsArgs<ExtArgs>
    studentPayments?: boolean | BillAssignment$studentPaymentsArgs<ExtArgs>
    _count?: boolean | BillAssignmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BillAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bill?: boolean | BillDefaultArgs<ExtArgs>
  }
  export type BillAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bill?: boolean | BillDefaultArgs<ExtArgs>
  }

  export type $BillAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BillAssignment"
    objects: {
      bill: Prisma.$BillPayload<ExtArgs>
      paymentRequests: Prisma.$PaymentRequestPayload<ExtArgs>[]
      studentPayments: Prisma.$StudentPaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      billId: string
      targetType: $Enums.BillAssignmentType
      targetId: string
      dueDate: Date
      status: $Enums.BillStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["billAssignment"]>
    composites: {}
  }

  type BillAssignmentGetPayload<S extends boolean | null | undefined | BillAssignmentDefaultArgs> = $Result.GetResult<Prisma.$BillAssignmentPayload, S>

  type BillAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BillAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BillAssignmentCountAggregateInputType | true
    }

  export interface BillAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BillAssignment'], meta: { name: 'BillAssignment' } }
    /**
     * Find zero or one BillAssignment that matches the filter.
     * @param {BillAssignmentFindUniqueArgs} args - Arguments to find a BillAssignment
     * @example
     * // Get one BillAssignment
     * const billAssignment = await prisma.billAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillAssignmentFindUniqueArgs>(args: SelectSubset<T, BillAssignmentFindUniqueArgs<ExtArgs>>): Prisma__BillAssignmentClient<$Result.GetResult<Prisma.$BillAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BillAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BillAssignmentFindUniqueOrThrowArgs} args - Arguments to find a BillAssignment
     * @example
     * // Get one BillAssignment
     * const billAssignment = await prisma.billAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, BillAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillAssignmentClient<$Result.GetResult<Prisma.$BillAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillAssignmentFindFirstArgs} args - Arguments to find a BillAssignment
     * @example
     * // Get one BillAssignment
     * const billAssignment = await prisma.billAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillAssignmentFindFirstArgs>(args?: SelectSubset<T, BillAssignmentFindFirstArgs<ExtArgs>>): Prisma__BillAssignmentClient<$Result.GetResult<Prisma.$BillAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillAssignmentFindFirstOrThrowArgs} args - Arguments to find a BillAssignment
     * @example
     * // Get one BillAssignment
     * const billAssignment = await prisma.billAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, BillAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillAssignmentClient<$Result.GetResult<Prisma.$BillAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BillAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BillAssignments
     * const billAssignments = await prisma.billAssignment.findMany()
     * 
     * // Get first 10 BillAssignments
     * const billAssignments = await prisma.billAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billAssignmentWithIdOnly = await prisma.billAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillAssignmentFindManyArgs>(args?: SelectSubset<T, BillAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BillAssignment.
     * @param {BillAssignmentCreateArgs} args - Arguments to create a BillAssignment.
     * @example
     * // Create one BillAssignment
     * const BillAssignment = await prisma.billAssignment.create({
     *   data: {
     *     // ... data to create a BillAssignment
     *   }
     * })
     * 
     */
    create<T extends BillAssignmentCreateArgs>(args: SelectSubset<T, BillAssignmentCreateArgs<ExtArgs>>): Prisma__BillAssignmentClient<$Result.GetResult<Prisma.$BillAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BillAssignments.
     * @param {BillAssignmentCreateManyArgs} args - Arguments to create many BillAssignments.
     * @example
     * // Create many BillAssignments
     * const billAssignment = await prisma.billAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillAssignmentCreateManyArgs>(args?: SelectSubset<T, BillAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BillAssignments and returns the data saved in the database.
     * @param {BillAssignmentCreateManyAndReturnArgs} args - Arguments to create many BillAssignments.
     * @example
     * // Create many BillAssignments
     * const billAssignment = await prisma.billAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BillAssignments and only return the `id`
     * const billAssignmentWithIdOnly = await prisma.billAssignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BillAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, BillAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillAssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BillAssignment.
     * @param {BillAssignmentDeleteArgs} args - Arguments to delete one BillAssignment.
     * @example
     * // Delete one BillAssignment
     * const BillAssignment = await prisma.billAssignment.delete({
     *   where: {
     *     // ... filter to delete one BillAssignment
     *   }
     * })
     * 
     */
    delete<T extends BillAssignmentDeleteArgs>(args: SelectSubset<T, BillAssignmentDeleteArgs<ExtArgs>>): Prisma__BillAssignmentClient<$Result.GetResult<Prisma.$BillAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BillAssignment.
     * @param {BillAssignmentUpdateArgs} args - Arguments to update one BillAssignment.
     * @example
     * // Update one BillAssignment
     * const billAssignment = await prisma.billAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillAssignmentUpdateArgs>(args: SelectSubset<T, BillAssignmentUpdateArgs<ExtArgs>>): Prisma__BillAssignmentClient<$Result.GetResult<Prisma.$BillAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BillAssignments.
     * @param {BillAssignmentDeleteManyArgs} args - Arguments to filter BillAssignments to delete.
     * @example
     * // Delete a few BillAssignments
     * const { count } = await prisma.billAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillAssignmentDeleteManyArgs>(args?: SelectSubset<T, BillAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BillAssignments
     * const billAssignment = await prisma.billAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillAssignmentUpdateManyArgs>(args: SelectSubset<T, BillAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillAssignments and returns the data updated in the database.
     * @param {BillAssignmentUpdateManyAndReturnArgs} args - Arguments to update many BillAssignments.
     * @example
     * // Update many BillAssignments
     * const billAssignment = await prisma.billAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BillAssignments and only return the `id`
     * const billAssignmentWithIdOnly = await prisma.billAssignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BillAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, BillAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BillAssignment.
     * @param {BillAssignmentUpsertArgs} args - Arguments to update or create a BillAssignment.
     * @example
     * // Update or create a BillAssignment
     * const billAssignment = await prisma.billAssignment.upsert({
     *   create: {
     *     // ... data to create a BillAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BillAssignment we want to update
     *   }
     * })
     */
    upsert<T extends BillAssignmentUpsertArgs>(args: SelectSubset<T, BillAssignmentUpsertArgs<ExtArgs>>): Prisma__BillAssignmentClient<$Result.GetResult<Prisma.$BillAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BillAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillAssignmentCountArgs} args - Arguments to filter BillAssignments to count.
     * @example
     * // Count the number of BillAssignments
     * const count = await prisma.billAssignment.count({
     *   where: {
     *     // ... the filter for the BillAssignments we want to count
     *   }
     * })
    **/
    count<T extends BillAssignmentCountArgs>(
      args?: Subset<T, BillAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BillAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillAssignmentAggregateArgs>(args: Subset<T, BillAssignmentAggregateArgs>): Prisma.PrismaPromise<GetBillAssignmentAggregateType<T>>

    /**
     * Group by BillAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: BillAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BillAssignment model
   */
  readonly fields: BillAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BillAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bill<T extends BillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BillDefaultArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    paymentRequests<T extends BillAssignment$paymentRequestsArgs<ExtArgs> = {}>(args?: Subset<T, BillAssignment$paymentRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentPayments<T extends BillAssignment$studentPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, BillAssignment$studentPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BillAssignment model
   */ 
  interface BillAssignmentFieldRefs {
    readonly id: FieldRef<"BillAssignment", 'String'>
    readonly billId: FieldRef<"BillAssignment", 'String'>
    readonly targetType: FieldRef<"BillAssignment", 'BillAssignmentType'>
    readonly targetId: FieldRef<"BillAssignment", 'String'>
    readonly dueDate: FieldRef<"BillAssignment", 'DateTime'>
    readonly status: FieldRef<"BillAssignment", 'BillStatus'>
    readonly createdAt: FieldRef<"BillAssignment", 'DateTime'>
    readonly updatedAt: FieldRef<"BillAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BillAssignment findUnique
   */
  export type BillAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillAssignment
     */
    select?: BillAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillAssignment
     */
    omit?: BillAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which BillAssignment to fetch.
     */
    where: BillAssignmentWhereUniqueInput
  }

  /**
   * BillAssignment findUniqueOrThrow
   */
  export type BillAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillAssignment
     */
    select?: BillAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillAssignment
     */
    omit?: BillAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which BillAssignment to fetch.
     */
    where: BillAssignmentWhereUniqueInput
  }

  /**
   * BillAssignment findFirst
   */
  export type BillAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillAssignment
     */
    select?: BillAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillAssignment
     */
    omit?: BillAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which BillAssignment to fetch.
     */
    where?: BillAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillAssignments to fetch.
     */
    orderBy?: BillAssignmentOrderByWithRelationInput | BillAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillAssignments.
     */
    cursor?: BillAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillAssignments.
     */
    distinct?: BillAssignmentScalarFieldEnum | BillAssignmentScalarFieldEnum[]
  }

  /**
   * BillAssignment findFirstOrThrow
   */
  export type BillAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillAssignment
     */
    select?: BillAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillAssignment
     */
    omit?: BillAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which BillAssignment to fetch.
     */
    where?: BillAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillAssignments to fetch.
     */
    orderBy?: BillAssignmentOrderByWithRelationInput | BillAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillAssignments.
     */
    cursor?: BillAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillAssignments.
     */
    distinct?: BillAssignmentScalarFieldEnum | BillAssignmentScalarFieldEnum[]
  }

  /**
   * BillAssignment findMany
   */
  export type BillAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillAssignment
     */
    select?: BillAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillAssignment
     */
    omit?: BillAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which BillAssignments to fetch.
     */
    where?: BillAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillAssignments to fetch.
     */
    orderBy?: BillAssignmentOrderByWithRelationInput | BillAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BillAssignments.
     */
    cursor?: BillAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillAssignments.
     */
    skip?: number
    distinct?: BillAssignmentScalarFieldEnum | BillAssignmentScalarFieldEnum[]
  }

  /**
   * BillAssignment create
   */
  export type BillAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillAssignment
     */
    select?: BillAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillAssignment
     */
    omit?: BillAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a BillAssignment.
     */
    data: XOR<BillAssignmentCreateInput, BillAssignmentUncheckedCreateInput>
  }

  /**
   * BillAssignment createMany
   */
  export type BillAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BillAssignments.
     */
    data: BillAssignmentCreateManyInput | BillAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BillAssignment createManyAndReturn
   */
  export type BillAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillAssignment
     */
    select?: BillAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillAssignment
     */
    omit?: BillAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many BillAssignments.
     */
    data: BillAssignmentCreateManyInput | BillAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillAssignment update
   */
  export type BillAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillAssignment
     */
    select?: BillAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillAssignment
     */
    omit?: BillAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a BillAssignment.
     */
    data: XOR<BillAssignmentUpdateInput, BillAssignmentUncheckedUpdateInput>
    /**
     * Choose, which BillAssignment to update.
     */
    where: BillAssignmentWhereUniqueInput
  }

  /**
   * BillAssignment updateMany
   */
  export type BillAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BillAssignments.
     */
    data: XOR<BillAssignmentUpdateManyMutationInput, BillAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which BillAssignments to update
     */
    where?: BillAssignmentWhereInput
    /**
     * Limit how many BillAssignments to update.
     */
    limit?: number
  }

  /**
   * BillAssignment updateManyAndReturn
   */
  export type BillAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillAssignment
     */
    select?: BillAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillAssignment
     */
    omit?: BillAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update BillAssignments.
     */
    data: XOR<BillAssignmentUpdateManyMutationInput, BillAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which BillAssignments to update
     */
    where?: BillAssignmentWhereInput
    /**
     * Limit how many BillAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillAssignment upsert
   */
  export type BillAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillAssignment
     */
    select?: BillAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillAssignment
     */
    omit?: BillAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the BillAssignment to update in case it exists.
     */
    where: BillAssignmentWhereUniqueInput
    /**
     * In case the BillAssignment found by the `where` argument doesn't exist, create a new BillAssignment with this data.
     */
    create: XOR<BillAssignmentCreateInput, BillAssignmentUncheckedCreateInput>
    /**
     * In case the BillAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillAssignmentUpdateInput, BillAssignmentUncheckedUpdateInput>
  }

  /**
   * BillAssignment delete
   */
  export type BillAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillAssignment
     */
    select?: BillAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillAssignment
     */
    omit?: BillAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillAssignmentInclude<ExtArgs> | null
    /**
     * Filter which BillAssignment to delete.
     */
    where: BillAssignmentWhereUniqueInput
  }

  /**
   * BillAssignment deleteMany
   */
  export type BillAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillAssignments to delete
     */
    where?: BillAssignmentWhereInput
    /**
     * Limit how many BillAssignments to delete.
     */
    limit?: number
  }

  /**
   * BillAssignment.paymentRequests
   */
  export type BillAssignment$paymentRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRequest
     */
    select?: PaymentRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRequest
     */
    omit?: PaymentRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRequestInclude<ExtArgs> | null
    where?: PaymentRequestWhereInput
    orderBy?: PaymentRequestOrderByWithRelationInput | PaymentRequestOrderByWithRelationInput[]
    cursor?: PaymentRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentRequestScalarFieldEnum | PaymentRequestScalarFieldEnum[]
  }

  /**
   * BillAssignment.studentPayments
   */
  export type BillAssignment$studentPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentPayment
     */
    select?: StudentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentPayment
     */
    omit?: StudentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentPaymentInclude<ExtArgs> | null
    where?: StudentPaymentWhereInput
    orderBy?: StudentPaymentOrderByWithRelationInput | StudentPaymentOrderByWithRelationInput[]
    cursor?: StudentPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentPaymentScalarFieldEnum | StudentPaymentScalarFieldEnum[]
  }

  /**
   * BillAssignment without action
   */
  export type BillAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillAssignment
     */
    select?: BillAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillAssignment
     */
    omit?: BillAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model StudentPayment
   */

  export type AggregateStudentPayment = {
    _count: StudentPaymentCountAggregateOutputType | null
    _avg: StudentPaymentAvgAggregateOutputType | null
    _sum: StudentPaymentSumAggregateOutputType | null
    _min: StudentPaymentMinAggregateOutputType | null
    _max: StudentPaymentMaxAggregateOutputType | null
  }

  export type StudentPaymentAvgAggregateOutputType = {
    amountPaid: number | null
  }

  export type StudentPaymentSumAggregateOutputType = {
    amountPaid: number | null
  }

  export type StudentPaymentMinAggregateOutputType = {
    id: string | null
    billAssignmentId: string | null
    studentId: string | null
    amountPaid: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentPaymentMaxAggregateOutputType = {
    id: string | null
    billAssignmentId: string | null
    studentId: string | null
    amountPaid: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentPaymentCountAggregateOutputType = {
    id: number
    billAssignmentId: number
    studentId: number
    amountPaid: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentPaymentAvgAggregateInputType = {
    amountPaid?: true
  }

  export type StudentPaymentSumAggregateInputType = {
    amountPaid?: true
  }

  export type StudentPaymentMinAggregateInputType = {
    id?: true
    billAssignmentId?: true
    studentId?: true
    amountPaid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentPaymentMaxAggregateInputType = {
    id?: true
    billAssignmentId?: true
    studentId?: true
    amountPaid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentPaymentCountAggregateInputType = {
    id?: true
    billAssignmentId?: true
    studentId?: true
    amountPaid?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentPayment to aggregate.
     */
    where?: StudentPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentPayments to fetch.
     */
    orderBy?: StudentPaymentOrderByWithRelationInput | StudentPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentPayments
    **/
    _count?: true | StudentPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentPaymentMaxAggregateInputType
  }

  export type GetStudentPaymentAggregateType<T extends StudentPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentPayment[P]>
      : GetScalarType<T[P], AggregateStudentPayment[P]>
  }




  export type StudentPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentPaymentWhereInput
    orderBy?: StudentPaymentOrderByWithAggregationInput | StudentPaymentOrderByWithAggregationInput[]
    by: StudentPaymentScalarFieldEnum[] | StudentPaymentScalarFieldEnum
    having?: StudentPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentPaymentCountAggregateInputType | true
    _avg?: StudentPaymentAvgAggregateInputType
    _sum?: StudentPaymentSumAggregateInputType
    _min?: StudentPaymentMinAggregateInputType
    _max?: StudentPaymentMaxAggregateInputType
  }

  export type StudentPaymentGroupByOutputType = {
    id: string
    billAssignmentId: string
    studentId: string
    amountPaid: number
    createdAt: Date
    updatedAt: Date
    _count: StudentPaymentCountAggregateOutputType | null
    _avg: StudentPaymentAvgAggregateOutputType | null
    _sum: StudentPaymentSumAggregateOutputType | null
    _min: StudentPaymentMinAggregateOutputType | null
    _max: StudentPaymentMaxAggregateOutputType | null
  }

  type GetStudentPaymentGroupByPayload<T extends StudentPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentPaymentGroupByOutputType[P]>
        }
      >
    >


  export type StudentPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billAssignmentId?: boolean
    studentId?: boolean
    amountPaid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paymentRequests?: boolean | StudentPayment$paymentRequestsArgs<ExtArgs>
    billAssignment?: boolean | BillAssignmentDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    _count?: boolean | StudentPaymentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentPayment"]>

  export type StudentPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billAssignmentId?: boolean
    studentId?: boolean
    amountPaid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    billAssignment?: boolean | BillAssignmentDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentPayment"]>

  export type StudentPaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billAssignmentId?: boolean
    studentId?: boolean
    amountPaid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    billAssignment?: boolean | BillAssignmentDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentPayment"]>

  export type StudentPaymentSelectScalar = {
    id?: boolean
    billAssignmentId?: boolean
    studentId?: boolean
    amountPaid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentPaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "billAssignmentId" | "studentId" | "amountPaid" | "createdAt" | "updatedAt", ExtArgs["result"]["studentPayment"]>
  export type StudentPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paymentRequests?: boolean | StudentPayment$paymentRequestsArgs<ExtArgs>
    billAssignment?: boolean | BillAssignmentDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    _count?: boolean | StudentPaymentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudentPaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    billAssignment?: boolean | BillAssignmentDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type StudentPaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    billAssignment?: boolean | BillAssignmentDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $StudentPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentPayment"
    objects: {
      paymentRequests: Prisma.$PaymentRequestPayload<ExtArgs>[]
      billAssignment: Prisma.$BillAssignmentPayload<ExtArgs>
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      billAssignmentId: string
      studentId: string
      amountPaid: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studentPayment"]>
    composites: {}
  }

  type StudentPaymentGetPayload<S extends boolean | null | undefined | StudentPaymentDefaultArgs> = $Result.GetResult<Prisma.$StudentPaymentPayload, S>

  type StudentPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentPaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentPaymentCountAggregateInputType | true
    }

  export interface StudentPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentPayment'], meta: { name: 'StudentPayment' } }
    /**
     * Find zero or one StudentPayment that matches the filter.
     * @param {StudentPaymentFindUniqueArgs} args - Arguments to find a StudentPayment
     * @example
     * // Get one StudentPayment
     * const studentPayment = await prisma.studentPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentPaymentFindUniqueArgs>(args: SelectSubset<T, StudentPaymentFindUniqueArgs<ExtArgs>>): Prisma__StudentPaymentClient<$Result.GetResult<Prisma.$StudentPaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentPayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentPaymentFindUniqueOrThrowArgs} args - Arguments to find a StudentPayment
     * @example
     * // Get one StudentPayment
     * const studentPayment = await prisma.studentPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentPaymentClient<$Result.GetResult<Prisma.$StudentPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentPaymentFindFirstArgs} args - Arguments to find a StudentPayment
     * @example
     * // Get one StudentPayment
     * const studentPayment = await prisma.studentPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentPaymentFindFirstArgs>(args?: SelectSubset<T, StudentPaymentFindFirstArgs<ExtArgs>>): Prisma__StudentPaymentClient<$Result.GetResult<Prisma.$StudentPaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentPaymentFindFirstOrThrowArgs} args - Arguments to find a StudentPayment
     * @example
     * // Get one StudentPayment
     * const studentPayment = await prisma.studentPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentPaymentClient<$Result.GetResult<Prisma.$StudentPaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentPayments
     * const studentPayments = await prisma.studentPayment.findMany()
     * 
     * // Get first 10 StudentPayments
     * const studentPayments = await prisma.studentPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentPaymentWithIdOnly = await prisma.studentPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentPaymentFindManyArgs>(args?: SelectSubset<T, StudentPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentPayment.
     * @param {StudentPaymentCreateArgs} args - Arguments to create a StudentPayment.
     * @example
     * // Create one StudentPayment
     * const StudentPayment = await prisma.studentPayment.create({
     *   data: {
     *     // ... data to create a StudentPayment
     *   }
     * })
     * 
     */
    create<T extends StudentPaymentCreateArgs>(args: SelectSubset<T, StudentPaymentCreateArgs<ExtArgs>>): Prisma__StudentPaymentClient<$Result.GetResult<Prisma.$StudentPaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentPayments.
     * @param {StudentPaymentCreateManyArgs} args - Arguments to create many StudentPayments.
     * @example
     * // Create many StudentPayments
     * const studentPayment = await prisma.studentPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentPaymentCreateManyArgs>(args?: SelectSubset<T, StudentPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentPayments and returns the data saved in the database.
     * @param {StudentPaymentCreateManyAndReturnArgs} args - Arguments to create many StudentPayments.
     * @example
     * // Create many StudentPayments
     * const studentPayment = await prisma.studentPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentPayments and only return the `id`
     * const studentPaymentWithIdOnly = await prisma.studentPayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudentPayment.
     * @param {StudentPaymentDeleteArgs} args - Arguments to delete one StudentPayment.
     * @example
     * // Delete one StudentPayment
     * const StudentPayment = await prisma.studentPayment.delete({
     *   where: {
     *     // ... filter to delete one StudentPayment
     *   }
     * })
     * 
     */
    delete<T extends StudentPaymentDeleteArgs>(args: SelectSubset<T, StudentPaymentDeleteArgs<ExtArgs>>): Prisma__StudentPaymentClient<$Result.GetResult<Prisma.$StudentPaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentPayment.
     * @param {StudentPaymentUpdateArgs} args - Arguments to update one StudentPayment.
     * @example
     * // Update one StudentPayment
     * const studentPayment = await prisma.studentPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentPaymentUpdateArgs>(args: SelectSubset<T, StudentPaymentUpdateArgs<ExtArgs>>): Prisma__StudentPaymentClient<$Result.GetResult<Prisma.$StudentPaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentPayments.
     * @param {StudentPaymentDeleteManyArgs} args - Arguments to filter StudentPayments to delete.
     * @example
     * // Delete a few StudentPayments
     * const { count } = await prisma.studentPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentPaymentDeleteManyArgs>(args?: SelectSubset<T, StudentPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentPayments
     * const studentPayment = await prisma.studentPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentPaymentUpdateManyArgs>(args: SelectSubset<T, StudentPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentPayments and returns the data updated in the database.
     * @param {StudentPaymentUpdateManyAndReturnArgs} args - Arguments to update many StudentPayments.
     * @example
     * // Update many StudentPayments
     * const studentPayment = await prisma.studentPayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudentPayments and only return the `id`
     * const studentPaymentWithIdOnly = await prisma.studentPayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentPaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentPaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudentPayment.
     * @param {StudentPaymentUpsertArgs} args - Arguments to update or create a StudentPayment.
     * @example
     * // Update or create a StudentPayment
     * const studentPayment = await prisma.studentPayment.upsert({
     *   create: {
     *     // ... data to create a StudentPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentPayment we want to update
     *   }
     * })
     */
    upsert<T extends StudentPaymentUpsertArgs>(args: SelectSubset<T, StudentPaymentUpsertArgs<ExtArgs>>): Prisma__StudentPaymentClient<$Result.GetResult<Prisma.$StudentPaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentPaymentCountArgs} args - Arguments to filter StudentPayments to count.
     * @example
     * // Count the number of StudentPayments
     * const count = await prisma.studentPayment.count({
     *   where: {
     *     // ... the filter for the StudentPayments we want to count
     *   }
     * })
    **/
    count<T extends StudentPaymentCountArgs>(
      args?: Subset<T, StudentPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentPaymentAggregateArgs>(args: Subset<T, StudentPaymentAggregateArgs>): Prisma.PrismaPromise<GetStudentPaymentAggregateType<T>>

    /**
     * Group by StudentPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentPaymentGroupByArgs['orderBy'] }
        : { orderBy?: StudentPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentPayment model
   */
  readonly fields: StudentPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    paymentRequests<T extends StudentPayment$paymentRequestsArgs<ExtArgs> = {}>(args?: Subset<T, StudentPayment$paymentRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    billAssignment<T extends BillAssignmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BillAssignmentDefaultArgs<ExtArgs>>): Prisma__BillAssignmentClient<$Result.GetResult<Prisma.$BillAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentPayment model
   */ 
  interface StudentPaymentFieldRefs {
    readonly id: FieldRef<"StudentPayment", 'String'>
    readonly billAssignmentId: FieldRef<"StudentPayment", 'String'>
    readonly studentId: FieldRef<"StudentPayment", 'String'>
    readonly amountPaid: FieldRef<"StudentPayment", 'Float'>
    readonly createdAt: FieldRef<"StudentPayment", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentPayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentPayment findUnique
   */
  export type StudentPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentPayment
     */
    select?: StudentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentPayment
     */
    omit?: StudentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentPaymentInclude<ExtArgs> | null
    /**
     * Filter, which StudentPayment to fetch.
     */
    where: StudentPaymentWhereUniqueInput
  }

  /**
   * StudentPayment findUniqueOrThrow
   */
  export type StudentPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentPayment
     */
    select?: StudentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentPayment
     */
    omit?: StudentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentPaymentInclude<ExtArgs> | null
    /**
     * Filter, which StudentPayment to fetch.
     */
    where: StudentPaymentWhereUniqueInput
  }

  /**
   * StudentPayment findFirst
   */
  export type StudentPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentPayment
     */
    select?: StudentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentPayment
     */
    omit?: StudentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentPaymentInclude<ExtArgs> | null
    /**
     * Filter, which StudentPayment to fetch.
     */
    where?: StudentPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentPayments to fetch.
     */
    orderBy?: StudentPaymentOrderByWithRelationInput | StudentPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentPayments.
     */
    cursor?: StudentPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentPayments.
     */
    distinct?: StudentPaymentScalarFieldEnum | StudentPaymentScalarFieldEnum[]
  }

  /**
   * StudentPayment findFirstOrThrow
   */
  export type StudentPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentPayment
     */
    select?: StudentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentPayment
     */
    omit?: StudentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentPaymentInclude<ExtArgs> | null
    /**
     * Filter, which StudentPayment to fetch.
     */
    where?: StudentPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentPayments to fetch.
     */
    orderBy?: StudentPaymentOrderByWithRelationInput | StudentPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentPayments.
     */
    cursor?: StudentPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentPayments.
     */
    distinct?: StudentPaymentScalarFieldEnum | StudentPaymentScalarFieldEnum[]
  }

  /**
   * StudentPayment findMany
   */
  export type StudentPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentPayment
     */
    select?: StudentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentPayment
     */
    omit?: StudentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentPaymentInclude<ExtArgs> | null
    /**
     * Filter, which StudentPayments to fetch.
     */
    where?: StudentPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentPayments to fetch.
     */
    orderBy?: StudentPaymentOrderByWithRelationInput | StudentPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentPayments.
     */
    cursor?: StudentPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentPayments.
     */
    skip?: number
    distinct?: StudentPaymentScalarFieldEnum | StudentPaymentScalarFieldEnum[]
  }

  /**
   * StudentPayment create
   */
  export type StudentPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentPayment
     */
    select?: StudentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentPayment
     */
    omit?: StudentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentPayment.
     */
    data: XOR<StudentPaymentCreateInput, StudentPaymentUncheckedCreateInput>
  }

  /**
   * StudentPayment createMany
   */
  export type StudentPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentPayments.
     */
    data: StudentPaymentCreateManyInput | StudentPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentPayment createManyAndReturn
   */
  export type StudentPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentPayment
     */
    select?: StudentPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentPayment
     */
    omit?: StudentPaymentOmit<ExtArgs> | null
    /**
     * The data used to create many StudentPayments.
     */
    data: StudentPaymentCreateManyInput | StudentPaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentPaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentPayment update
   */
  export type StudentPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentPayment
     */
    select?: StudentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentPayment
     */
    omit?: StudentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentPayment.
     */
    data: XOR<StudentPaymentUpdateInput, StudentPaymentUncheckedUpdateInput>
    /**
     * Choose, which StudentPayment to update.
     */
    where: StudentPaymentWhereUniqueInput
  }

  /**
   * StudentPayment updateMany
   */
  export type StudentPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentPayments.
     */
    data: XOR<StudentPaymentUpdateManyMutationInput, StudentPaymentUncheckedUpdateManyInput>
    /**
     * Filter which StudentPayments to update
     */
    where?: StudentPaymentWhereInput
    /**
     * Limit how many StudentPayments to update.
     */
    limit?: number
  }

  /**
   * StudentPayment updateManyAndReturn
   */
  export type StudentPaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentPayment
     */
    select?: StudentPaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentPayment
     */
    omit?: StudentPaymentOmit<ExtArgs> | null
    /**
     * The data used to update StudentPayments.
     */
    data: XOR<StudentPaymentUpdateManyMutationInput, StudentPaymentUncheckedUpdateManyInput>
    /**
     * Filter which StudentPayments to update
     */
    where?: StudentPaymentWhereInput
    /**
     * Limit how many StudentPayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentPaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentPayment upsert
   */
  export type StudentPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentPayment
     */
    select?: StudentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentPayment
     */
    omit?: StudentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentPayment to update in case it exists.
     */
    where: StudentPaymentWhereUniqueInput
    /**
     * In case the StudentPayment found by the `where` argument doesn't exist, create a new StudentPayment with this data.
     */
    create: XOR<StudentPaymentCreateInput, StudentPaymentUncheckedCreateInput>
    /**
     * In case the StudentPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentPaymentUpdateInput, StudentPaymentUncheckedUpdateInput>
  }

  /**
   * StudentPayment delete
   */
  export type StudentPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentPayment
     */
    select?: StudentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentPayment
     */
    omit?: StudentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentPaymentInclude<ExtArgs> | null
    /**
     * Filter which StudentPayment to delete.
     */
    where: StudentPaymentWhereUniqueInput
  }

  /**
   * StudentPayment deleteMany
   */
  export type StudentPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentPayments to delete
     */
    where?: StudentPaymentWhereInput
    /**
     * Limit how many StudentPayments to delete.
     */
    limit?: number
  }

  /**
   * StudentPayment.paymentRequests
   */
  export type StudentPayment$paymentRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRequest
     */
    select?: PaymentRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRequest
     */
    omit?: PaymentRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRequestInclude<ExtArgs> | null
    where?: PaymentRequestWhereInput
    orderBy?: PaymentRequestOrderByWithRelationInput | PaymentRequestOrderByWithRelationInput[]
    cursor?: PaymentRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentRequestScalarFieldEnum | PaymentRequestScalarFieldEnum[]
  }

  /**
   * StudentPayment without action
   */
  export type StudentPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentPayment
     */
    select?: StudentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentPayment
     */
    omit?: StudentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentPaymentInclude<ExtArgs> | null
  }


  /**
   * Model PaymentRequest
   */

  export type AggregatePaymentRequest = {
    _count: PaymentRequestCountAggregateOutputType | null
    _avg: PaymentRequestAvgAggregateOutputType | null
    _sum: PaymentRequestSumAggregateOutputType | null
    _min: PaymentRequestMinAggregateOutputType | null
    _max: PaymentRequestMaxAggregateOutputType | null
  }

  export type PaymentRequestAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentRequestSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentRequestMinAggregateOutputType = {
    id: string | null
    billId: string | null
    billAssignmentId: string | null
    studentPaymentId: string | null
    studentId: string | null
    amount: number | null
    receiptUrl: string | null
    status: $Enums.PaymentStatus | null
    notes: string | null
    processedById: string | null
    processedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentRequestMaxAggregateOutputType = {
    id: string | null
    billId: string | null
    billAssignmentId: string | null
    studentPaymentId: string | null
    studentId: string | null
    amount: number | null
    receiptUrl: string | null
    status: $Enums.PaymentStatus | null
    notes: string | null
    processedById: string | null
    processedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentRequestCountAggregateOutputType = {
    id: number
    billId: number
    billAssignmentId: number
    studentPaymentId: number
    studentId: number
    amount: number
    receiptUrl: number
    status: number
    notes: number
    processedById: number
    processedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentRequestAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentRequestSumAggregateInputType = {
    amount?: true
  }

  export type PaymentRequestMinAggregateInputType = {
    id?: true
    billId?: true
    billAssignmentId?: true
    studentPaymentId?: true
    studentId?: true
    amount?: true
    receiptUrl?: true
    status?: true
    notes?: true
    processedById?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentRequestMaxAggregateInputType = {
    id?: true
    billId?: true
    billAssignmentId?: true
    studentPaymentId?: true
    studentId?: true
    amount?: true
    receiptUrl?: true
    status?: true
    notes?: true
    processedById?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentRequestCountAggregateInputType = {
    id?: true
    billId?: true
    billAssignmentId?: true
    studentPaymentId?: true
    studentId?: true
    amount?: true
    receiptUrl?: true
    status?: true
    notes?: true
    processedById?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentRequest to aggregate.
     */
    where?: PaymentRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentRequests to fetch.
     */
    orderBy?: PaymentRequestOrderByWithRelationInput | PaymentRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentRequests
    **/
    _count?: true | PaymentRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentRequestMaxAggregateInputType
  }

  export type GetPaymentRequestAggregateType<T extends PaymentRequestAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentRequest[P]>
      : GetScalarType<T[P], AggregatePaymentRequest[P]>
  }




  export type PaymentRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentRequestWhereInput
    orderBy?: PaymentRequestOrderByWithAggregationInput | PaymentRequestOrderByWithAggregationInput[]
    by: PaymentRequestScalarFieldEnum[] | PaymentRequestScalarFieldEnum
    having?: PaymentRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentRequestCountAggregateInputType | true
    _avg?: PaymentRequestAvgAggregateInputType
    _sum?: PaymentRequestSumAggregateInputType
    _min?: PaymentRequestMinAggregateInputType
    _max?: PaymentRequestMaxAggregateInputType
  }

  export type PaymentRequestGroupByOutputType = {
    id: string
    billId: string
    billAssignmentId: string
    studentPaymentId: string | null
    studentId: string
    amount: number
    receiptUrl: string | null
    status: $Enums.PaymentStatus
    notes: string | null
    processedById: string | null
    processedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentRequestCountAggregateOutputType | null
    _avg: PaymentRequestAvgAggregateOutputType | null
    _sum: PaymentRequestSumAggregateOutputType | null
    _min: PaymentRequestMinAggregateOutputType | null
    _max: PaymentRequestMaxAggregateOutputType | null
  }

  type GetPaymentRequestGroupByPayload<T extends PaymentRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentRequestGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentRequestGroupByOutputType[P]>
        }
      >
    >


  export type PaymentRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billId?: boolean
    billAssignmentId?: boolean
    studentPaymentId?: boolean
    studentId?: boolean
    amount?: boolean
    receiptUrl?: boolean
    status?: boolean
    notes?: boolean
    processedById?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    billAssignment?: boolean | BillAssignmentDefaultArgs<ExtArgs>
    bill?: boolean | BillDefaultArgs<ExtArgs>
    processedBy?: boolean | PaymentRequest$processedByArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    studentPayment?: boolean | PaymentRequest$studentPaymentArgs<ExtArgs>
  }, ExtArgs["result"]["paymentRequest"]>

  export type PaymentRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billId?: boolean
    billAssignmentId?: boolean
    studentPaymentId?: boolean
    studentId?: boolean
    amount?: boolean
    receiptUrl?: boolean
    status?: boolean
    notes?: boolean
    processedById?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    billAssignment?: boolean | BillAssignmentDefaultArgs<ExtArgs>
    bill?: boolean | BillDefaultArgs<ExtArgs>
    processedBy?: boolean | PaymentRequest$processedByArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    studentPayment?: boolean | PaymentRequest$studentPaymentArgs<ExtArgs>
  }, ExtArgs["result"]["paymentRequest"]>

  export type PaymentRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billId?: boolean
    billAssignmentId?: boolean
    studentPaymentId?: boolean
    studentId?: boolean
    amount?: boolean
    receiptUrl?: boolean
    status?: boolean
    notes?: boolean
    processedById?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    billAssignment?: boolean | BillAssignmentDefaultArgs<ExtArgs>
    bill?: boolean | BillDefaultArgs<ExtArgs>
    processedBy?: boolean | PaymentRequest$processedByArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    studentPayment?: boolean | PaymentRequest$studentPaymentArgs<ExtArgs>
  }, ExtArgs["result"]["paymentRequest"]>

  export type PaymentRequestSelectScalar = {
    id?: boolean
    billId?: boolean
    billAssignmentId?: boolean
    studentPaymentId?: boolean
    studentId?: boolean
    amount?: boolean
    receiptUrl?: boolean
    status?: boolean
    notes?: boolean
    processedById?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "billId" | "billAssignmentId" | "studentPaymentId" | "studentId" | "amount" | "receiptUrl" | "status" | "notes" | "processedById" | "processedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["paymentRequest"]>
  export type PaymentRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    billAssignment?: boolean | BillAssignmentDefaultArgs<ExtArgs>
    bill?: boolean | BillDefaultArgs<ExtArgs>
    processedBy?: boolean | PaymentRequest$processedByArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    studentPayment?: boolean | PaymentRequest$studentPaymentArgs<ExtArgs>
  }
  export type PaymentRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    billAssignment?: boolean | BillAssignmentDefaultArgs<ExtArgs>
    bill?: boolean | BillDefaultArgs<ExtArgs>
    processedBy?: boolean | PaymentRequest$processedByArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    studentPayment?: boolean | PaymentRequest$studentPaymentArgs<ExtArgs>
  }
  export type PaymentRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    billAssignment?: boolean | BillAssignmentDefaultArgs<ExtArgs>
    bill?: boolean | BillDefaultArgs<ExtArgs>
    processedBy?: boolean | PaymentRequest$processedByArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    studentPayment?: boolean | PaymentRequest$studentPaymentArgs<ExtArgs>
  }

  export type $PaymentRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentRequest"
    objects: {
      billAssignment: Prisma.$BillAssignmentPayload<ExtArgs>
      bill: Prisma.$BillPayload<ExtArgs>
      processedBy: Prisma.$UserPayload<ExtArgs> | null
      student: Prisma.$StudentPayload<ExtArgs>
      studentPayment: Prisma.$StudentPaymentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      billId: string
      billAssignmentId: string
      studentPaymentId: string | null
      studentId: string
      amount: number
      receiptUrl: string | null
      status: $Enums.PaymentStatus
      notes: string | null
      processedById: string | null
      processedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentRequest"]>
    composites: {}
  }

  type PaymentRequestGetPayload<S extends boolean | null | undefined | PaymentRequestDefaultArgs> = $Result.GetResult<Prisma.$PaymentRequestPayload, S>

  type PaymentRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentRequestCountAggregateInputType | true
    }

  export interface PaymentRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentRequest'], meta: { name: 'PaymentRequest' } }
    /**
     * Find zero or one PaymentRequest that matches the filter.
     * @param {PaymentRequestFindUniqueArgs} args - Arguments to find a PaymentRequest
     * @example
     * // Get one PaymentRequest
     * const paymentRequest = await prisma.paymentRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentRequestFindUniqueArgs>(args: SelectSubset<T, PaymentRequestFindUniqueArgs<ExtArgs>>): Prisma__PaymentRequestClient<$Result.GetResult<Prisma.$PaymentRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentRequestFindUniqueOrThrowArgs} args - Arguments to find a PaymentRequest
     * @example
     * // Get one PaymentRequest
     * const paymentRequest = await prisma.paymentRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentRequestClient<$Result.GetResult<Prisma.$PaymentRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentRequestFindFirstArgs} args - Arguments to find a PaymentRequest
     * @example
     * // Get one PaymentRequest
     * const paymentRequest = await prisma.paymentRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentRequestFindFirstArgs>(args?: SelectSubset<T, PaymentRequestFindFirstArgs<ExtArgs>>): Prisma__PaymentRequestClient<$Result.GetResult<Prisma.$PaymentRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentRequestFindFirstOrThrowArgs} args - Arguments to find a PaymentRequest
     * @example
     * // Get one PaymentRequest
     * const paymentRequest = await prisma.paymentRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentRequestClient<$Result.GetResult<Prisma.$PaymentRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentRequests
     * const paymentRequests = await prisma.paymentRequest.findMany()
     * 
     * // Get first 10 PaymentRequests
     * const paymentRequests = await prisma.paymentRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentRequestWithIdOnly = await prisma.paymentRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentRequestFindManyArgs>(args?: SelectSubset<T, PaymentRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentRequest.
     * @param {PaymentRequestCreateArgs} args - Arguments to create a PaymentRequest.
     * @example
     * // Create one PaymentRequest
     * const PaymentRequest = await prisma.paymentRequest.create({
     *   data: {
     *     // ... data to create a PaymentRequest
     *   }
     * })
     * 
     */
    create<T extends PaymentRequestCreateArgs>(args: SelectSubset<T, PaymentRequestCreateArgs<ExtArgs>>): Prisma__PaymentRequestClient<$Result.GetResult<Prisma.$PaymentRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentRequests.
     * @param {PaymentRequestCreateManyArgs} args - Arguments to create many PaymentRequests.
     * @example
     * // Create many PaymentRequests
     * const paymentRequest = await prisma.paymentRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentRequestCreateManyArgs>(args?: SelectSubset<T, PaymentRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentRequests and returns the data saved in the database.
     * @param {PaymentRequestCreateManyAndReturnArgs} args - Arguments to create many PaymentRequests.
     * @example
     * // Create many PaymentRequests
     * const paymentRequest = await prisma.paymentRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentRequests and only return the `id`
     * const paymentRequestWithIdOnly = await prisma.paymentRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentRequest.
     * @param {PaymentRequestDeleteArgs} args - Arguments to delete one PaymentRequest.
     * @example
     * // Delete one PaymentRequest
     * const PaymentRequest = await prisma.paymentRequest.delete({
     *   where: {
     *     // ... filter to delete one PaymentRequest
     *   }
     * })
     * 
     */
    delete<T extends PaymentRequestDeleteArgs>(args: SelectSubset<T, PaymentRequestDeleteArgs<ExtArgs>>): Prisma__PaymentRequestClient<$Result.GetResult<Prisma.$PaymentRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentRequest.
     * @param {PaymentRequestUpdateArgs} args - Arguments to update one PaymentRequest.
     * @example
     * // Update one PaymentRequest
     * const paymentRequest = await prisma.paymentRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentRequestUpdateArgs>(args: SelectSubset<T, PaymentRequestUpdateArgs<ExtArgs>>): Prisma__PaymentRequestClient<$Result.GetResult<Prisma.$PaymentRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentRequests.
     * @param {PaymentRequestDeleteManyArgs} args - Arguments to filter PaymentRequests to delete.
     * @example
     * // Delete a few PaymentRequests
     * const { count } = await prisma.paymentRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentRequestDeleteManyArgs>(args?: SelectSubset<T, PaymentRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentRequests
     * const paymentRequest = await prisma.paymentRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentRequestUpdateManyArgs>(args: SelectSubset<T, PaymentRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentRequests and returns the data updated in the database.
     * @param {PaymentRequestUpdateManyAndReturnArgs} args - Arguments to update many PaymentRequests.
     * @example
     * // Update many PaymentRequests
     * const paymentRequest = await prisma.paymentRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentRequests and only return the `id`
     * const paymentRequestWithIdOnly = await prisma.paymentRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentRequest.
     * @param {PaymentRequestUpsertArgs} args - Arguments to update or create a PaymentRequest.
     * @example
     * // Update or create a PaymentRequest
     * const paymentRequest = await prisma.paymentRequest.upsert({
     *   create: {
     *     // ... data to create a PaymentRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentRequest we want to update
     *   }
     * })
     */
    upsert<T extends PaymentRequestUpsertArgs>(args: SelectSubset<T, PaymentRequestUpsertArgs<ExtArgs>>): Prisma__PaymentRequestClient<$Result.GetResult<Prisma.$PaymentRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentRequestCountArgs} args - Arguments to filter PaymentRequests to count.
     * @example
     * // Count the number of PaymentRequests
     * const count = await prisma.paymentRequest.count({
     *   where: {
     *     // ... the filter for the PaymentRequests we want to count
     *   }
     * })
    **/
    count<T extends PaymentRequestCountArgs>(
      args?: Subset<T, PaymentRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentRequestAggregateArgs>(args: Subset<T, PaymentRequestAggregateArgs>): Prisma.PrismaPromise<GetPaymentRequestAggregateType<T>>

    /**
     * Group by PaymentRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentRequestGroupByArgs['orderBy'] }
        : { orderBy?: PaymentRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentRequest model
   */
  readonly fields: PaymentRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    billAssignment<T extends BillAssignmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BillAssignmentDefaultArgs<ExtArgs>>): Prisma__BillAssignmentClient<$Result.GetResult<Prisma.$BillAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bill<T extends BillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BillDefaultArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    processedBy<T extends PaymentRequest$processedByArgs<ExtArgs> = {}>(args?: Subset<T, PaymentRequest$processedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    studentPayment<T extends PaymentRequest$studentPaymentArgs<ExtArgs> = {}>(args?: Subset<T, PaymentRequest$studentPaymentArgs<ExtArgs>>): Prisma__StudentPaymentClient<$Result.GetResult<Prisma.$StudentPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentRequest model
   */ 
  interface PaymentRequestFieldRefs {
    readonly id: FieldRef<"PaymentRequest", 'String'>
    readonly billId: FieldRef<"PaymentRequest", 'String'>
    readonly billAssignmentId: FieldRef<"PaymentRequest", 'String'>
    readonly studentPaymentId: FieldRef<"PaymentRequest", 'String'>
    readonly studentId: FieldRef<"PaymentRequest", 'String'>
    readonly amount: FieldRef<"PaymentRequest", 'Float'>
    readonly receiptUrl: FieldRef<"PaymentRequest", 'String'>
    readonly status: FieldRef<"PaymentRequest", 'PaymentStatus'>
    readonly notes: FieldRef<"PaymentRequest", 'String'>
    readonly processedById: FieldRef<"PaymentRequest", 'String'>
    readonly processedAt: FieldRef<"PaymentRequest", 'DateTime'>
    readonly createdAt: FieldRef<"PaymentRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentRequest findUnique
   */
  export type PaymentRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRequest
     */
    select?: PaymentRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRequest
     */
    omit?: PaymentRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRequestInclude<ExtArgs> | null
    /**
     * Filter, which PaymentRequest to fetch.
     */
    where: PaymentRequestWhereUniqueInput
  }

  /**
   * PaymentRequest findUniqueOrThrow
   */
  export type PaymentRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRequest
     */
    select?: PaymentRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRequest
     */
    omit?: PaymentRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRequestInclude<ExtArgs> | null
    /**
     * Filter, which PaymentRequest to fetch.
     */
    where: PaymentRequestWhereUniqueInput
  }

  /**
   * PaymentRequest findFirst
   */
  export type PaymentRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRequest
     */
    select?: PaymentRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRequest
     */
    omit?: PaymentRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRequestInclude<ExtArgs> | null
    /**
     * Filter, which PaymentRequest to fetch.
     */
    where?: PaymentRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentRequests to fetch.
     */
    orderBy?: PaymentRequestOrderByWithRelationInput | PaymentRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentRequests.
     */
    cursor?: PaymentRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentRequests.
     */
    distinct?: PaymentRequestScalarFieldEnum | PaymentRequestScalarFieldEnum[]
  }

  /**
   * PaymentRequest findFirstOrThrow
   */
  export type PaymentRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRequest
     */
    select?: PaymentRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRequest
     */
    omit?: PaymentRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRequestInclude<ExtArgs> | null
    /**
     * Filter, which PaymentRequest to fetch.
     */
    where?: PaymentRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentRequests to fetch.
     */
    orderBy?: PaymentRequestOrderByWithRelationInput | PaymentRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentRequests.
     */
    cursor?: PaymentRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentRequests.
     */
    distinct?: PaymentRequestScalarFieldEnum | PaymentRequestScalarFieldEnum[]
  }

  /**
   * PaymentRequest findMany
   */
  export type PaymentRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRequest
     */
    select?: PaymentRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRequest
     */
    omit?: PaymentRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRequestInclude<ExtArgs> | null
    /**
     * Filter, which PaymentRequests to fetch.
     */
    where?: PaymentRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentRequests to fetch.
     */
    orderBy?: PaymentRequestOrderByWithRelationInput | PaymentRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentRequests.
     */
    cursor?: PaymentRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentRequests.
     */
    skip?: number
    distinct?: PaymentRequestScalarFieldEnum | PaymentRequestScalarFieldEnum[]
  }

  /**
   * PaymentRequest create
   */
  export type PaymentRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRequest
     */
    select?: PaymentRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRequest
     */
    omit?: PaymentRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentRequest.
     */
    data: XOR<PaymentRequestCreateInput, PaymentRequestUncheckedCreateInput>
  }

  /**
   * PaymentRequest createMany
   */
  export type PaymentRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentRequests.
     */
    data: PaymentRequestCreateManyInput | PaymentRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentRequest createManyAndReturn
   */
  export type PaymentRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRequest
     */
    select?: PaymentRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRequest
     */
    omit?: PaymentRequestOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentRequests.
     */
    data: PaymentRequestCreateManyInput | PaymentRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentRequest update
   */
  export type PaymentRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRequest
     */
    select?: PaymentRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRequest
     */
    omit?: PaymentRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentRequest.
     */
    data: XOR<PaymentRequestUpdateInput, PaymentRequestUncheckedUpdateInput>
    /**
     * Choose, which PaymentRequest to update.
     */
    where: PaymentRequestWhereUniqueInput
  }

  /**
   * PaymentRequest updateMany
   */
  export type PaymentRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentRequests.
     */
    data: XOR<PaymentRequestUpdateManyMutationInput, PaymentRequestUncheckedUpdateManyInput>
    /**
     * Filter which PaymentRequests to update
     */
    where?: PaymentRequestWhereInput
    /**
     * Limit how many PaymentRequests to update.
     */
    limit?: number
  }

  /**
   * PaymentRequest updateManyAndReturn
   */
  export type PaymentRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRequest
     */
    select?: PaymentRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRequest
     */
    omit?: PaymentRequestOmit<ExtArgs> | null
    /**
     * The data used to update PaymentRequests.
     */
    data: XOR<PaymentRequestUpdateManyMutationInput, PaymentRequestUncheckedUpdateManyInput>
    /**
     * Filter which PaymentRequests to update
     */
    where?: PaymentRequestWhereInput
    /**
     * Limit how many PaymentRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentRequest upsert
   */
  export type PaymentRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRequest
     */
    select?: PaymentRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRequest
     */
    omit?: PaymentRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentRequest to update in case it exists.
     */
    where: PaymentRequestWhereUniqueInput
    /**
     * In case the PaymentRequest found by the `where` argument doesn't exist, create a new PaymentRequest with this data.
     */
    create: XOR<PaymentRequestCreateInput, PaymentRequestUncheckedCreateInput>
    /**
     * In case the PaymentRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentRequestUpdateInput, PaymentRequestUncheckedUpdateInput>
  }

  /**
   * PaymentRequest delete
   */
  export type PaymentRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRequest
     */
    select?: PaymentRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRequest
     */
    omit?: PaymentRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRequestInclude<ExtArgs> | null
    /**
     * Filter which PaymentRequest to delete.
     */
    where: PaymentRequestWhereUniqueInput
  }

  /**
   * PaymentRequest deleteMany
   */
  export type PaymentRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentRequests to delete
     */
    where?: PaymentRequestWhereInput
    /**
     * Limit how many PaymentRequests to delete.
     */
    limit?: number
  }

  /**
   * PaymentRequest.processedBy
   */
  export type PaymentRequest$processedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PaymentRequest.studentPayment
   */
  export type PaymentRequest$studentPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentPayment
     */
    select?: StudentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentPayment
     */
    omit?: StudentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentPaymentInclude<ExtArgs> | null
    where?: StudentPaymentWhereInput
  }

  /**
   * PaymentRequest without action
   */
  export type PaymentRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRequest
     */
    select?: PaymentRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRequest
     */
    omit?: PaymentRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRequestInclude<ExtArgs> | null
  }


  /**
   * Model SchoolLevel
   */

  export type AggregateSchoolLevel = {
    _count: SchoolLevelCountAggregateOutputType | null
    _avg: SchoolLevelAvgAggregateOutputType | null
    _sum: SchoolLevelSumAggregateOutputType | null
    _min: SchoolLevelMinAggregateOutputType | null
    _max: SchoolLevelMaxAggregateOutputType | null
  }

  export type SchoolLevelAvgAggregateOutputType = {
    order: number | null
  }

  export type SchoolLevelSumAggregateOutputType = {
    order: number | null
  }

  export type SchoolLevelMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    order: number | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolLevelMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    order: number | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolLevelCountAggregateOutputType = {
    id: number
    name: number
    description: number
    order: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SchoolLevelAvgAggregateInputType = {
    order?: true
  }

  export type SchoolLevelSumAggregateInputType = {
    order?: true
  }

  export type SchoolLevelMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    order?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolLevelMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    order?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolLevelCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    order?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchoolLevelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolLevel to aggregate.
     */
    where?: SchoolLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolLevels to fetch.
     */
    orderBy?: SchoolLevelOrderByWithRelationInput | SchoolLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SchoolLevels
    **/
    _count?: true | SchoolLevelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SchoolLevelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SchoolLevelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolLevelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolLevelMaxAggregateInputType
  }

  export type GetSchoolLevelAggregateType<T extends SchoolLevelAggregateArgs> = {
        [P in keyof T & keyof AggregateSchoolLevel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchoolLevel[P]>
      : GetScalarType<T[P], AggregateSchoolLevel[P]>
  }




  export type SchoolLevelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolLevelWhereInput
    orderBy?: SchoolLevelOrderByWithAggregationInput | SchoolLevelOrderByWithAggregationInput[]
    by: SchoolLevelScalarFieldEnum[] | SchoolLevelScalarFieldEnum
    having?: SchoolLevelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolLevelCountAggregateInputType | true
    _avg?: SchoolLevelAvgAggregateInputType
    _sum?: SchoolLevelSumAggregateInputType
    _min?: SchoolLevelMinAggregateInputType
    _max?: SchoolLevelMaxAggregateInputType
  }

  export type SchoolLevelGroupByOutputType = {
    id: string
    name: string
    description: string | null
    order: number
    schoolId: string
    createdAt: Date
    updatedAt: Date
    _count: SchoolLevelCountAggregateOutputType | null
    _avg: SchoolLevelAvgAggregateOutputType | null
    _sum: SchoolLevelSumAggregateOutputType | null
    _min: SchoolLevelMinAggregateOutputType | null
    _max: SchoolLevelMaxAggregateOutputType | null
  }

  type GetSchoolLevelGroupByPayload<T extends SchoolLevelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolLevelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolLevelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolLevelGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolLevelGroupByOutputType[P]>
        }
      >
    >


  export type SchoolLevelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    classes?: boolean | SchoolLevel$classesArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    subjects?: boolean | SchoolLevel$subjectsArgs<ExtArgs>
    _count?: boolean | SchoolLevelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolLevel"]>

  export type SchoolLevelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolLevel"]>

  export type SchoolLevelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolLevel"]>

  export type SchoolLevelSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SchoolLevelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "order" | "schoolId" | "createdAt" | "updatedAt", ExtArgs["result"]["schoolLevel"]>
  export type SchoolLevelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | SchoolLevel$classesArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    subjects?: boolean | SchoolLevel$subjectsArgs<ExtArgs>
    _count?: boolean | SchoolLevelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SchoolLevelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type SchoolLevelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $SchoolLevelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SchoolLevel"
    objects: {
      classes: Prisma.$ClassPayload<ExtArgs>[]
      school: Prisma.$SchoolPayload<ExtArgs>
      subjects: Prisma.$SubjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      order: number
      schoolId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["schoolLevel"]>
    composites: {}
  }

  type SchoolLevelGetPayload<S extends boolean | null | undefined | SchoolLevelDefaultArgs> = $Result.GetResult<Prisma.$SchoolLevelPayload, S>

  type SchoolLevelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SchoolLevelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SchoolLevelCountAggregateInputType | true
    }

  export interface SchoolLevelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SchoolLevel'], meta: { name: 'SchoolLevel' } }
    /**
     * Find zero or one SchoolLevel that matches the filter.
     * @param {SchoolLevelFindUniqueArgs} args - Arguments to find a SchoolLevel
     * @example
     * // Get one SchoolLevel
     * const schoolLevel = await prisma.schoolLevel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolLevelFindUniqueArgs>(args: SelectSubset<T, SchoolLevelFindUniqueArgs<ExtArgs>>): Prisma__SchoolLevelClient<$Result.GetResult<Prisma.$SchoolLevelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SchoolLevel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SchoolLevelFindUniqueOrThrowArgs} args - Arguments to find a SchoolLevel
     * @example
     * // Get one SchoolLevel
     * const schoolLevel = await prisma.schoolLevel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolLevelFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolLevelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolLevelClient<$Result.GetResult<Prisma.$SchoolLevelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SchoolLevel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolLevelFindFirstArgs} args - Arguments to find a SchoolLevel
     * @example
     * // Get one SchoolLevel
     * const schoolLevel = await prisma.schoolLevel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolLevelFindFirstArgs>(args?: SelectSubset<T, SchoolLevelFindFirstArgs<ExtArgs>>): Prisma__SchoolLevelClient<$Result.GetResult<Prisma.$SchoolLevelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SchoolLevel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolLevelFindFirstOrThrowArgs} args - Arguments to find a SchoolLevel
     * @example
     * // Get one SchoolLevel
     * const schoolLevel = await prisma.schoolLevel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolLevelFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolLevelFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolLevelClient<$Result.GetResult<Prisma.$SchoolLevelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SchoolLevels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolLevelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SchoolLevels
     * const schoolLevels = await prisma.schoolLevel.findMany()
     * 
     * // Get first 10 SchoolLevels
     * const schoolLevels = await prisma.schoolLevel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolLevelWithIdOnly = await prisma.schoolLevel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolLevelFindManyArgs>(args?: SelectSubset<T, SchoolLevelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolLevelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SchoolLevel.
     * @param {SchoolLevelCreateArgs} args - Arguments to create a SchoolLevel.
     * @example
     * // Create one SchoolLevel
     * const SchoolLevel = await prisma.schoolLevel.create({
     *   data: {
     *     // ... data to create a SchoolLevel
     *   }
     * })
     * 
     */
    create<T extends SchoolLevelCreateArgs>(args: SelectSubset<T, SchoolLevelCreateArgs<ExtArgs>>): Prisma__SchoolLevelClient<$Result.GetResult<Prisma.$SchoolLevelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SchoolLevels.
     * @param {SchoolLevelCreateManyArgs} args - Arguments to create many SchoolLevels.
     * @example
     * // Create many SchoolLevels
     * const schoolLevel = await prisma.schoolLevel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolLevelCreateManyArgs>(args?: SelectSubset<T, SchoolLevelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SchoolLevels and returns the data saved in the database.
     * @param {SchoolLevelCreateManyAndReturnArgs} args - Arguments to create many SchoolLevels.
     * @example
     * // Create many SchoolLevels
     * const schoolLevel = await prisma.schoolLevel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SchoolLevels and only return the `id`
     * const schoolLevelWithIdOnly = await prisma.schoolLevel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchoolLevelCreateManyAndReturnArgs>(args?: SelectSubset<T, SchoolLevelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolLevelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SchoolLevel.
     * @param {SchoolLevelDeleteArgs} args - Arguments to delete one SchoolLevel.
     * @example
     * // Delete one SchoolLevel
     * const SchoolLevel = await prisma.schoolLevel.delete({
     *   where: {
     *     // ... filter to delete one SchoolLevel
     *   }
     * })
     * 
     */
    delete<T extends SchoolLevelDeleteArgs>(args: SelectSubset<T, SchoolLevelDeleteArgs<ExtArgs>>): Prisma__SchoolLevelClient<$Result.GetResult<Prisma.$SchoolLevelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SchoolLevel.
     * @param {SchoolLevelUpdateArgs} args - Arguments to update one SchoolLevel.
     * @example
     * // Update one SchoolLevel
     * const schoolLevel = await prisma.schoolLevel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolLevelUpdateArgs>(args: SelectSubset<T, SchoolLevelUpdateArgs<ExtArgs>>): Prisma__SchoolLevelClient<$Result.GetResult<Prisma.$SchoolLevelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SchoolLevels.
     * @param {SchoolLevelDeleteManyArgs} args - Arguments to filter SchoolLevels to delete.
     * @example
     * // Delete a few SchoolLevels
     * const { count } = await prisma.schoolLevel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolLevelDeleteManyArgs>(args?: SelectSubset<T, SchoolLevelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolLevelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SchoolLevels
     * const schoolLevel = await prisma.schoolLevel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolLevelUpdateManyArgs>(args: SelectSubset<T, SchoolLevelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolLevels and returns the data updated in the database.
     * @param {SchoolLevelUpdateManyAndReturnArgs} args - Arguments to update many SchoolLevels.
     * @example
     * // Update many SchoolLevels
     * const schoolLevel = await prisma.schoolLevel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SchoolLevels and only return the `id`
     * const schoolLevelWithIdOnly = await prisma.schoolLevel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SchoolLevelUpdateManyAndReturnArgs>(args: SelectSubset<T, SchoolLevelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolLevelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SchoolLevel.
     * @param {SchoolLevelUpsertArgs} args - Arguments to update or create a SchoolLevel.
     * @example
     * // Update or create a SchoolLevel
     * const schoolLevel = await prisma.schoolLevel.upsert({
     *   create: {
     *     // ... data to create a SchoolLevel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SchoolLevel we want to update
     *   }
     * })
     */
    upsert<T extends SchoolLevelUpsertArgs>(args: SelectSubset<T, SchoolLevelUpsertArgs<ExtArgs>>): Prisma__SchoolLevelClient<$Result.GetResult<Prisma.$SchoolLevelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SchoolLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolLevelCountArgs} args - Arguments to filter SchoolLevels to count.
     * @example
     * // Count the number of SchoolLevels
     * const count = await prisma.schoolLevel.count({
     *   where: {
     *     // ... the filter for the SchoolLevels we want to count
     *   }
     * })
    **/
    count<T extends SchoolLevelCountArgs>(
      args?: Subset<T, SchoolLevelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolLevelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SchoolLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolLevelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolLevelAggregateArgs>(args: Subset<T, SchoolLevelAggregateArgs>): Prisma.PrismaPromise<GetSchoolLevelAggregateType<T>>

    /**
     * Group by SchoolLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolLevelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolLevelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolLevelGroupByArgs['orderBy'] }
        : { orderBy?: SchoolLevelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolLevelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolLevelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SchoolLevel model
   */
  readonly fields: SchoolLevelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SchoolLevel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolLevelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classes<T extends SchoolLevel$classesArgs<ExtArgs> = {}>(args?: Subset<T, SchoolLevel$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subjects<T extends SchoolLevel$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, SchoolLevel$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SchoolLevel model
   */ 
  interface SchoolLevelFieldRefs {
    readonly id: FieldRef<"SchoolLevel", 'String'>
    readonly name: FieldRef<"SchoolLevel", 'String'>
    readonly description: FieldRef<"SchoolLevel", 'String'>
    readonly order: FieldRef<"SchoolLevel", 'Int'>
    readonly schoolId: FieldRef<"SchoolLevel", 'String'>
    readonly createdAt: FieldRef<"SchoolLevel", 'DateTime'>
    readonly updatedAt: FieldRef<"SchoolLevel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SchoolLevel findUnique
   */
  export type SchoolLevelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLevel
     */
    select?: SchoolLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolLevel
     */
    omit?: SchoolLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLevelInclude<ExtArgs> | null
    /**
     * Filter, which SchoolLevel to fetch.
     */
    where: SchoolLevelWhereUniqueInput
  }

  /**
   * SchoolLevel findUniqueOrThrow
   */
  export type SchoolLevelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLevel
     */
    select?: SchoolLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolLevel
     */
    omit?: SchoolLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLevelInclude<ExtArgs> | null
    /**
     * Filter, which SchoolLevel to fetch.
     */
    where: SchoolLevelWhereUniqueInput
  }

  /**
   * SchoolLevel findFirst
   */
  export type SchoolLevelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLevel
     */
    select?: SchoolLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolLevel
     */
    omit?: SchoolLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLevelInclude<ExtArgs> | null
    /**
     * Filter, which SchoolLevel to fetch.
     */
    where?: SchoolLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolLevels to fetch.
     */
    orderBy?: SchoolLevelOrderByWithRelationInput | SchoolLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolLevels.
     */
    cursor?: SchoolLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolLevels.
     */
    distinct?: SchoolLevelScalarFieldEnum | SchoolLevelScalarFieldEnum[]
  }

  /**
   * SchoolLevel findFirstOrThrow
   */
  export type SchoolLevelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLevel
     */
    select?: SchoolLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolLevel
     */
    omit?: SchoolLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLevelInclude<ExtArgs> | null
    /**
     * Filter, which SchoolLevel to fetch.
     */
    where?: SchoolLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolLevels to fetch.
     */
    orderBy?: SchoolLevelOrderByWithRelationInput | SchoolLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolLevels.
     */
    cursor?: SchoolLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolLevels.
     */
    distinct?: SchoolLevelScalarFieldEnum | SchoolLevelScalarFieldEnum[]
  }

  /**
   * SchoolLevel findMany
   */
  export type SchoolLevelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLevel
     */
    select?: SchoolLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolLevel
     */
    omit?: SchoolLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLevelInclude<ExtArgs> | null
    /**
     * Filter, which SchoolLevels to fetch.
     */
    where?: SchoolLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolLevels to fetch.
     */
    orderBy?: SchoolLevelOrderByWithRelationInput | SchoolLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SchoolLevels.
     */
    cursor?: SchoolLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolLevels.
     */
    skip?: number
    distinct?: SchoolLevelScalarFieldEnum | SchoolLevelScalarFieldEnum[]
  }

  /**
   * SchoolLevel create
   */
  export type SchoolLevelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLevel
     */
    select?: SchoolLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolLevel
     */
    omit?: SchoolLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLevelInclude<ExtArgs> | null
    /**
     * The data needed to create a SchoolLevel.
     */
    data: XOR<SchoolLevelCreateInput, SchoolLevelUncheckedCreateInput>
  }

  /**
   * SchoolLevel createMany
   */
  export type SchoolLevelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SchoolLevels.
     */
    data: SchoolLevelCreateManyInput | SchoolLevelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SchoolLevel createManyAndReturn
   */
  export type SchoolLevelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLevel
     */
    select?: SchoolLevelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolLevel
     */
    omit?: SchoolLevelOmit<ExtArgs> | null
    /**
     * The data used to create many SchoolLevels.
     */
    data: SchoolLevelCreateManyInput | SchoolLevelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLevelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SchoolLevel update
   */
  export type SchoolLevelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLevel
     */
    select?: SchoolLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolLevel
     */
    omit?: SchoolLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLevelInclude<ExtArgs> | null
    /**
     * The data needed to update a SchoolLevel.
     */
    data: XOR<SchoolLevelUpdateInput, SchoolLevelUncheckedUpdateInput>
    /**
     * Choose, which SchoolLevel to update.
     */
    where: SchoolLevelWhereUniqueInput
  }

  /**
   * SchoolLevel updateMany
   */
  export type SchoolLevelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SchoolLevels.
     */
    data: XOR<SchoolLevelUpdateManyMutationInput, SchoolLevelUncheckedUpdateManyInput>
    /**
     * Filter which SchoolLevels to update
     */
    where?: SchoolLevelWhereInput
    /**
     * Limit how many SchoolLevels to update.
     */
    limit?: number
  }

  /**
   * SchoolLevel updateManyAndReturn
   */
  export type SchoolLevelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLevel
     */
    select?: SchoolLevelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolLevel
     */
    omit?: SchoolLevelOmit<ExtArgs> | null
    /**
     * The data used to update SchoolLevels.
     */
    data: XOR<SchoolLevelUpdateManyMutationInput, SchoolLevelUncheckedUpdateManyInput>
    /**
     * Filter which SchoolLevels to update
     */
    where?: SchoolLevelWhereInput
    /**
     * Limit how many SchoolLevels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLevelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SchoolLevel upsert
   */
  export type SchoolLevelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLevel
     */
    select?: SchoolLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolLevel
     */
    omit?: SchoolLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLevelInclude<ExtArgs> | null
    /**
     * The filter to search for the SchoolLevel to update in case it exists.
     */
    where: SchoolLevelWhereUniqueInput
    /**
     * In case the SchoolLevel found by the `where` argument doesn't exist, create a new SchoolLevel with this data.
     */
    create: XOR<SchoolLevelCreateInput, SchoolLevelUncheckedCreateInput>
    /**
     * In case the SchoolLevel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolLevelUpdateInput, SchoolLevelUncheckedUpdateInput>
  }

  /**
   * SchoolLevel delete
   */
  export type SchoolLevelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLevel
     */
    select?: SchoolLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolLevel
     */
    omit?: SchoolLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLevelInclude<ExtArgs> | null
    /**
     * Filter which SchoolLevel to delete.
     */
    where: SchoolLevelWhereUniqueInput
  }

  /**
   * SchoolLevel deleteMany
   */
  export type SchoolLevelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolLevels to delete
     */
    where?: SchoolLevelWhereInput
    /**
     * Limit how many SchoolLevels to delete.
     */
    limit?: number
  }

  /**
   * SchoolLevel.classes
   */
  export type SchoolLevel$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * SchoolLevel.subjects
   */
  export type SchoolLevel$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    cursor?: SubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * SchoolLevel without action
   */
  export type SchoolLevelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLevel
     */
    select?: SchoolLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolLevel
     */
    omit?: SchoolLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLevelInclude<ExtArgs> | null
  }


  /**
   * Model UserActivityLog
   */

  export type AggregateUserActivityLog = {
    _count: UserActivityLogCountAggregateOutputType | null
    _min: UserActivityLogMinAggregateOutputType | null
    _max: UserActivityLogMaxAggregateOutputType | null
  }

  export type UserActivityLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    page: string | null
    action: string | null
    createdAt: Date | null
  }

  export type UserActivityLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    page: string | null
    action: string | null
    createdAt: Date | null
  }

  export type UserActivityLogCountAggregateOutputType = {
    id: number
    userId: number
    page: number
    action: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type UserActivityLogMinAggregateInputType = {
    id?: true
    userId?: true
    page?: true
    action?: true
    createdAt?: true
  }

  export type UserActivityLogMaxAggregateInputType = {
    id?: true
    userId?: true
    page?: true
    action?: true
    createdAt?: true
  }

  export type UserActivityLogCountAggregateInputType = {
    id?: true
    userId?: true
    page?: true
    action?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type UserActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserActivityLog to aggregate.
     */
    where?: UserActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActivityLogs to fetch.
     */
    orderBy?: UserActivityLogOrderByWithRelationInput | UserActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserActivityLogs
    **/
    _count?: true | UserActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserActivityLogMaxAggregateInputType
  }

  export type GetUserActivityLogAggregateType<T extends UserActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateUserActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserActivityLog[P]>
      : GetScalarType<T[P], AggregateUserActivityLog[P]>
  }




  export type UserActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserActivityLogWhereInput
    orderBy?: UserActivityLogOrderByWithAggregationInput | UserActivityLogOrderByWithAggregationInput[]
    by: UserActivityLogScalarFieldEnum[] | UserActivityLogScalarFieldEnum
    having?: UserActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserActivityLogCountAggregateInputType | true
    _min?: UserActivityLogMinAggregateInputType
    _max?: UserActivityLogMaxAggregateInputType
  }

  export type UserActivityLogGroupByOutputType = {
    id: string
    userId: string
    page: string
    action: string
    metadata: JsonValue | null
    createdAt: Date
    _count: UserActivityLogCountAggregateOutputType | null
    _min: UserActivityLogMinAggregateOutputType | null
    _max: UserActivityLogMaxAggregateOutputType | null
  }

  type GetUserActivityLogGroupByPayload<T extends UserActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], UserActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type UserActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    page?: boolean
    action?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userActivityLog"]>

  export type UserActivityLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    page?: boolean
    action?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userActivityLog"]>

  export type UserActivityLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    page?: boolean
    action?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userActivityLog"]>

  export type UserActivityLogSelectScalar = {
    id?: boolean
    userId?: boolean
    page?: boolean
    action?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type UserActivityLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "page" | "action" | "metadata" | "createdAt", ExtArgs["result"]["userActivityLog"]>
  export type UserActivityLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserActivityLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserActivityLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserActivityLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      page: string
      action: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["userActivityLog"]>
    composites: {}
  }

  type UserActivityLogGetPayload<S extends boolean | null | undefined | UserActivityLogDefaultArgs> = $Result.GetResult<Prisma.$UserActivityLogPayload, S>

  type UserActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserActivityLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserActivityLogCountAggregateInputType | true
    }

  export interface UserActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserActivityLog'], meta: { name: 'UserActivityLog' } }
    /**
     * Find zero or one UserActivityLog that matches the filter.
     * @param {UserActivityLogFindUniqueArgs} args - Arguments to find a UserActivityLog
     * @example
     * // Get one UserActivityLog
     * const userActivityLog = await prisma.userActivityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserActivityLogFindUniqueArgs>(args: SelectSubset<T, UserActivityLogFindUniqueArgs<ExtArgs>>): Prisma__UserActivityLogClient<$Result.GetResult<Prisma.$UserActivityLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserActivityLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserActivityLogFindUniqueOrThrowArgs} args - Arguments to find a UserActivityLog
     * @example
     * // Get one UserActivityLog
     * const userActivityLog = await prisma.userActivityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, UserActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserActivityLogClient<$Result.GetResult<Prisma.$UserActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityLogFindFirstArgs} args - Arguments to find a UserActivityLog
     * @example
     * // Get one UserActivityLog
     * const userActivityLog = await prisma.userActivityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserActivityLogFindFirstArgs>(args?: SelectSubset<T, UserActivityLogFindFirstArgs<ExtArgs>>): Prisma__UserActivityLogClient<$Result.GetResult<Prisma.$UserActivityLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityLogFindFirstOrThrowArgs} args - Arguments to find a UserActivityLog
     * @example
     * // Get one UserActivityLog
     * const userActivityLog = await prisma.userActivityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, UserActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserActivityLogClient<$Result.GetResult<Prisma.$UserActivityLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserActivityLogs
     * const userActivityLogs = await prisma.userActivityLog.findMany()
     * 
     * // Get first 10 UserActivityLogs
     * const userActivityLogs = await prisma.userActivityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userActivityLogWithIdOnly = await prisma.userActivityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserActivityLogFindManyArgs>(args?: SelectSubset<T, UserActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserActivityLog.
     * @param {UserActivityLogCreateArgs} args - Arguments to create a UserActivityLog.
     * @example
     * // Create one UserActivityLog
     * const UserActivityLog = await prisma.userActivityLog.create({
     *   data: {
     *     // ... data to create a UserActivityLog
     *   }
     * })
     * 
     */
    create<T extends UserActivityLogCreateArgs>(args: SelectSubset<T, UserActivityLogCreateArgs<ExtArgs>>): Prisma__UserActivityLogClient<$Result.GetResult<Prisma.$UserActivityLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserActivityLogs.
     * @param {UserActivityLogCreateManyArgs} args - Arguments to create many UserActivityLogs.
     * @example
     * // Create many UserActivityLogs
     * const userActivityLog = await prisma.userActivityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserActivityLogCreateManyArgs>(args?: SelectSubset<T, UserActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserActivityLogs and returns the data saved in the database.
     * @param {UserActivityLogCreateManyAndReturnArgs} args - Arguments to create many UserActivityLogs.
     * @example
     * // Create many UserActivityLogs
     * const userActivityLog = await prisma.userActivityLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserActivityLogs and only return the `id`
     * const userActivityLogWithIdOnly = await prisma.userActivityLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserActivityLogCreateManyAndReturnArgs>(args?: SelectSubset<T, UserActivityLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserActivityLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserActivityLog.
     * @param {UserActivityLogDeleteArgs} args - Arguments to delete one UserActivityLog.
     * @example
     * // Delete one UserActivityLog
     * const UserActivityLog = await prisma.userActivityLog.delete({
     *   where: {
     *     // ... filter to delete one UserActivityLog
     *   }
     * })
     * 
     */
    delete<T extends UserActivityLogDeleteArgs>(args: SelectSubset<T, UserActivityLogDeleteArgs<ExtArgs>>): Prisma__UserActivityLogClient<$Result.GetResult<Prisma.$UserActivityLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserActivityLog.
     * @param {UserActivityLogUpdateArgs} args - Arguments to update one UserActivityLog.
     * @example
     * // Update one UserActivityLog
     * const userActivityLog = await prisma.userActivityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserActivityLogUpdateArgs>(args: SelectSubset<T, UserActivityLogUpdateArgs<ExtArgs>>): Prisma__UserActivityLogClient<$Result.GetResult<Prisma.$UserActivityLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserActivityLogs.
     * @param {UserActivityLogDeleteManyArgs} args - Arguments to filter UserActivityLogs to delete.
     * @example
     * // Delete a few UserActivityLogs
     * const { count } = await prisma.userActivityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserActivityLogDeleteManyArgs>(args?: SelectSubset<T, UserActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserActivityLogs
     * const userActivityLog = await prisma.userActivityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserActivityLogUpdateManyArgs>(args: SelectSubset<T, UserActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserActivityLogs and returns the data updated in the database.
     * @param {UserActivityLogUpdateManyAndReturnArgs} args - Arguments to update many UserActivityLogs.
     * @example
     * // Update many UserActivityLogs
     * const userActivityLog = await prisma.userActivityLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserActivityLogs and only return the `id`
     * const userActivityLogWithIdOnly = await prisma.userActivityLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserActivityLogUpdateManyAndReturnArgs>(args: SelectSubset<T, UserActivityLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserActivityLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserActivityLog.
     * @param {UserActivityLogUpsertArgs} args - Arguments to update or create a UserActivityLog.
     * @example
     * // Update or create a UserActivityLog
     * const userActivityLog = await prisma.userActivityLog.upsert({
     *   create: {
     *     // ... data to create a UserActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends UserActivityLogUpsertArgs>(args: SelectSubset<T, UserActivityLogUpsertArgs<ExtArgs>>): Prisma__UserActivityLogClient<$Result.GetResult<Prisma.$UserActivityLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityLogCountArgs} args - Arguments to filter UserActivityLogs to count.
     * @example
     * // Count the number of UserActivityLogs
     * const count = await prisma.userActivityLog.count({
     *   where: {
     *     // ... the filter for the UserActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends UserActivityLogCountArgs>(
      args?: Subset<T, UserActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserActivityLogAggregateArgs>(args: Subset<T, UserActivityLogAggregateArgs>): Prisma.PrismaPromise<GetUserActivityLogAggregateType<T>>

    /**
     * Group by UserActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: UserActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserActivityLog model
   */
  readonly fields: UserActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserActivityLog model
   */ 
  interface UserActivityLogFieldRefs {
    readonly id: FieldRef<"UserActivityLog", 'String'>
    readonly userId: FieldRef<"UserActivityLog", 'String'>
    readonly page: FieldRef<"UserActivityLog", 'String'>
    readonly action: FieldRef<"UserActivityLog", 'String'>
    readonly metadata: FieldRef<"UserActivityLog", 'Json'>
    readonly createdAt: FieldRef<"UserActivityLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserActivityLog findUnique
   */
  export type UserActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivityLog
     */
    select?: UserActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivityLog
     */
    omit?: UserActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which UserActivityLog to fetch.
     */
    where: UserActivityLogWhereUniqueInput
  }

  /**
   * UserActivityLog findUniqueOrThrow
   */
  export type UserActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivityLog
     */
    select?: UserActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivityLog
     */
    omit?: UserActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which UserActivityLog to fetch.
     */
    where: UserActivityLogWhereUniqueInput
  }

  /**
   * UserActivityLog findFirst
   */
  export type UserActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivityLog
     */
    select?: UserActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivityLog
     */
    omit?: UserActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which UserActivityLog to fetch.
     */
    where?: UserActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActivityLogs to fetch.
     */
    orderBy?: UserActivityLogOrderByWithRelationInput | UserActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserActivityLogs.
     */
    cursor?: UserActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserActivityLogs.
     */
    distinct?: UserActivityLogScalarFieldEnum | UserActivityLogScalarFieldEnum[]
  }

  /**
   * UserActivityLog findFirstOrThrow
   */
  export type UserActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivityLog
     */
    select?: UserActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivityLog
     */
    omit?: UserActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which UserActivityLog to fetch.
     */
    where?: UserActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActivityLogs to fetch.
     */
    orderBy?: UserActivityLogOrderByWithRelationInput | UserActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserActivityLogs.
     */
    cursor?: UserActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserActivityLogs.
     */
    distinct?: UserActivityLogScalarFieldEnum | UserActivityLogScalarFieldEnum[]
  }

  /**
   * UserActivityLog findMany
   */
  export type UserActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivityLog
     */
    select?: UserActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivityLog
     */
    omit?: UserActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which UserActivityLogs to fetch.
     */
    where?: UserActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActivityLogs to fetch.
     */
    orderBy?: UserActivityLogOrderByWithRelationInput | UserActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserActivityLogs.
     */
    cursor?: UserActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActivityLogs.
     */
    skip?: number
    distinct?: UserActivityLogScalarFieldEnum | UserActivityLogScalarFieldEnum[]
  }

  /**
   * UserActivityLog create
   */
  export type UserActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivityLog
     */
    select?: UserActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivityLog
     */
    omit?: UserActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to create a UserActivityLog.
     */
    data: XOR<UserActivityLogCreateInput, UserActivityLogUncheckedCreateInput>
  }

  /**
   * UserActivityLog createMany
   */
  export type UserActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserActivityLogs.
     */
    data: UserActivityLogCreateManyInput | UserActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserActivityLog createManyAndReturn
   */
  export type UserActivityLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivityLog
     */
    select?: UserActivityLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivityLog
     */
    omit?: UserActivityLogOmit<ExtArgs> | null
    /**
     * The data used to create many UserActivityLogs.
     */
    data: UserActivityLogCreateManyInput | UserActivityLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserActivityLog update
   */
  export type UserActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivityLog
     */
    select?: UserActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivityLog
     */
    omit?: UserActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to update a UserActivityLog.
     */
    data: XOR<UserActivityLogUpdateInput, UserActivityLogUncheckedUpdateInput>
    /**
     * Choose, which UserActivityLog to update.
     */
    where: UserActivityLogWhereUniqueInput
  }

  /**
   * UserActivityLog updateMany
   */
  export type UserActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserActivityLogs.
     */
    data: XOR<UserActivityLogUpdateManyMutationInput, UserActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which UserActivityLogs to update
     */
    where?: UserActivityLogWhereInput
    /**
     * Limit how many UserActivityLogs to update.
     */
    limit?: number
  }

  /**
   * UserActivityLog updateManyAndReturn
   */
  export type UserActivityLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivityLog
     */
    select?: UserActivityLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivityLog
     */
    omit?: UserActivityLogOmit<ExtArgs> | null
    /**
     * The data used to update UserActivityLogs.
     */
    data: XOR<UserActivityLogUpdateManyMutationInput, UserActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which UserActivityLogs to update
     */
    where?: UserActivityLogWhereInput
    /**
     * Limit how many UserActivityLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserActivityLog upsert
   */
  export type UserActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivityLog
     */
    select?: UserActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivityLog
     */
    omit?: UserActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityLogInclude<ExtArgs> | null
    /**
     * The filter to search for the UserActivityLog to update in case it exists.
     */
    where: UserActivityLogWhereUniqueInput
    /**
     * In case the UserActivityLog found by the `where` argument doesn't exist, create a new UserActivityLog with this data.
     */
    create: XOR<UserActivityLogCreateInput, UserActivityLogUncheckedCreateInput>
    /**
     * In case the UserActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserActivityLogUpdateInput, UserActivityLogUncheckedUpdateInput>
  }

  /**
   * UserActivityLog delete
   */
  export type UserActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivityLog
     */
    select?: UserActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivityLog
     */
    omit?: UserActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityLogInclude<ExtArgs> | null
    /**
     * Filter which UserActivityLog to delete.
     */
    where: UserActivityLogWhereUniqueInput
  }

  /**
   * UserActivityLog deleteMany
   */
  export type UserActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserActivityLogs to delete
     */
    where?: UserActivityLogWhereInput
    /**
     * Limit how many UserActivityLogs to delete.
     */
    limit?: number
  }

  /**
   * UserActivityLog without action
   */
  export type UserActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivityLog
     */
    select?: UserActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivityLog
     */
    omit?: UserActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityLogInclude<ExtArgs> | null
  }


  /**
   * Model ApiRequestLog
   */

  export type AggregateApiRequestLog = {
    _count: ApiRequestLogCountAggregateOutputType | null
    _avg: ApiRequestLogAvgAggregateOutputType | null
    _sum: ApiRequestLogSumAggregateOutputType | null
    _min: ApiRequestLogMinAggregateOutputType | null
    _max: ApiRequestLogMaxAggregateOutputType | null
  }

  export type ApiRequestLogAvgAggregateOutputType = {
    status: number | null
    duration: number | null
  }

  export type ApiRequestLogSumAggregateOutputType = {
    status: number | null
    duration: number | null
  }

  export type ApiRequestLogMinAggregateOutputType = {
    id: string | null
    route: string | null
    method: string | null
    status: number | null
    duration: number | null
    createdAt: Date | null
  }

  export type ApiRequestLogMaxAggregateOutputType = {
    id: string | null
    route: string | null
    method: string | null
    status: number | null
    duration: number | null
    createdAt: Date | null
  }

  export type ApiRequestLogCountAggregateOutputType = {
    id: number
    route: number
    method: number
    status: number
    duration: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type ApiRequestLogAvgAggregateInputType = {
    status?: true
    duration?: true
  }

  export type ApiRequestLogSumAggregateInputType = {
    status?: true
    duration?: true
  }

  export type ApiRequestLogMinAggregateInputType = {
    id?: true
    route?: true
    method?: true
    status?: true
    duration?: true
    createdAt?: true
  }

  export type ApiRequestLogMaxAggregateInputType = {
    id?: true
    route?: true
    method?: true
    status?: true
    duration?: true
    createdAt?: true
  }

  export type ApiRequestLogCountAggregateInputType = {
    id?: true
    route?: true
    method?: true
    status?: true
    duration?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type ApiRequestLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiRequestLog to aggregate.
     */
    where?: ApiRequestLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiRequestLogs to fetch.
     */
    orderBy?: ApiRequestLogOrderByWithRelationInput | ApiRequestLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiRequestLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiRequestLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiRequestLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiRequestLogs
    **/
    _count?: true | ApiRequestLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApiRequestLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApiRequestLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiRequestLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiRequestLogMaxAggregateInputType
  }

  export type GetApiRequestLogAggregateType<T extends ApiRequestLogAggregateArgs> = {
        [P in keyof T & keyof AggregateApiRequestLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiRequestLog[P]>
      : GetScalarType<T[P], AggregateApiRequestLog[P]>
  }




  export type ApiRequestLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiRequestLogWhereInput
    orderBy?: ApiRequestLogOrderByWithAggregationInput | ApiRequestLogOrderByWithAggregationInput[]
    by: ApiRequestLogScalarFieldEnum[] | ApiRequestLogScalarFieldEnum
    having?: ApiRequestLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiRequestLogCountAggregateInputType | true
    _avg?: ApiRequestLogAvgAggregateInputType
    _sum?: ApiRequestLogSumAggregateInputType
    _min?: ApiRequestLogMinAggregateInputType
    _max?: ApiRequestLogMaxAggregateInputType
  }

  export type ApiRequestLogGroupByOutputType = {
    id: string
    route: string
    method: string
    status: number
    duration: number
    metadata: JsonValue | null
    createdAt: Date
    _count: ApiRequestLogCountAggregateOutputType | null
    _avg: ApiRequestLogAvgAggregateOutputType | null
    _sum: ApiRequestLogSumAggregateOutputType | null
    _min: ApiRequestLogMinAggregateOutputType | null
    _max: ApiRequestLogMaxAggregateOutputType | null
  }

  type GetApiRequestLogGroupByPayload<T extends ApiRequestLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiRequestLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiRequestLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiRequestLogGroupByOutputType[P]>
            : GetScalarType<T[P], ApiRequestLogGroupByOutputType[P]>
        }
      >
    >


  export type ApiRequestLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    route?: boolean
    method?: boolean
    status?: boolean
    duration?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["apiRequestLog"]>

  export type ApiRequestLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    route?: boolean
    method?: boolean
    status?: boolean
    duration?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["apiRequestLog"]>

  export type ApiRequestLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    route?: boolean
    method?: boolean
    status?: boolean
    duration?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["apiRequestLog"]>

  export type ApiRequestLogSelectScalar = {
    id?: boolean
    route?: boolean
    method?: boolean
    status?: boolean
    duration?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type ApiRequestLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "route" | "method" | "status" | "duration" | "metadata" | "createdAt", ExtArgs["result"]["apiRequestLog"]>

  export type $ApiRequestLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiRequestLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      route: string
      method: string
      status: number
      duration: number
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["apiRequestLog"]>
    composites: {}
  }

  type ApiRequestLogGetPayload<S extends boolean | null | undefined | ApiRequestLogDefaultArgs> = $Result.GetResult<Prisma.$ApiRequestLogPayload, S>

  type ApiRequestLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApiRequestLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApiRequestLogCountAggregateInputType | true
    }

  export interface ApiRequestLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiRequestLog'], meta: { name: 'ApiRequestLog' } }
    /**
     * Find zero or one ApiRequestLog that matches the filter.
     * @param {ApiRequestLogFindUniqueArgs} args - Arguments to find a ApiRequestLog
     * @example
     * // Get one ApiRequestLog
     * const apiRequestLog = await prisma.apiRequestLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiRequestLogFindUniqueArgs>(args: SelectSubset<T, ApiRequestLogFindUniqueArgs<ExtArgs>>): Prisma__ApiRequestLogClient<$Result.GetResult<Prisma.$ApiRequestLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApiRequestLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApiRequestLogFindUniqueOrThrowArgs} args - Arguments to find a ApiRequestLog
     * @example
     * // Get one ApiRequestLog
     * const apiRequestLog = await prisma.apiRequestLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiRequestLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiRequestLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiRequestLogClient<$Result.GetResult<Prisma.$ApiRequestLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiRequestLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiRequestLogFindFirstArgs} args - Arguments to find a ApiRequestLog
     * @example
     * // Get one ApiRequestLog
     * const apiRequestLog = await prisma.apiRequestLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiRequestLogFindFirstArgs>(args?: SelectSubset<T, ApiRequestLogFindFirstArgs<ExtArgs>>): Prisma__ApiRequestLogClient<$Result.GetResult<Prisma.$ApiRequestLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiRequestLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiRequestLogFindFirstOrThrowArgs} args - Arguments to find a ApiRequestLog
     * @example
     * // Get one ApiRequestLog
     * const apiRequestLog = await prisma.apiRequestLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiRequestLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiRequestLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiRequestLogClient<$Result.GetResult<Prisma.$ApiRequestLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApiRequestLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiRequestLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiRequestLogs
     * const apiRequestLogs = await prisma.apiRequestLog.findMany()
     * 
     * // Get first 10 ApiRequestLogs
     * const apiRequestLogs = await prisma.apiRequestLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiRequestLogWithIdOnly = await prisma.apiRequestLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiRequestLogFindManyArgs>(args?: SelectSubset<T, ApiRequestLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiRequestLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApiRequestLog.
     * @param {ApiRequestLogCreateArgs} args - Arguments to create a ApiRequestLog.
     * @example
     * // Create one ApiRequestLog
     * const ApiRequestLog = await prisma.apiRequestLog.create({
     *   data: {
     *     // ... data to create a ApiRequestLog
     *   }
     * })
     * 
     */
    create<T extends ApiRequestLogCreateArgs>(args: SelectSubset<T, ApiRequestLogCreateArgs<ExtArgs>>): Prisma__ApiRequestLogClient<$Result.GetResult<Prisma.$ApiRequestLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApiRequestLogs.
     * @param {ApiRequestLogCreateManyArgs} args - Arguments to create many ApiRequestLogs.
     * @example
     * // Create many ApiRequestLogs
     * const apiRequestLog = await prisma.apiRequestLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiRequestLogCreateManyArgs>(args?: SelectSubset<T, ApiRequestLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiRequestLogs and returns the data saved in the database.
     * @param {ApiRequestLogCreateManyAndReturnArgs} args - Arguments to create many ApiRequestLogs.
     * @example
     * // Create many ApiRequestLogs
     * const apiRequestLog = await prisma.apiRequestLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiRequestLogs and only return the `id`
     * const apiRequestLogWithIdOnly = await prisma.apiRequestLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiRequestLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiRequestLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiRequestLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ApiRequestLog.
     * @param {ApiRequestLogDeleteArgs} args - Arguments to delete one ApiRequestLog.
     * @example
     * // Delete one ApiRequestLog
     * const ApiRequestLog = await prisma.apiRequestLog.delete({
     *   where: {
     *     // ... filter to delete one ApiRequestLog
     *   }
     * })
     * 
     */
    delete<T extends ApiRequestLogDeleteArgs>(args: SelectSubset<T, ApiRequestLogDeleteArgs<ExtArgs>>): Prisma__ApiRequestLogClient<$Result.GetResult<Prisma.$ApiRequestLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApiRequestLog.
     * @param {ApiRequestLogUpdateArgs} args - Arguments to update one ApiRequestLog.
     * @example
     * // Update one ApiRequestLog
     * const apiRequestLog = await prisma.apiRequestLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiRequestLogUpdateArgs>(args: SelectSubset<T, ApiRequestLogUpdateArgs<ExtArgs>>): Prisma__ApiRequestLogClient<$Result.GetResult<Prisma.$ApiRequestLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApiRequestLogs.
     * @param {ApiRequestLogDeleteManyArgs} args - Arguments to filter ApiRequestLogs to delete.
     * @example
     * // Delete a few ApiRequestLogs
     * const { count } = await prisma.apiRequestLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiRequestLogDeleteManyArgs>(args?: SelectSubset<T, ApiRequestLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiRequestLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiRequestLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiRequestLogs
     * const apiRequestLog = await prisma.apiRequestLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiRequestLogUpdateManyArgs>(args: SelectSubset<T, ApiRequestLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiRequestLogs and returns the data updated in the database.
     * @param {ApiRequestLogUpdateManyAndReturnArgs} args - Arguments to update many ApiRequestLogs.
     * @example
     * // Update many ApiRequestLogs
     * const apiRequestLog = await prisma.apiRequestLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ApiRequestLogs and only return the `id`
     * const apiRequestLogWithIdOnly = await prisma.apiRequestLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApiRequestLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ApiRequestLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiRequestLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ApiRequestLog.
     * @param {ApiRequestLogUpsertArgs} args - Arguments to update or create a ApiRequestLog.
     * @example
     * // Update or create a ApiRequestLog
     * const apiRequestLog = await prisma.apiRequestLog.upsert({
     *   create: {
     *     // ... data to create a ApiRequestLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiRequestLog we want to update
     *   }
     * })
     */
    upsert<T extends ApiRequestLogUpsertArgs>(args: SelectSubset<T, ApiRequestLogUpsertArgs<ExtArgs>>): Prisma__ApiRequestLogClient<$Result.GetResult<Prisma.$ApiRequestLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ApiRequestLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiRequestLogCountArgs} args - Arguments to filter ApiRequestLogs to count.
     * @example
     * // Count the number of ApiRequestLogs
     * const count = await prisma.apiRequestLog.count({
     *   where: {
     *     // ... the filter for the ApiRequestLogs we want to count
     *   }
     * })
    **/
    count<T extends ApiRequestLogCountArgs>(
      args?: Subset<T, ApiRequestLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiRequestLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiRequestLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiRequestLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiRequestLogAggregateArgs>(args: Subset<T, ApiRequestLogAggregateArgs>): Prisma.PrismaPromise<GetApiRequestLogAggregateType<T>>

    /**
     * Group by ApiRequestLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiRequestLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiRequestLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiRequestLogGroupByArgs['orderBy'] }
        : { orderBy?: ApiRequestLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiRequestLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiRequestLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiRequestLog model
   */
  readonly fields: ApiRequestLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiRequestLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiRequestLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiRequestLog model
   */ 
  interface ApiRequestLogFieldRefs {
    readonly id: FieldRef<"ApiRequestLog", 'String'>
    readonly route: FieldRef<"ApiRequestLog", 'String'>
    readonly method: FieldRef<"ApiRequestLog", 'String'>
    readonly status: FieldRef<"ApiRequestLog", 'Int'>
    readonly duration: FieldRef<"ApiRequestLog", 'Int'>
    readonly metadata: FieldRef<"ApiRequestLog", 'Json'>
    readonly createdAt: FieldRef<"ApiRequestLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiRequestLog findUnique
   */
  export type ApiRequestLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiRequestLog
     */
    select?: ApiRequestLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiRequestLog
     */
    omit?: ApiRequestLogOmit<ExtArgs> | null
    /**
     * Filter, which ApiRequestLog to fetch.
     */
    where: ApiRequestLogWhereUniqueInput
  }

  /**
   * ApiRequestLog findUniqueOrThrow
   */
  export type ApiRequestLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiRequestLog
     */
    select?: ApiRequestLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiRequestLog
     */
    omit?: ApiRequestLogOmit<ExtArgs> | null
    /**
     * Filter, which ApiRequestLog to fetch.
     */
    where: ApiRequestLogWhereUniqueInput
  }

  /**
   * ApiRequestLog findFirst
   */
  export type ApiRequestLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiRequestLog
     */
    select?: ApiRequestLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiRequestLog
     */
    omit?: ApiRequestLogOmit<ExtArgs> | null
    /**
     * Filter, which ApiRequestLog to fetch.
     */
    where?: ApiRequestLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiRequestLogs to fetch.
     */
    orderBy?: ApiRequestLogOrderByWithRelationInput | ApiRequestLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiRequestLogs.
     */
    cursor?: ApiRequestLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiRequestLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiRequestLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiRequestLogs.
     */
    distinct?: ApiRequestLogScalarFieldEnum | ApiRequestLogScalarFieldEnum[]
  }

  /**
   * ApiRequestLog findFirstOrThrow
   */
  export type ApiRequestLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiRequestLog
     */
    select?: ApiRequestLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiRequestLog
     */
    omit?: ApiRequestLogOmit<ExtArgs> | null
    /**
     * Filter, which ApiRequestLog to fetch.
     */
    where?: ApiRequestLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiRequestLogs to fetch.
     */
    orderBy?: ApiRequestLogOrderByWithRelationInput | ApiRequestLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiRequestLogs.
     */
    cursor?: ApiRequestLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiRequestLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiRequestLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiRequestLogs.
     */
    distinct?: ApiRequestLogScalarFieldEnum | ApiRequestLogScalarFieldEnum[]
  }

  /**
   * ApiRequestLog findMany
   */
  export type ApiRequestLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiRequestLog
     */
    select?: ApiRequestLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiRequestLog
     */
    omit?: ApiRequestLogOmit<ExtArgs> | null
    /**
     * Filter, which ApiRequestLogs to fetch.
     */
    where?: ApiRequestLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiRequestLogs to fetch.
     */
    orderBy?: ApiRequestLogOrderByWithRelationInput | ApiRequestLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiRequestLogs.
     */
    cursor?: ApiRequestLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiRequestLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiRequestLogs.
     */
    skip?: number
    distinct?: ApiRequestLogScalarFieldEnum | ApiRequestLogScalarFieldEnum[]
  }

  /**
   * ApiRequestLog create
   */
  export type ApiRequestLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiRequestLog
     */
    select?: ApiRequestLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiRequestLog
     */
    omit?: ApiRequestLogOmit<ExtArgs> | null
    /**
     * The data needed to create a ApiRequestLog.
     */
    data: XOR<ApiRequestLogCreateInput, ApiRequestLogUncheckedCreateInput>
  }

  /**
   * ApiRequestLog createMany
   */
  export type ApiRequestLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiRequestLogs.
     */
    data: ApiRequestLogCreateManyInput | ApiRequestLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiRequestLog createManyAndReturn
   */
  export type ApiRequestLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiRequestLog
     */
    select?: ApiRequestLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiRequestLog
     */
    omit?: ApiRequestLogOmit<ExtArgs> | null
    /**
     * The data used to create many ApiRequestLogs.
     */
    data: ApiRequestLogCreateManyInput | ApiRequestLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiRequestLog update
   */
  export type ApiRequestLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiRequestLog
     */
    select?: ApiRequestLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiRequestLog
     */
    omit?: ApiRequestLogOmit<ExtArgs> | null
    /**
     * The data needed to update a ApiRequestLog.
     */
    data: XOR<ApiRequestLogUpdateInput, ApiRequestLogUncheckedUpdateInput>
    /**
     * Choose, which ApiRequestLog to update.
     */
    where: ApiRequestLogWhereUniqueInput
  }

  /**
   * ApiRequestLog updateMany
   */
  export type ApiRequestLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiRequestLogs.
     */
    data: XOR<ApiRequestLogUpdateManyMutationInput, ApiRequestLogUncheckedUpdateManyInput>
    /**
     * Filter which ApiRequestLogs to update
     */
    where?: ApiRequestLogWhereInput
    /**
     * Limit how many ApiRequestLogs to update.
     */
    limit?: number
  }

  /**
   * ApiRequestLog updateManyAndReturn
   */
  export type ApiRequestLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiRequestLog
     */
    select?: ApiRequestLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiRequestLog
     */
    omit?: ApiRequestLogOmit<ExtArgs> | null
    /**
     * The data used to update ApiRequestLogs.
     */
    data: XOR<ApiRequestLogUpdateManyMutationInput, ApiRequestLogUncheckedUpdateManyInput>
    /**
     * Filter which ApiRequestLogs to update
     */
    where?: ApiRequestLogWhereInput
    /**
     * Limit how many ApiRequestLogs to update.
     */
    limit?: number
  }

  /**
   * ApiRequestLog upsert
   */
  export type ApiRequestLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiRequestLog
     */
    select?: ApiRequestLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiRequestLog
     */
    omit?: ApiRequestLogOmit<ExtArgs> | null
    /**
     * The filter to search for the ApiRequestLog to update in case it exists.
     */
    where: ApiRequestLogWhereUniqueInput
    /**
     * In case the ApiRequestLog found by the `where` argument doesn't exist, create a new ApiRequestLog with this data.
     */
    create: XOR<ApiRequestLogCreateInput, ApiRequestLogUncheckedCreateInput>
    /**
     * In case the ApiRequestLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiRequestLogUpdateInput, ApiRequestLogUncheckedUpdateInput>
  }

  /**
   * ApiRequestLog delete
   */
  export type ApiRequestLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiRequestLog
     */
    select?: ApiRequestLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiRequestLog
     */
    omit?: ApiRequestLogOmit<ExtArgs> | null
    /**
     * Filter which ApiRequestLog to delete.
     */
    where: ApiRequestLogWhereUniqueInput
  }

  /**
   * ApiRequestLog deleteMany
   */
  export type ApiRequestLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiRequestLogs to delete
     */
    where?: ApiRequestLogWhereInput
    /**
     * Limit how many ApiRequestLogs to delete.
     */
    limit?: number
  }

  /**
   * ApiRequestLog without action
   */
  export type ApiRequestLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiRequestLog
     */
    select?: ApiRequestLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiRequestLog
     */
    omit?: ApiRequestLogOmit<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model ResultConfiguration
   */

  export type AggregateResultConfiguration = {
    _count: ResultConfigurationCountAggregateOutputType | null
    _min: ResultConfigurationMinAggregateOutputType | null
    _max: ResultConfigurationMaxAggregateOutputType | null
  }

  export type ResultConfigurationMinAggregateOutputType = {
    id: string | null
    schoolId: string | null
    sessionId: string | null
    cumulativeEnabled: boolean | null
    cumulativeMethod: string | null
    showCumulativePerTerm: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResultConfigurationMaxAggregateOutputType = {
    id: string | null
    schoolId: string | null
    sessionId: string | null
    cumulativeEnabled: boolean | null
    cumulativeMethod: string | null
    showCumulativePerTerm: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResultConfigurationCountAggregateOutputType = {
    id: number
    schoolId: number
    sessionId: number
    cumulativeEnabled: number
    cumulativeMethod: number
    showCumulativePerTerm: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ResultConfigurationMinAggregateInputType = {
    id?: true
    schoolId?: true
    sessionId?: true
    cumulativeEnabled?: true
    cumulativeMethod?: true
    showCumulativePerTerm?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResultConfigurationMaxAggregateInputType = {
    id?: true
    schoolId?: true
    sessionId?: true
    cumulativeEnabled?: true
    cumulativeMethod?: true
    showCumulativePerTerm?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResultConfigurationCountAggregateInputType = {
    id?: true
    schoolId?: true
    sessionId?: true
    cumulativeEnabled?: true
    cumulativeMethod?: true
    showCumulativePerTerm?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ResultConfigurationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResultConfiguration to aggregate.
     */
    where?: ResultConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResultConfigurations to fetch.
     */
    orderBy?: ResultConfigurationOrderByWithRelationInput | ResultConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResultConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResultConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResultConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResultConfigurations
    **/
    _count?: true | ResultConfigurationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResultConfigurationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResultConfigurationMaxAggregateInputType
  }

  export type GetResultConfigurationAggregateType<T extends ResultConfigurationAggregateArgs> = {
        [P in keyof T & keyof AggregateResultConfiguration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResultConfiguration[P]>
      : GetScalarType<T[P], AggregateResultConfiguration[P]>
  }




  export type ResultConfigurationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResultConfigurationWhereInput
    orderBy?: ResultConfigurationOrderByWithAggregationInput | ResultConfigurationOrderByWithAggregationInput[]
    by: ResultConfigurationScalarFieldEnum[] | ResultConfigurationScalarFieldEnum
    having?: ResultConfigurationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResultConfigurationCountAggregateInputType | true
    _min?: ResultConfigurationMinAggregateInputType
    _max?: ResultConfigurationMaxAggregateInputType
  }

  export type ResultConfigurationGroupByOutputType = {
    id: string
    schoolId: string
    sessionId: string
    cumulativeEnabled: boolean
    cumulativeMethod: string
    showCumulativePerTerm: boolean
    createdAt: Date
    updatedAt: Date
    _count: ResultConfigurationCountAggregateOutputType | null
    _min: ResultConfigurationMinAggregateOutputType | null
    _max: ResultConfigurationMaxAggregateOutputType | null
  }

  type GetResultConfigurationGroupByPayload<T extends ResultConfigurationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResultConfigurationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResultConfigurationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResultConfigurationGroupByOutputType[P]>
            : GetScalarType<T[P], ResultConfigurationGroupByOutputType[P]>
        }
      >
    >


  export type ResultConfigurationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    sessionId?: boolean
    cumulativeEnabled?: boolean
    cumulativeMethod?: boolean
    showCumulativePerTerm?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    periods?: boolean | ResultConfiguration$periodsArgs<ExtArgs>
    assessmentComponents?: boolean | ResultConfiguration$assessmentComponentsArgs<ExtArgs>
    gradingScale?: boolean | ResultConfiguration$gradingScaleArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    session?: boolean | AcademicSessionDefaultArgs<ExtArgs>
    _count?: boolean | ResultConfigurationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resultConfiguration"]>

  export type ResultConfigurationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    sessionId?: boolean
    cumulativeEnabled?: boolean
    cumulativeMethod?: boolean
    showCumulativePerTerm?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    session?: boolean | AcademicSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resultConfiguration"]>

  export type ResultConfigurationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    sessionId?: boolean
    cumulativeEnabled?: boolean
    cumulativeMethod?: boolean
    showCumulativePerTerm?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    session?: boolean | AcademicSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resultConfiguration"]>

  export type ResultConfigurationSelectScalar = {
    id?: boolean
    schoolId?: boolean
    sessionId?: boolean
    cumulativeEnabled?: boolean
    cumulativeMethod?: boolean
    showCumulativePerTerm?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ResultConfigurationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "schoolId" | "sessionId" | "cumulativeEnabled" | "cumulativeMethod" | "showCumulativePerTerm" | "createdAt" | "updatedAt", ExtArgs["result"]["resultConfiguration"]>
  export type ResultConfigurationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    periods?: boolean | ResultConfiguration$periodsArgs<ExtArgs>
    assessmentComponents?: boolean | ResultConfiguration$assessmentComponentsArgs<ExtArgs>
    gradingScale?: boolean | ResultConfiguration$gradingScaleArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    session?: boolean | AcademicSessionDefaultArgs<ExtArgs>
    _count?: boolean | ResultConfigurationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ResultConfigurationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    session?: boolean | AcademicSessionDefaultArgs<ExtArgs>
  }
  export type ResultConfigurationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    session?: boolean | AcademicSessionDefaultArgs<ExtArgs>
  }

  export type $ResultConfigurationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResultConfiguration"
    objects: {
      periods: Prisma.$ResultPeriodPayload<ExtArgs>[]
      assessmentComponents: Prisma.$AssessmentComponentPayload<ExtArgs>[]
      gradingScale: Prisma.$GradingScalePayload<ExtArgs>[]
      school: Prisma.$SchoolPayload<ExtArgs>
      session: Prisma.$AcademicSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      schoolId: string
      sessionId: string
      cumulativeEnabled: boolean
      cumulativeMethod: string
      showCumulativePerTerm: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["resultConfiguration"]>
    composites: {}
  }

  type ResultConfigurationGetPayload<S extends boolean | null | undefined | ResultConfigurationDefaultArgs> = $Result.GetResult<Prisma.$ResultConfigurationPayload, S>

  type ResultConfigurationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResultConfigurationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResultConfigurationCountAggregateInputType | true
    }

  export interface ResultConfigurationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResultConfiguration'], meta: { name: 'ResultConfiguration' } }
    /**
     * Find zero or one ResultConfiguration that matches the filter.
     * @param {ResultConfigurationFindUniqueArgs} args - Arguments to find a ResultConfiguration
     * @example
     * // Get one ResultConfiguration
     * const resultConfiguration = await prisma.resultConfiguration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResultConfigurationFindUniqueArgs>(args: SelectSubset<T, ResultConfigurationFindUniqueArgs<ExtArgs>>): Prisma__ResultConfigurationClient<$Result.GetResult<Prisma.$ResultConfigurationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ResultConfiguration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResultConfigurationFindUniqueOrThrowArgs} args - Arguments to find a ResultConfiguration
     * @example
     * // Get one ResultConfiguration
     * const resultConfiguration = await prisma.resultConfiguration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResultConfigurationFindUniqueOrThrowArgs>(args: SelectSubset<T, ResultConfigurationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResultConfigurationClient<$Result.GetResult<Prisma.$ResultConfigurationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResultConfiguration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultConfigurationFindFirstArgs} args - Arguments to find a ResultConfiguration
     * @example
     * // Get one ResultConfiguration
     * const resultConfiguration = await prisma.resultConfiguration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResultConfigurationFindFirstArgs>(args?: SelectSubset<T, ResultConfigurationFindFirstArgs<ExtArgs>>): Prisma__ResultConfigurationClient<$Result.GetResult<Prisma.$ResultConfigurationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResultConfiguration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultConfigurationFindFirstOrThrowArgs} args - Arguments to find a ResultConfiguration
     * @example
     * // Get one ResultConfiguration
     * const resultConfiguration = await prisma.resultConfiguration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResultConfigurationFindFirstOrThrowArgs>(args?: SelectSubset<T, ResultConfigurationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResultConfigurationClient<$Result.GetResult<Prisma.$ResultConfigurationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ResultConfigurations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultConfigurationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResultConfigurations
     * const resultConfigurations = await prisma.resultConfiguration.findMany()
     * 
     * // Get first 10 ResultConfigurations
     * const resultConfigurations = await prisma.resultConfiguration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resultConfigurationWithIdOnly = await prisma.resultConfiguration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResultConfigurationFindManyArgs>(args?: SelectSubset<T, ResultConfigurationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultConfigurationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ResultConfiguration.
     * @param {ResultConfigurationCreateArgs} args - Arguments to create a ResultConfiguration.
     * @example
     * // Create one ResultConfiguration
     * const ResultConfiguration = await prisma.resultConfiguration.create({
     *   data: {
     *     // ... data to create a ResultConfiguration
     *   }
     * })
     * 
     */
    create<T extends ResultConfigurationCreateArgs>(args: SelectSubset<T, ResultConfigurationCreateArgs<ExtArgs>>): Prisma__ResultConfigurationClient<$Result.GetResult<Prisma.$ResultConfigurationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ResultConfigurations.
     * @param {ResultConfigurationCreateManyArgs} args - Arguments to create many ResultConfigurations.
     * @example
     * // Create many ResultConfigurations
     * const resultConfiguration = await prisma.resultConfiguration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResultConfigurationCreateManyArgs>(args?: SelectSubset<T, ResultConfigurationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResultConfigurations and returns the data saved in the database.
     * @param {ResultConfigurationCreateManyAndReturnArgs} args - Arguments to create many ResultConfigurations.
     * @example
     * // Create many ResultConfigurations
     * const resultConfiguration = await prisma.resultConfiguration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResultConfigurations and only return the `id`
     * const resultConfigurationWithIdOnly = await prisma.resultConfiguration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResultConfigurationCreateManyAndReturnArgs>(args?: SelectSubset<T, ResultConfigurationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultConfigurationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ResultConfiguration.
     * @param {ResultConfigurationDeleteArgs} args - Arguments to delete one ResultConfiguration.
     * @example
     * // Delete one ResultConfiguration
     * const ResultConfiguration = await prisma.resultConfiguration.delete({
     *   where: {
     *     // ... filter to delete one ResultConfiguration
     *   }
     * })
     * 
     */
    delete<T extends ResultConfigurationDeleteArgs>(args: SelectSubset<T, ResultConfigurationDeleteArgs<ExtArgs>>): Prisma__ResultConfigurationClient<$Result.GetResult<Prisma.$ResultConfigurationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ResultConfiguration.
     * @param {ResultConfigurationUpdateArgs} args - Arguments to update one ResultConfiguration.
     * @example
     * // Update one ResultConfiguration
     * const resultConfiguration = await prisma.resultConfiguration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResultConfigurationUpdateArgs>(args: SelectSubset<T, ResultConfigurationUpdateArgs<ExtArgs>>): Prisma__ResultConfigurationClient<$Result.GetResult<Prisma.$ResultConfigurationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ResultConfigurations.
     * @param {ResultConfigurationDeleteManyArgs} args - Arguments to filter ResultConfigurations to delete.
     * @example
     * // Delete a few ResultConfigurations
     * const { count } = await prisma.resultConfiguration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResultConfigurationDeleteManyArgs>(args?: SelectSubset<T, ResultConfigurationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResultConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultConfigurationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResultConfigurations
     * const resultConfiguration = await prisma.resultConfiguration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResultConfigurationUpdateManyArgs>(args: SelectSubset<T, ResultConfigurationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResultConfigurations and returns the data updated in the database.
     * @param {ResultConfigurationUpdateManyAndReturnArgs} args - Arguments to update many ResultConfigurations.
     * @example
     * // Update many ResultConfigurations
     * const resultConfiguration = await prisma.resultConfiguration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ResultConfigurations and only return the `id`
     * const resultConfigurationWithIdOnly = await prisma.resultConfiguration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResultConfigurationUpdateManyAndReturnArgs>(args: SelectSubset<T, ResultConfigurationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultConfigurationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ResultConfiguration.
     * @param {ResultConfigurationUpsertArgs} args - Arguments to update or create a ResultConfiguration.
     * @example
     * // Update or create a ResultConfiguration
     * const resultConfiguration = await prisma.resultConfiguration.upsert({
     *   create: {
     *     // ... data to create a ResultConfiguration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResultConfiguration we want to update
     *   }
     * })
     */
    upsert<T extends ResultConfigurationUpsertArgs>(args: SelectSubset<T, ResultConfigurationUpsertArgs<ExtArgs>>): Prisma__ResultConfigurationClient<$Result.GetResult<Prisma.$ResultConfigurationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ResultConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultConfigurationCountArgs} args - Arguments to filter ResultConfigurations to count.
     * @example
     * // Count the number of ResultConfigurations
     * const count = await prisma.resultConfiguration.count({
     *   where: {
     *     // ... the filter for the ResultConfigurations we want to count
     *   }
     * })
    **/
    count<T extends ResultConfigurationCountArgs>(
      args?: Subset<T, ResultConfigurationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResultConfigurationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResultConfiguration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultConfigurationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResultConfigurationAggregateArgs>(args: Subset<T, ResultConfigurationAggregateArgs>): Prisma.PrismaPromise<GetResultConfigurationAggregateType<T>>

    /**
     * Group by ResultConfiguration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultConfigurationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResultConfigurationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResultConfigurationGroupByArgs['orderBy'] }
        : { orderBy?: ResultConfigurationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResultConfigurationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResultConfigurationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResultConfiguration model
   */
  readonly fields: ResultConfigurationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResultConfiguration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResultConfigurationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    periods<T extends ResultConfiguration$periodsArgs<ExtArgs> = {}>(args?: Subset<T, ResultConfiguration$periodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultPeriodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assessmentComponents<T extends ResultConfiguration$assessmentComponentsArgs<ExtArgs> = {}>(args?: Subset<T, ResultConfiguration$assessmentComponentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentComponentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gradingScale<T extends ResultConfiguration$gradingScaleArgs<ExtArgs> = {}>(args?: Subset<T, ResultConfiguration$gradingScaleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradingScalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    session<T extends AcademicSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSessionDefaultArgs<ExtArgs>>): Prisma__AcademicSessionClient<$Result.GetResult<Prisma.$AcademicSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResultConfiguration model
   */ 
  interface ResultConfigurationFieldRefs {
    readonly id: FieldRef<"ResultConfiguration", 'String'>
    readonly schoolId: FieldRef<"ResultConfiguration", 'String'>
    readonly sessionId: FieldRef<"ResultConfiguration", 'String'>
    readonly cumulativeEnabled: FieldRef<"ResultConfiguration", 'Boolean'>
    readonly cumulativeMethod: FieldRef<"ResultConfiguration", 'String'>
    readonly showCumulativePerTerm: FieldRef<"ResultConfiguration", 'Boolean'>
    readonly createdAt: FieldRef<"ResultConfiguration", 'DateTime'>
    readonly updatedAt: FieldRef<"ResultConfiguration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ResultConfiguration findUnique
   */
  export type ResultConfigurationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultConfiguration
     */
    select?: ResultConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultConfiguration
     */
    omit?: ResultConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which ResultConfiguration to fetch.
     */
    where: ResultConfigurationWhereUniqueInput
  }

  /**
   * ResultConfiguration findUniqueOrThrow
   */
  export type ResultConfigurationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultConfiguration
     */
    select?: ResultConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultConfiguration
     */
    omit?: ResultConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which ResultConfiguration to fetch.
     */
    where: ResultConfigurationWhereUniqueInput
  }

  /**
   * ResultConfiguration findFirst
   */
  export type ResultConfigurationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultConfiguration
     */
    select?: ResultConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultConfiguration
     */
    omit?: ResultConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which ResultConfiguration to fetch.
     */
    where?: ResultConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResultConfigurations to fetch.
     */
    orderBy?: ResultConfigurationOrderByWithRelationInput | ResultConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResultConfigurations.
     */
    cursor?: ResultConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResultConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResultConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResultConfigurations.
     */
    distinct?: ResultConfigurationScalarFieldEnum | ResultConfigurationScalarFieldEnum[]
  }

  /**
   * ResultConfiguration findFirstOrThrow
   */
  export type ResultConfigurationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultConfiguration
     */
    select?: ResultConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultConfiguration
     */
    omit?: ResultConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which ResultConfiguration to fetch.
     */
    where?: ResultConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResultConfigurations to fetch.
     */
    orderBy?: ResultConfigurationOrderByWithRelationInput | ResultConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResultConfigurations.
     */
    cursor?: ResultConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResultConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResultConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResultConfigurations.
     */
    distinct?: ResultConfigurationScalarFieldEnum | ResultConfigurationScalarFieldEnum[]
  }

  /**
   * ResultConfiguration findMany
   */
  export type ResultConfigurationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultConfiguration
     */
    select?: ResultConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultConfiguration
     */
    omit?: ResultConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which ResultConfigurations to fetch.
     */
    where?: ResultConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResultConfigurations to fetch.
     */
    orderBy?: ResultConfigurationOrderByWithRelationInput | ResultConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResultConfigurations.
     */
    cursor?: ResultConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResultConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResultConfigurations.
     */
    skip?: number
    distinct?: ResultConfigurationScalarFieldEnum | ResultConfigurationScalarFieldEnum[]
  }

  /**
   * ResultConfiguration create
   */
  export type ResultConfigurationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultConfiguration
     */
    select?: ResultConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultConfiguration
     */
    omit?: ResultConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultConfigurationInclude<ExtArgs> | null
    /**
     * The data needed to create a ResultConfiguration.
     */
    data: XOR<ResultConfigurationCreateInput, ResultConfigurationUncheckedCreateInput>
  }

  /**
   * ResultConfiguration createMany
   */
  export type ResultConfigurationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResultConfigurations.
     */
    data: ResultConfigurationCreateManyInput | ResultConfigurationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResultConfiguration createManyAndReturn
   */
  export type ResultConfigurationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultConfiguration
     */
    select?: ResultConfigurationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResultConfiguration
     */
    omit?: ResultConfigurationOmit<ExtArgs> | null
    /**
     * The data used to create many ResultConfigurations.
     */
    data: ResultConfigurationCreateManyInput | ResultConfigurationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultConfigurationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResultConfiguration update
   */
  export type ResultConfigurationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultConfiguration
     */
    select?: ResultConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultConfiguration
     */
    omit?: ResultConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultConfigurationInclude<ExtArgs> | null
    /**
     * The data needed to update a ResultConfiguration.
     */
    data: XOR<ResultConfigurationUpdateInput, ResultConfigurationUncheckedUpdateInput>
    /**
     * Choose, which ResultConfiguration to update.
     */
    where: ResultConfigurationWhereUniqueInput
  }

  /**
   * ResultConfiguration updateMany
   */
  export type ResultConfigurationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResultConfigurations.
     */
    data: XOR<ResultConfigurationUpdateManyMutationInput, ResultConfigurationUncheckedUpdateManyInput>
    /**
     * Filter which ResultConfigurations to update
     */
    where?: ResultConfigurationWhereInput
    /**
     * Limit how many ResultConfigurations to update.
     */
    limit?: number
  }

  /**
   * ResultConfiguration updateManyAndReturn
   */
  export type ResultConfigurationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultConfiguration
     */
    select?: ResultConfigurationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResultConfiguration
     */
    omit?: ResultConfigurationOmit<ExtArgs> | null
    /**
     * The data used to update ResultConfigurations.
     */
    data: XOR<ResultConfigurationUpdateManyMutationInput, ResultConfigurationUncheckedUpdateManyInput>
    /**
     * Filter which ResultConfigurations to update
     */
    where?: ResultConfigurationWhereInput
    /**
     * Limit how many ResultConfigurations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultConfigurationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResultConfiguration upsert
   */
  export type ResultConfigurationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultConfiguration
     */
    select?: ResultConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultConfiguration
     */
    omit?: ResultConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultConfigurationInclude<ExtArgs> | null
    /**
     * The filter to search for the ResultConfiguration to update in case it exists.
     */
    where: ResultConfigurationWhereUniqueInput
    /**
     * In case the ResultConfiguration found by the `where` argument doesn't exist, create a new ResultConfiguration with this data.
     */
    create: XOR<ResultConfigurationCreateInput, ResultConfigurationUncheckedCreateInput>
    /**
     * In case the ResultConfiguration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResultConfigurationUpdateInput, ResultConfigurationUncheckedUpdateInput>
  }

  /**
   * ResultConfiguration delete
   */
  export type ResultConfigurationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultConfiguration
     */
    select?: ResultConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultConfiguration
     */
    omit?: ResultConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultConfigurationInclude<ExtArgs> | null
    /**
     * Filter which ResultConfiguration to delete.
     */
    where: ResultConfigurationWhereUniqueInput
  }

  /**
   * ResultConfiguration deleteMany
   */
  export type ResultConfigurationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResultConfigurations to delete
     */
    where?: ResultConfigurationWhereInput
    /**
     * Limit how many ResultConfigurations to delete.
     */
    limit?: number
  }

  /**
   * ResultConfiguration.periods
   */
  export type ResultConfiguration$periodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultPeriod
     */
    select?: ResultPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultPeriod
     */
    omit?: ResultPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultPeriodInclude<ExtArgs> | null
    where?: ResultPeriodWhereInput
    orderBy?: ResultPeriodOrderByWithRelationInput | ResultPeriodOrderByWithRelationInput[]
    cursor?: ResultPeriodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResultPeriodScalarFieldEnum | ResultPeriodScalarFieldEnum[]
  }

  /**
   * ResultConfiguration.assessmentComponents
   */
  export type ResultConfiguration$assessmentComponentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentComponent
     */
    select?: AssessmentComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentComponent
     */
    omit?: AssessmentComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentComponentInclude<ExtArgs> | null
    where?: AssessmentComponentWhereInput
    orderBy?: AssessmentComponentOrderByWithRelationInput | AssessmentComponentOrderByWithRelationInput[]
    cursor?: AssessmentComponentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssessmentComponentScalarFieldEnum | AssessmentComponentScalarFieldEnum[]
  }

  /**
   * ResultConfiguration.gradingScale
   */
  export type ResultConfiguration$gradingScaleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradingScale
     */
    select?: GradingScaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradingScale
     */
    omit?: GradingScaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingScaleInclude<ExtArgs> | null
    where?: GradingScaleWhereInput
    orderBy?: GradingScaleOrderByWithRelationInput | GradingScaleOrderByWithRelationInput[]
    cursor?: GradingScaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradingScaleScalarFieldEnum | GradingScaleScalarFieldEnum[]
  }

  /**
   * ResultConfiguration without action
   */
  export type ResultConfigurationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultConfiguration
     */
    select?: ResultConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultConfiguration
     */
    omit?: ResultConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultConfigurationInclude<ExtArgs> | null
  }


  /**
   * Model ResultPeriod
   */

  export type AggregateResultPeriod = {
    _count: ResultPeriodCountAggregateOutputType | null
    _avg: ResultPeriodAvgAggregateOutputType | null
    _sum: ResultPeriodSumAggregateOutputType | null
    _min: ResultPeriodMinAggregateOutputType | null
    _max: ResultPeriodMaxAggregateOutputType | null
  }

  export type ResultPeriodAvgAggregateOutputType = {
    weight: number | null
  }

  export type ResultPeriodSumAggregateOutputType = {
    weight: number | null
  }

  export type ResultPeriodMinAggregateOutputType = {
    id: string | null
    name: string | null
    weight: number | null
    configurationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResultPeriodMaxAggregateOutputType = {
    id: string | null
    name: string | null
    weight: number | null
    configurationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResultPeriodCountAggregateOutputType = {
    id: number
    name: number
    weight: number
    configurationId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ResultPeriodAvgAggregateInputType = {
    weight?: true
  }

  export type ResultPeriodSumAggregateInputType = {
    weight?: true
  }

  export type ResultPeriodMinAggregateInputType = {
    id?: true
    name?: true
    weight?: true
    configurationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResultPeriodMaxAggregateInputType = {
    id?: true
    name?: true
    weight?: true
    configurationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResultPeriodCountAggregateInputType = {
    id?: true
    name?: true
    weight?: true
    configurationId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ResultPeriodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResultPeriod to aggregate.
     */
    where?: ResultPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResultPeriods to fetch.
     */
    orderBy?: ResultPeriodOrderByWithRelationInput | ResultPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResultPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResultPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResultPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResultPeriods
    **/
    _count?: true | ResultPeriodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResultPeriodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResultPeriodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResultPeriodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResultPeriodMaxAggregateInputType
  }

  export type GetResultPeriodAggregateType<T extends ResultPeriodAggregateArgs> = {
        [P in keyof T & keyof AggregateResultPeriod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResultPeriod[P]>
      : GetScalarType<T[P], AggregateResultPeriod[P]>
  }




  export type ResultPeriodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResultPeriodWhereInput
    orderBy?: ResultPeriodOrderByWithAggregationInput | ResultPeriodOrderByWithAggregationInput[]
    by: ResultPeriodScalarFieldEnum[] | ResultPeriodScalarFieldEnum
    having?: ResultPeriodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResultPeriodCountAggregateInputType | true
    _avg?: ResultPeriodAvgAggregateInputType
    _sum?: ResultPeriodSumAggregateInputType
    _min?: ResultPeriodMinAggregateInputType
    _max?: ResultPeriodMaxAggregateInputType
  }

  export type ResultPeriodGroupByOutputType = {
    id: string
    name: string
    weight: number
    configurationId: string
    createdAt: Date
    updatedAt: Date
    _count: ResultPeriodCountAggregateOutputType | null
    _avg: ResultPeriodAvgAggregateOutputType | null
    _sum: ResultPeriodSumAggregateOutputType | null
    _min: ResultPeriodMinAggregateOutputType | null
    _max: ResultPeriodMaxAggregateOutputType | null
  }

  type GetResultPeriodGroupByPayload<T extends ResultPeriodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResultPeriodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResultPeriodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResultPeriodGroupByOutputType[P]>
            : GetScalarType<T[P], ResultPeriodGroupByOutputType[P]>
        }
      >
    >


  export type ResultPeriodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    weight?: boolean
    configurationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    configuration?: boolean | ResultConfigurationDefaultArgs<ExtArgs>
    results?: boolean | ResultPeriod$resultsArgs<ExtArgs>
    _count?: boolean | ResultPeriodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resultPeriod"]>

  export type ResultPeriodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    weight?: boolean
    configurationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    configuration?: boolean | ResultConfigurationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resultPeriod"]>

  export type ResultPeriodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    weight?: boolean
    configurationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    configuration?: boolean | ResultConfigurationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resultPeriod"]>

  export type ResultPeriodSelectScalar = {
    id?: boolean
    name?: boolean
    weight?: boolean
    configurationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ResultPeriodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "weight" | "configurationId" | "createdAt" | "updatedAt", ExtArgs["result"]["resultPeriod"]>
  export type ResultPeriodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    configuration?: boolean | ResultConfigurationDefaultArgs<ExtArgs>
    results?: boolean | ResultPeriod$resultsArgs<ExtArgs>
    _count?: boolean | ResultPeriodCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ResultPeriodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    configuration?: boolean | ResultConfigurationDefaultArgs<ExtArgs>
  }
  export type ResultPeriodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    configuration?: boolean | ResultConfigurationDefaultArgs<ExtArgs>
  }

  export type $ResultPeriodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResultPeriod"
    objects: {
      configuration: Prisma.$ResultConfigurationPayload<ExtArgs>
      results: Prisma.$ResultPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      weight: number
      configurationId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["resultPeriod"]>
    composites: {}
  }

  type ResultPeriodGetPayload<S extends boolean | null | undefined | ResultPeriodDefaultArgs> = $Result.GetResult<Prisma.$ResultPeriodPayload, S>

  type ResultPeriodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResultPeriodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResultPeriodCountAggregateInputType | true
    }

  export interface ResultPeriodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResultPeriod'], meta: { name: 'ResultPeriod' } }
    /**
     * Find zero or one ResultPeriod that matches the filter.
     * @param {ResultPeriodFindUniqueArgs} args - Arguments to find a ResultPeriod
     * @example
     * // Get one ResultPeriod
     * const resultPeriod = await prisma.resultPeriod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResultPeriodFindUniqueArgs>(args: SelectSubset<T, ResultPeriodFindUniqueArgs<ExtArgs>>): Prisma__ResultPeriodClient<$Result.GetResult<Prisma.$ResultPeriodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ResultPeriod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResultPeriodFindUniqueOrThrowArgs} args - Arguments to find a ResultPeriod
     * @example
     * // Get one ResultPeriod
     * const resultPeriod = await prisma.resultPeriod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResultPeriodFindUniqueOrThrowArgs>(args: SelectSubset<T, ResultPeriodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResultPeriodClient<$Result.GetResult<Prisma.$ResultPeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResultPeriod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultPeriodFindFirstArgs} args - Arguments to find a ResultPeriod
     * @example
     * // Get one ResultPeriod
     * const resultPeriod = await prisma.resultPeriod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResultPeriodFindFirstArgs>(args?: SelectSubset<T, ResultPeriodFindFirstArgs<ExtArgs>>): Prisma__ResultPeriodClient<$Result.GetResult<Prisma.$ResultPeriodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResultPeriod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultPeriodFindFirstOrThrowArgs} args - Arguments to find a ResultPeriod
     * @example
     * // Get one ResultPeriod
     * const resultPeriod = await prisma.resultPeriod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResultPeriodFindFirstOrThrowArgs>(args?: SelectSubset<T, ResultPeriodFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResultPeriodClient<$Result.GetResult<Prisma.$ResultPeriodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ResultPeriods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultPeriodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResultPeriods
     * const resultPeriods = await prisma.resultPeriod.findMany()
     * 
     * // Get first 10 ResultPeriods
     * const resultPeriods = await prisma.resultPeriod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resultPeriodWithIdOnly = await prisma.resultPeriod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResultPeriodFindManyArgs>(args?: SelectSubset<T, ResultPeriodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultPeriodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ResultPeriod.
     * @param {ResultPeriodCreateArgs} args - Arguments to create a ResultPeriod.
     * @example
     * // Create one ResultPeriod
     * const ResultPeriod = await prisma.resultPeriod.create({
     *   data: {
     *     // ... data to create a ResultPeriod
     *   }
     * })
     * 
     */
    create<T extends ResultPeriodCreateArgs>(args: SelectSubset<T, ResultPeriodCreateArgs<ExtArgs>>): Prisma__ResultPeriodClient<$Result.GetResult<Prisma.$ResultPeriodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ResultPeriods.
     * @param {ResultPeriodCreateManyArgs} args - Arguments to create many ResultPeriods.
     * @example
     * // Create many ResultPeriods
     * const resultPeriod = await prisma.resultPeriod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResultPeriodCreateManyArgs>(args?: SelectSubset<T, ResultPeriodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResultPeriods and returns the data saved in the database.
     * @param {ResultPeriodCreateManyAndReturnArgs} args - Arguments to create many ResultPeriods.
     * @example
     * // Create many ResultPeriods
     * const resultPeriod = await prisma.resultPeriod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResultPeriods and only return the `id`
     * const resultPeriodWithIdOnly = await prisma.resultPeriod.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResultPeriodCreateManyAndReturnArgs>(args?: SelectSubset<T, ResultPeriodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultPeriodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ResultPeriod.
     * @param {ResultPeriodDeleteArgs} args - Arguments to delete one ResultPeriod.
     * @example
     * // Delete one ResultPeriod
     * const ResultPeriod = await prisma.resultPeriod.delete({
     *   where: {
     *     // ... filter to delete one ResultPeriod
     *   }
     * })
     * 
     */
    delete<T extends ResultPeriodDeleteArgs>(args: SelectSubset<T, ResultPeriodDeleteArgs<ExtArgs>>): Prisma__ResultPeriodClient<$Result.GetResult<Prisma.$ResultPeriodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ResultPeriod.
     * @param {ResultPeriodUpdateArgs} args - Arguments to update one ResultPeriod.
     * @example
     * // Update one ResultPeriod
     * const resultPeriod = await prisma.resultPeriod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResultPeriodUpdateArgs>(args: SelectSubset<T, ResultPeriodUpdateArgs<ExtArgs>>): Prisma__ResultPeriodClient<$Result.GetResult<Prisma.$ResultPeriodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ResultPeriods.
     * @param {ResultPeriodDeleteManyArgs} args - Arguments to filter ResultPeriods to delete.
     * @example
     * // Delete a few ResultPeriods
     * const { count } = await prisma.resultPeriod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResultPeriodDeleteManyArgs>(args?: SelectSubset<T, ResultPeriodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResultPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultPeriodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResultPeriods
     * const resultPeriod = await prisma.resultPeriod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResultPeriodUpdateManyArgs>(args: SelectSubset<T, ResultPeriodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResultPeriods and returns the data updated in the database.
     * @param {ResultPeriodUpdateManyAndReturnArgs} args - Arguments to update many ResultPeriods.
     * @example
     * // Update many ResultPeriods
     * const resultPeriod = await prisma.resultPeriod.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ResultPeriods and only return the `id`
     * const resultPeriodWithIdOnly = await prisma.resultPeriod.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResultPeriodUpdateManyAndReturnArgs>(args: SelectSubset<T, ResultPeriodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultPeriodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ResultPeriod.
     * @param {ResultPeriodUpsertArgs} args - Arguments to update or create a ResultPeriod.
     * @example
     * // Update or create a ResultPeriod
     * const resultPeriod = await prisma.resultPeriod.upsert({
     *   create: {
     *     // ... data to create a ResultPeriod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResultPeriod we want to update
     *   }
     * })
     */
    upsert<T extends ResultPeriodUpsertArgs>(args: SelectSubset<T, ResultPeriodUpsertArgs<ExtArgs>>): Prisma__ResultPeriodClient<$Result.GetResult<Prisma.$ResultPeriodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ResultPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultPeriodCountArgs} args - Arguments to filter ResultPeriods to count.
     * @example
     * // Count the number of ResultPeriods
     * const count = await prisma.resultPeriod.count({
     *   where: {
     *     // ... the filter for the ResultPeriods we want to count
     *   }
     * })
    **/
    count<T extends ResultPeriodCountArgs>(
      args?: Subset<T, ResultPeriodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResultPeriodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResultPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultPeriodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResultPeriodAggregateArgs>(args: Subset<T, ResultPeriodAggregateArgs>): Prisma.PrismaPromise<GetResultPeriodAggregateType<T>>

    /**
     * Group by ResultPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultPeriodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResultPeriodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResultPeriodGroupByArgs['orderBy'] }
        : { orderBy?: ResultPeriodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResultPeriodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResultPeriodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResultPeriod model
   */
  readonly fields: ResultPeriodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResultPeriod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResultPeriodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    configuration<T extends ResultConfigurationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResultConfigurationDefaultArgs<ExtArgs>>): Prisma__ResultConfigurationClient<$Result.GetResult<Prisma.$ResultConfigurationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    results<T extends ResultPeriod$resultsArgs<ExtArgs> = {}>(args?: Subset<T, ResultPeriod$resultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResultPeriod model
   */ 
  interface ResultPeriodFieldRefs {
    readonly id: FieldRef<"ResultPeriod", 'String'>
    readonly name: FieldRef<"ResultPeriod", 'String'>
    readonly weight: FieldRef<"ResultPeriod", 'Float'>
    readonly configurationId: FieldRef<"ResultPeriod", 'String'>
    readonly createdAt: FieldRef<"ResultPeriod", 'DateTime'>
    readonly updatedAt: FieldRef<"ResultPeriod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ResultPeriod findUnique
   */
  export type ResultPeriodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultPeriod
     */
    select?: ResultPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultPeriod
     */
    omit?: ResultPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultPeriodInclude<ExtArgs> | null
    /**
     * Filter, which ResultPeriod to fetch.
     */
    where: ResultPeriodWhereUniqueInput
  }

  /**
   * ResultPeriod findUniqueOrThrow
   */
  export type ResultPeriodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultPeriod
     */
    select?: ResultPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultPeriod
     */
    omit?: ResultPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultPeriodInclude<ExtArgs> | null
    /**
     * Filter, which ResultPeriod to fetch.
     */
    where: ResultPeriodWhereUniqueInput
  }

  /**
   * ResultPeriod findFirst
   */
  export type ResultPeriodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultPeriod
     */
    select?: ResultPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultPeriod
     */
    omit?: ResultPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultPeriodInclude<ExtArgs> | null
    /**
     * Filter, which ResultPeriod to fetch.
     */
    where?: ResultPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResultPeriods to fetch.
     */
    orderBy?: ResultPeriodOrderByWithRelationInput | ResultPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResultPeriods.
     */
    cursor?: ResultPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResultPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResultPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResultPeriods.
     */
    distinct?: ResultPeriodScalarFieldEnum | ResultPeriodScalarFieldEnum[]
  }

  /**
   * ResultPeriod findFirstOrThrow
   */
  export type ResultPeriodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultPeriod
     */
    select?: ResultPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultPeriod
     */
    omit?: ResultPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultPeriodInclude<ExtArgs> | null
    /**
     * Filter, which ResultPeriod to fetch.
     */
    where?: ResultPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResultPeriods to fetch.
     */
    orderBy?: ResultPeriodOrderByWithRelationInput | ResultPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResultPeriods.
     */
    cursor?: ResultPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResultPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResultPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResultPeriods.
     */
    distinct?: ResultPeriodScalarFieldEnum | ResultPeriodScalarFieldEnum[]
  }

  /**
   * ResultPeriod findMany
   */
  export type ResultPeriodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultPeriod
     */
    select?: ResultPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultPeriod
     */
    omit?: ResultPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultPeriodInclude<ExtArgs> | null
    /**
     * Filter, which ResultPeriods to fetch.
     */
    where?: ResultPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResultPeriods to fetch.
     */
    orderBy?: ResultPeriodOrderByWithRelationInput | ResultPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResultPeriods.
     */
    cursor?: ResultPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResultPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResultPeriods.
     */
    skip?: number
    distinct?: ResultPeriodScalarFieldEnum | ResultPeriodScalarFieldEnum[]
  }

  /**
   * ResultPeriod create
   */
  export type ResultPeriodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultPeriod
     */
    select?: ResultPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultPeriod
     */
    omit?: ResultPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultPeriodInclude<ExtArgs> | null
    /**
     * The data needed to create a ResultPeriod.
     */
    data: XOR<ResultPeriodCreateInput, ResultPeriodUncheckedCreateInput>
  }

  /**
   * ResultPeriod createMany
   */
  export type ResultPeriodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResultPeriods.
     */
    data: ResultPeriodCreateManyInput | ResultPeriodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResultPeriod createManyAndReturn
   */
  export type ResultPeriodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultPeriod
     */
    select?: ResultPeriodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResultPeriod
     */
    omit?: ResultPeriodOmit<ExtArgs> | null
    /**
     * The data used to create many ResultPeriods.
     */
    data: ResultPeriodCreateManyInput | ResultPeriodCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultPeriodIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResultPeriod update
   */
  export type ResultPeriodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultPeriod
     */
    select?: ResultPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultPeriod
     */
    omit?: ResultPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultPeriodInclude<ExtArgs> | null
    /**
     * The data needed to update a ResultPeriod.
     */
    data: XOR<ResultPeriodUpdateInput, ResultPeriodUncheckedUpdateInput>
    /**
     * Choose, which ResultPeriod to update.
     */
    where: ResultPeriodWhereUniqueInput
  }

  /**
   * ResultPeriod updateMany
   */
  export type ResultPeriodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResultPeriods.
     */
    data: XOR<ResultPeriodUpdateManyMutationInput, ResultPeriodUncheckedUpdateManyInput>
    /**
     * Filter which ResultPeriods to update
     */
    where?: ResultPeriodWhereInput
    /**
     * Limit how many ResultPeriods to update.
     */
    limit?: number
  }

  /**
   * ResultPeriod updateManyAndReturn
   */
  export type ResultPeriodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultPeriod
     */
    select?: ResultPeriodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResultPeriod
     */
    omit?: ResultPeriodOmit<ExtArgs> | null
    /**
     * The data used to update ResultPeriods.
     */
    data: XOR<ResultPeriodUpdateManyMutationInput, ResultPeriodUncheckedUpdateManyInput>
    /**
     * Filter which ResultPeriods to update
     */
    where?: ResultPeriodWhereInput
    /**
     * Limit how many ResultPeriods to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultPeriodIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResultPeriod upsert
   */
  export type ResultPeriodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultPeriod
     */
    select?: ResultPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultPeriod
     */
    omit?: ResultPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultPeriodInclude<ExtArgs> | null
    /**
     * The filter to search for the ResultPeriod to update in case it exists.
     */
    where: ResultPeriodWhereUniqueInput
    /**
     * In case the ResultPeriod found by the `where` argument doesn't exist, create a new ResultPeriod with this data.
     */
    create: XOR<ResultPeriodCreateInput, ResultPeriodUncheckedCreateInput>
    /**
     * In case the ResultPeriod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResultPeriodUpdateInput, ResultPeriodUncheckedUpdateInput>
  }

  /**
   * ResultPeriod delete
   */
  export type ResultPeriodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultPeriod
     */
    select?: ResultPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultPeriod
     */
    omit?: ResultPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultPeriodInclude<ExtArgs> | null
    /**
     * Filter which ResultPeriod to delete.
     */
    where: ResultPeriodWhereUniqueInput
  }

  /**
   * ResultPeriod deleteMany
   */
  export type ResultPeriodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResultPeriods to delete
     */
    where?: ResultPeriodWhereInput
    /**
     * Limit how many ResultPeriods to delete.
     */
    limit?: number
  }

  /**
   * ResultPeriod.results
   */
  export type ResultPeriod$resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Result
     */
    select?: ResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Result
     */
    omit?: ResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultInclude<ExtArgs> | null
    where?: ResultWhereInput
    orderBy?: ResultOrderByWithRelationInput | ResultOrderByWithRelationInput[]
    cursor?: ResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResultScalarFieldEnum | ResultScalarFieldEnum[]
  }

  /**
   * ResultPeriod without action
   */
  export type ResultPeriodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultPeriod
     */
    select?: ResultPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultPeriod
     */
    omit?: ResultPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultPeriodInclude<ExtArgs> | null
  }


  /**
   * Model AssessmentComponent
   */

  export type AggregateAssessmentComponent = {
    _count: AssessmentComponentCountAggregateOutputType | null
    _avg: AssessmentComponentAvgAggregateOutputType | null
    _sum: AssessmentComponentSumAggregateOutputType | null
    _min: AssessmentComponentMinAggregateOutputType | null
    _max: AssessmentComponentMaxAggregateOutputType | null
  }

  export type AssessmentComponentAvgAggregateOutputType = {
    maxScore: number | null
  }

  export type AssessmentComponentSumAggregateOutputType = {
    maxScore: number | null
  }

  export type AssessmentComponentMinAggregateOutputType = {
    id: string | null
    name: string | null
    key: string | null
    maxScore: number | null
    configurationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssessmentComponentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    key: string | null
    maxScore: number | null
    configurationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssessmentComponentCountAggregateOutputType = {
    id: number
    name: number
    key: number
    maxScore: number
    configurationId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AssessmentComponentAvgAggregateInputType = {
    maxScore?: true
  }

  export type AssessmentComponentSumAggregateInputType = {
    maxScore?: true
  }

  export type AssessmentComponentMinAggregateInputType = {
    id?: true
    name?: true
    key?: true
    maxScore?: true
    configurationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssessmentComponentMaxAggregateInputType = {
    id?: true
    name?: true
    key?: true
    maxScore?: true
    configurationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssessmentComponentCountAggregateInputType = {
    id?: true
    name?: true
    key?: true
    maxScore?: true
    configurationId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AssessmentComponentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssessmentComponent to aggregate.
     */
    where?: AssessmentComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentComponents to fetch.
     */
    orderBy?: AssessmentComponentOrderByWithRelationInput | AssessmentComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssessmentComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssessmentComponents
    **/
    _count?: true | AssessmentComponentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssessmentComponentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssessmentComponentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssessmentComponentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssessmentComponentMaxAggregateInputType
  }

  export type GetAssessmentComponentAggregateType<T extends AssessmentComponentAggregateArgs> = {
        [P in keyof T & keyof AggregateAssessmentComponent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssessmentComponent[P]>
      : GetScalarType<T[P], AggregateAssessmentComponent[P]>
  }




  export type AssessmentComponentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssessmentComponentWhereInput
    orderBy?: AssessmentComponentOrderByWithAggregationInput | AssessmentComponentOrderByWithAggregationInput[]
    by: AssessmentComponentScalarFieldEnum[] | AssessmentComponentScalarFieldEnum
    having?: AssessmentComponentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssessmentComponentCountAggregateInputType | true
    _avg?: AssessmentComponentAvgAggregateInputType
    _sum?: AssessmentComponentSumAggregateInputType
    _min?: AssessmentComponentMinAggregateInputType
    _max?: AssessmentComponentMaxAggregateInputType
  }

  export type AssessmentComponentGroupByOutputType = {
    id: string
    name: string
    key: string
    maxScore: number
    configurationId: string
    createdAt: Date
    updatedAt: Date
    _count: AssessmentComponentCountAggregateOutputType | null
    _avg: AssessmentComponentAvgAggregateOutputType | null
    _sum: AssessmentComponentSumAggregateOutputType | null
    _min: AssessmentComponentMinAggregateOutputType | null
    _max: AssessmentComponentMaxAggregateOutputType | null
  }

  type GetAssessmentComponentGroupByPayload<T extends AssessmentComponentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssessmentComponentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssessmentComponentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssessmentComponentGroupByOutputType[P]>
            : GetScalarType<T[P], AssessmentComponentGroupByOutputType[P]>
        }
      >
    >


  export type AssessmentComponentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    key?: boolean
    maxScore?: boolean
    configurationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    configuration?: boolean | ResultConfigurationDefaultArgs<ExtArgs>
    scores?: boolean | AssessmentComponent$scoresArgs<ExtArgs>
    _count?: boolean | AssessmentComponentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assessmentComponent"]>

  export type AssessmentComponentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    key?: boolean
    maxScore?: boolean
    configurationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    configuration?: boolean | ResultConfigurationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assessmentComponent"]>

  export type AssessmentComponentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    key?: boolean
    maxScore?: boolean
    configurationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    configuration?: boolean | ResultConfigurationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assessmentComponent"]>

  export type AssessmentComponentSelectScalar = {
    id?: boolean
    name?: boolean
    key?: boolean
    maxScore?: boolean
    configurationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AssessmentComponentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "key" | "maxScore" | "configurationId" | "createdAt" | "updatedAt", ExtArgs["result"]["assessmentComponent"]>
  export type AssessmentComponentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    configuration?: boolean | ResultConfigurationDefaultArgs<ExtArgs>
    scores?: boolean | AssessmentComponent$scoresArgs<ExtArgs>
    _count?: boolean | AssessmentComponentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AssessmentComponentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    configuration?: boolean | ResultConfigurationDefaultArgs<ExtArgs>
  }
  export type AssessmentComponentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    configuration?: boolean | ResultConfigurationDefaultArgs<ExtArgs>
  }

  export type $AssessmentComponentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssessmentComponent"
    objects: {
      configuration: Prisma.$ResultConfigurationPayload<ExtArgs>
      scores: Prisma.$ComponentScorePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      key: string
      maxScore: number
      configurationId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["assessmentComponent"]>
    composites: {}
  }

  type AssessmentComponentGetPayload<S extends boolean | null | undefined | AssessmentComponentDefaultArgs> = $Result.GetResult<Prisma.$AssessmentComponentPayload, S>

  type AssessmentComponentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssessmentComponentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssessmentComponentCountAggregateInputType | true
    }

  export interface AssessmentComponentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssessmentComponent'], meta: { name: 'AssessmentComponent' } }
    /**
     * Find zero or one AssessmentComponent that matches the filter.
     * @param {AssessmentComponentFindUniqueArgs} args - Arguments to find a AssessmentComponent
     * @example
     * // Get one AssessmentComponent
     * const assessmentComponent = await prisma.assessmentComponent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssessmentComponentFindUniqueArgs>(args: SelectSubset<T, AssessmentComponentFindUniqueArgs<ExtArgs>>): Prisma__AssessmentComponentClient<$Result.GetResult<Prisma.$AssessmentComponentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AssessmentComponent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssessmentComponentFindUniqueOrThrowArgs} args - Arguments to find a AssessmentComponent
     * @example
     * // Get one AssessmentComponent
     * const assessmentComponent = await prisma.assessmentComponent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssessmentComponentFindUniqueOrThrowArgs>(args: SelectSubset<T, AssessmentComponentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssessmentComponentClient<$Result.GetResult<Prisma.$AssessmentComponentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssessmentComponent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentComponentFindFirstArgs} args - Arguments to find a AssessmentComponent
     * @example
     * // Get one AssessmentComponent
     * const assessmentComponent = await prisma.assessmentComponent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssessmentComponentFindFirstArgs>(args?: SelectSubset<T, AssessmentComponentFindFirstArgs<ExtArgs>>): Prisma__AssessmentComponentClient<$Result.GetResult<Prisma.$AssessmentComponentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssessmentComponent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentComponentFindFirstOrThrowArgs} args - Arguments to find a AssessmentComponent
     * @example
     * // Get one AssessmentComponent
     * const assessmentComponent = await prisma.assessmentComponent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssessmentComponentFindFirstOrThrowArgs>(args?: SelectSubset<T, AssessmentComponentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssessmentComponentClient<$Result.GetResult<Prisma.$AssessmentComponentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AssessmentComponents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentComponentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssessmentComponents
     * const assessmentComponents = await prisma.assessmentComponent.findMany()
     * 
     * // Get first 10 AssessmentComponents
     * const assessmentComponents = await prisma.assessmentComponent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assessmentComponentWithIdOnly = await prisma.assessmentComponent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssessmentComponentFindManyArgs>(args?: SelectSubset<T, AssessmentComponentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentComponentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AssessmentComponent.
     * @param {AssessmentComponentCreateArgs} args - Arguments to create a AssessmentComponent.
     * @example
     * // Create one AssessmentComponent
     * const AssessmentComponent = await prisma.assessmentComponent.create({
     *   data: {
     *     // ... data to create a AssessmentComponent
     *   }
     * })
     * 
     */
    create<T extends AssessmentComponentCreateArgs>(args: SelectSubset<T, AssessmentComponentCreateArgs<ExtArgs>>): Prisma__AssessmentComponentClient<$Result.GetResult<Prisma.$AssessmentComponentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AssessmentComponents.
     * @param {AssessmentComponentCreateManyArgs} args - Arguments to create many AssessmentComponents.
     * @example
     * // Create many AssessmentComponents
     * const assessmentComponent = await prisma.assessmentComponent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssessmentComponentCreateManyArgs>(args?: SelectSubset<T, AssessmentComponentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AssessmentComponents and returns the data saved in the database.
     * @param {AssessmentComponentCreateManyAndReturnArgs} args - Arguments to create many AssessmentComponents.
     * @example
     * // Create many AssessmentComponents
     * const assessmentComponent = await prisma.assessmentComponent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AssessmentComponents and only return the `id`
     * const assessmentComponentWithIdOnly = await prisma.assessmentComponent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssessmentComponentCreateManyAndReturnArgs>(args?: SelectSubset<T, AssessmentComponentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentComponentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AssessmentComponent.
     * @param {AssessmentComponentDeleteArgs} args - Arguments to delete one AssessmentComponent.
     * @example
     * // Delete one AssessmentComponent
     * const AssessmentComponent = await prisma.assessmentComponent.delete({
     *   where: {
     *     // ... filter to delete one AssessmentComponent
     *   }
     * })
     * 
     */
    delete<T extends AssessmentComponentDeleteArgs>(args: SelectSubset<T, AssessmentComponentDeleteArgs<ExtArgs>>): Prisma__AssessmentComponentClient<$Result.GetResult<Prisma.$AssessmentComponentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AssessmentComponent.
     * @param {AssessmentComponentUpdateArgs} args - Arguments to update one AssessmentComponent.
     * @example
     * // Update one AssessmentComponent
     * const assessmentComponent = await prisma.assessmentComponent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssessmentComponentUpdateArgs>(args: SelectSubset<T, AssessmentComponentUpdateArgs<ExtArgs>>): Prisma__AssessmentComponentClient<$Result.GetResult<Prisma.$AssessmentComponentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AssessmentComponents.
     * @param {AssessmentComponentDeleteManyArgs} args - Arguments to filter AssessmentComponents to delete.
     * @example
     * // Delete a few AssessmentComponents
     * const { count } = await prisma.assessmentComponent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssessmentComponentDeleteManyArgs>(args?: SelectSubset<T, AssessmentComponentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssessmentComponents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentComponentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssessmentComponents
     * const assessmentComponent = await prisma.assessmentComponent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssessmentComponentUpdateManyArgs>(args: SelectSubset<T, AssessmentComponentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssessmentComponents and returns the data updated in the database.
     * @param {AssessmentComponentUpdateManyAndReturnArgs} args - Arguments to update many AssessmentComponents.
     * @example
     * // Update many AssessmentComponents
     * const assessmentComponent = await prisma.assessmentComponent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AssessmentComponents and only return the `id`
     * const assessmentComponentWithIdOnly = await prisma.assessmentComponent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssessmentComponentUpdateManyAndReturnArgs>(args: SelectSubset<T, AssessmentComponentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentComponentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AssessmentComponent.
     * @param {AssessmentComponentUpsertArgs} args - Arguments to update or create a AssessmentComponent.
     * @example
     * // Update or create a AssessmentComponent
     * const assessmentComponent = await prisma.assessmentComponent.upsert({
     *   create: {
     *     // ... data to create a AssessmentComponent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssessmentComponent we want to update
     *   }
     * })
     */
    upsert<T extends AssessmentComponentUpsertArgs>(args: SelectSubset<T, AssessmentComponentUpsertArgs<ExtArgs>>): Prisma__AssessmentComponentClient<$Result.GetResult<Prisma.$AssessmentComponentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AssessmentComponents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentComponentCountArgs} args - Arguments to filter AssessmentComponents to count.
     * @example
     * // Count the number of AssessmentComponents
     * const count = await prisma.assessmentComponent.count({
     *   where: {
     *     // ... the filter for the AssessmentComponents we want to count
     *   }
     * })
    **/
    count<T extends AssessmentComponentCountArgs>(
      args?: Subset<T, AssessmentComponentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssessmentComponentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssessmentComponent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentComponentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssessmentComponentAggregateArgs>(args: Subset<T, AssessmentComponentAggregateArgs>): Prisma.PrismaPromise<GetAssessmentComponentAggregateType<T>>

    /**
     * Group by AssessmentComponent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentComponentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssessmentComponentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssessmentComponentGroupByArgs['orderBy'] }
        : { orderBy?: AssessmentComponentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssessmentComponentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssessmentComponentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssessmentComponent model
   */
  readonly fields: AssessmentComponentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssessmentComponent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssessmentComponentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    configuration<T extends ResultConfigurationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResultConfigurationDefaultArgs<ExtArgs>>): Prisma__ResultConfigurationClient<$Result.GetResult<Prisma.$ResultConfigurationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    scores<T extends AssessmentComponent$scoresArgs<ExtArgs> = {}>(args?: Subset<T, AssessmentComponent$scoresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComponentScorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssessmentComponent model
   */ 
  interface AssessmentComponentFieldRefs {
    readonly id: FieldRef<"AssessmentComponent", 'String'>
    readonly name: FieldRef<"AssessmentComponent", 'String'>
    readonly key: FieldRef<"AssessmentComponent", 'String'>
    readonly maxScore: FieldRef<"AssessmentComponent", 'Float'>
    readonly configurationId: FieldRef<"AssessmentComponent", 'String'>
    readonly createdAt: FieldRef<"AssessmentComponent", 'DateTime'>
    readonly updatedAt: FieldRef<"AssessmentComponent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AssessmentComponent findUnique
   */
  export type AssessmentComponentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentComponent
     */
    select?: AssessmentComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentComponent
     */
    omit?: AssessmentComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentComponentInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentComponent to fetch.
     */
    where: AssessmentComponentWhereUniqueInput
  }

  /**
   * AssessmentComponent findUniqueOrThrow
   */
  export type AssessmentComponentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentComponent
     */
    select?: AssessmentComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentComponent
     */
    omit?: AssessmentComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentComponentInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentComponent to fetch.
     */
    where: AssessmentComponentWhereUniqueInput
  }

  /**
   * AssessmentComponent findFirst
   */
  export type AssessmentComponentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentComponent
     */
    select?: AssessmentComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentComponent
     */
    omit?: AssessmentComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentComponentInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentComponent to fetch.
     */
    where?: AssessmentComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentComponents to fetch.
     */
    orderBy?: AssessmentComponentOrderByWithRelationInput | AssessmentComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssessmentComponents.
     */
    cursor?: AssessmentComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssessmentComponents.
     */
    distinct?: AssessmentComponentScalarFieldEnum | AssessmentComponentScalarFieldEnum[]
  }

  /**
   * AssessmentComponent findFirstOrThrow
   */
  export type AssessmentComponentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentComponent
     */
    select?: AssessmentComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentComponent
     */
    omit?: AssessmentComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentComponentInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentComponent to fetch.
     */
    where?: AssessmentComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentComponents to fetch.
     */
    orderBy?: AssessmentComponentOrderByWithRelationInput | AssessmentComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssessmentComponents.
     */
    cursor?: AssessmentComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssessmentComponents.
     */
    distinct?: AssessmentComponentScalarFieldEnum | AssessmentComponentScalarFieldEnum[]
  }

  /**
   * AssessmentComponent findMany
   */
  export type AssessmentComponentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentComponent
     */
    select?: AssessmentComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentComponent
     */
    omit?: AssessmentComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentComponentInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentComponents to fetch.
     */
    where?: AssessmentComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentComponents to fetch.
     */
    orderBy?: AssessmentComponentOrderByWithRelationInput | AssessmentComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssessmentComponents.
     */
    cursor?: AssessmentComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentComponents.
     */
    skip?: number
    distinct?: AssessmentComponentScalarFieldEnum | AssessmentComponentScalarFieldEnum[]
  }

  /**
   * AssessmentComponent create
   */
  export type AssessmentComponentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentComponent
     */
    select?: AssessmentComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentComponent
     */
    omit?: AssessmentComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentComponentInclude<ExtArgs> | null
    /**
     * The data needed to create a AssessmentComponent.
     */
    data: XOR<AssessmentComponentCreateInput, AssessmentComponentUncheckedCreateInput>
  }

  /**
   * AssessmentComponent createMany
   */
  export type AssessmentComponentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssessmentComponents.
     */
    data: AssessmentComponentCreateManyInput | AssessmentComponentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssessmentComponent createManyAndReturn
   */
  export type AssessmentComponentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentComponent
     */
    select?: AssessmentComponentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentComponent
     */
    omit?: AssessmentComponentOmit<ExtArgs> | null
    /**
     * The data used to create many AssessmentComponents.
     */
    data: AssessmentComponentCreateManyInput | AssessmentComponentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentComponentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssessmentComponent update
   */
  export type AssessmentComponentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentComponent
     */
    select?: AssessmentComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentComponent
     */
    omit?: AssessmentComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentComponentInclude<ExtArgs> | null
    /**
     * The data needed to update a AssessmentComponent.
     */
    data: XOR<AssessmentComponentUpdateInput, AssessmentComponentUncheckedUpdateInput>
    /**
     * Choose, which AssessmentComponent to update.
     */
    where: AssessmentComponentWhereUniqueInput
  }

  /**
   * AssessmentComponent updateMany
   */
  export type AssessmentComponentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssessmentComponents.
     */
    data: XOR<AssessmentComponentUpdateManyMutationInput, AssessmentComponentUncheckedUpdateManyInput>
    /**
     * Filter which AssessmentComponents to update
     */
    where?: AssessmentComponentWhereInput
    /**
     * Limit how many AssessmentComponents to update.
     */
    limit?: number
  }

  /**
   * AssessmentComponent updateManyAndReturn
   */
  export type AssessmentComponentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentComponent
     */
    select?: AssessmentComponentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentComponent
     */
    omit?: AssessmentComponentOmit<ExtArgs> | null
    /**
     * The data used to update AssessmentComponents.
     */
    data: XOR<AssessmentComponentUpdateManyMutationInput, AssessmentComponentUncheckedUpdateManyInput>
    /**
     * Filter which AssessmentComponents to update
     */
    where?: AssessmentComponentWhereInput
    /**
     * Limit how many AssessmentComponents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentComponentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssessmentComponent upsert
   */
  export type AssessmentComponentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentComponent
     */
    select?: AssessmentComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentComponent
     */
    omit?: AssessmentComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentComponentInclude<ExtArgs> | null
    /**
     * The filter to search for the AssessmentComponent to update in case it exists.
     */
    where: AssessmentComponentWhereUniqueInput
    /**
     * In case the AssessmentComponent found by the `where` argument doesn't exist, create a new AssessmentComponent with this data.
     */
    create: XOR<AssessmentComponentCreateInput, AssessmentComponentUncheckedCreateInput>
    /**
     * In case the AssessmentComponent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssessmentComponentUpdateInput, AssessmentComponentUncheckedUpdateInput>
  }

  /**
   * AssessmentComponent delete
   */
  export type AssessmentComponentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentComponent
     */
    select?: AssessmentComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentComponent
     */
    omit?: AssessmentComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentComponentInclude<ExtArgs> | null
    /**
     * Filter which AssessmentComponent to delete.
     */
    where: AssessmentComponentWhereUniqueInput
  }

  /**
   * AssessmentComponent deleteMany
   */
  export type AssessmentComponentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssessmentComponents to delete
     */
    where?: AssessmentComponentWhereInput
    /**
     * Limit how many AssessmentComponents to delete.
     */
    limit?: number
  }

  /**
   * AssessmentComponent.scores
   */
  export type AssessmentComponent$scoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentScore
     */
    select?: ComponentScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentScore
     */
    omit?: ComponentScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentScoreInclude<ExtArgs> | null
    where?: ComponentScoreWhereInput
    orderBy?: ComponentScoreOrderByWithRelationInput | ComponentScoreOrderByWithRelationInput[]
    cursor?: ComponentScoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComponentScoreScalarFieldEnum | ComponentScoreScalarFieldEnum[]
  }

  /**
   * AssessmentComponent without action
   */
  export type AssessmentComponentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentComponent
     */
    select?: AssessmentComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentComponent
     */
    omit?: AssessmentComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentComponentInclude<ExtArgs> | null
  }


  /**
   * Model GradingScale
   */

  export type AggregateGradingScale = {
    _count: GradingScaleCountAggregateOutputType | null
    _avg: GradingScaleAvgAggregateOutputType | null
    _sum: GradingScaleSumAggregateOutputType | null
    _min: GradingScaleMinAggregateOutputType | null
    _max: GradingScaleMaxAggregateOutputType | null
  }

  export type GradingScaleAvgAggregateOutputType = {
    minScore: number | null
    maxScore: number | null
  }

  export type GradingScaleSumAggregateOutputType = {
    minScore: number | null
    maxScore: number | null
  }

  export type GradingScaleMinAggregateOutputType = {
    id: string | null
    minScore: number | null
    maxScore: number | null
    grade: string | null
    remark: string | null
    configurationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GradingScaleMaxAggregateOutputType = {
    id: string | null
    minScore: number | null
    maxScore: number | null
    grade: string | null
    remark: string | null
    configurationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GradingScaleCountAggregateOutputType = {
    id: number
    minScore: number
    maxScore: number
    grade: number
    remark: number
    configurationId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GradingScaleAvgAggregateInputType = {
    minScore?: true
    maxScore?: true
  }

  export type GradingScaleSumAggregateInputType = {
    minScore?: true
    maxScore?: true
  }

  export type GradingScaleMinAggregateInputType = {
    id?: true
    minScore?: true
    maxScore?: true
    grade?: true
    remark?: true
    configurationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GradingScaleMaxAggregateInputType = {
    id?: true
    minScore?: true
    maxScore?: true
    grade?: true
    remark?: true
    configurationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GradingScaleCountAggregateInputType = {
    id?: true
    minScore?: true
    maxScore?: true
    grade?: true
    remark?: true
    configurationId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GradingScaleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GradingScale to aggregate.
     */
    where?: GradingScaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GradingScales to fetch.
     */
    orderBy?: GradingScaleOrderByWithRelationInput | GradingScaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GradingScaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GradingScales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GradingScales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GradingScales
    **/
    _count?: true | GradingScaleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GradingScaleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GradingScaleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GradingScaleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GradingScaleMaxAggregateInputType
  }

  export type GetGradingScaleAggregateType<T extends GradingScaleAggregateArgs> = {
        [P in keyof T & keyof AggregateGradingScale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGradingScale[P]>
      : GetScalarType<T[P], AggregateGradingScale[P]>
  }




  export type GradingScaleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradingScaleWhereInput
    orderBy?: GradingScaleOrderByWithAggregationInput | GradingScaleOrderByWithAggregationInput[]
    by: GradingScaleScalarFieldEnum[] | GradingScaleScalarFieldEnum
    having?: GradingScaleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GradingScaleCountAggregateInputType | true
    _avg?: GradingScaleAvgAggregateInputType
    _sum?: GradingScaleSumAggregateInputType
    _min?: GradingScaleMinAggregateInputType
    _max?: GradingScaleMaxAggregateInputType
  }

  export type GradingScaleGroupByOutputType = {
    id: string
    minScore: number
    maxScore: number
    grade: string
    remark: string
    configurationId: string
    createdAt: Date
    updatedAt: Date
    _count: GradingScaleCountAggregateOutputType | null
    _avg: GradingScaleAvgAggregateOutputType | null
    _sum: GradingScaleSumAggregateOutputType | null
    _min: GradingScaleMinAggregateOutputType | null
    _max: GradingScaleMaxAggregateOutputType | null
  }

  type GetGradingScaleGroupByPayload<T extends GradingScaleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GradingScaleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GradingScaleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GradingScaleGroupByOutputType[P]>
            : GetScalarType<T[P], GradingScaleGroupByOutputType[P]>
        }
      >
    >


  export type GradingScaleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    minScore?: boolean
    maxScore?: boolean
    grade?: boolean
    remark?: boolean
    configurationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    configuration?: boolean | ResultConfigurationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gradingScale"]>

  export type GradingScaleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    minScore?: boolean
    maxScore?: boolean
    grade?: boolean
    remark?: boolean
    configurationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    configuration?: boolean | ResultConfigurationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gradingScale"]>

  export type GradingScaleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    minScore?: boolean
    maxScore?: boolean
    grade?: boolean
    remark?: boolean
    configurationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    configuration?: boolean | ResultConfigurationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gradingScale"]>

  export type GradingScaleSelectScalar = {
    id?: boolean
    minScore?: boolean
    maxScore?: boolean
    grade?: boolean
    remark?: boolean
    configurationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GradingScaleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "minScore" | "maxScore" | "grade" | "remark" | "configurationId" | "createdAt" | "updatedAt", ExtArgs["result"]["gradingScale"]>
  export type GradingScaleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    configuration?: boolean | ResultConfigurationDefaultArgs<ExtArgs>
  }
  export type GradingScaleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    configuration?: boolean | ResultConfigurationDefaultArgs<ExtArgs>
  }
  export type GradingScaleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    configuration?: boolean | ResultConfigurationDefaultArgs<ExtArgs>
  }

  export type $GradingScalePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GradingScale"
    objects: {
      configuration: Prisma.$ResultConfigurationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      minScore: number
      maxScore: number
      grade: string
      remark: string
      configurationId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gradingScale"]>
    composites: {}
  }

  type GradingScaleGetPayload<S extends boolean | null | undefined | GradingScaleDefaultArgs> = $Result.GetResult<Prisma.$GradingScalePayload, S>

  type GradingScaleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GradingScaleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GradingScaleCountAggregateInputType | true
    }

  export interface GradingScaleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GradingScale'], meta: { name: 'GradingScale' } }
    /**
     * Find zero or one GradingScale that matches the filter.
     * @param {GradingScaleFindUniqueArgs} args - Arguments to find a GradingScale
     * @example
     * // Get one GradingScale
     * const gradingScale = await prisma.gradingScale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GradingScaleFindUniqueArgs>(args: SelectSubset<T, GradingScaleFindUniqueArgs<ExtArgs>>): Prisma__GradingScaleClient<$Result.GetResult<Prisma.$GradingScalePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GradingScale that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GradingScaleFindUniqueOrThrowArgs} args - Arguments to find a GradingScale
     * @example
     * // Get one GradingScale
     * const gradingScale = await prisma.gradingScale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GradingScaleFindUniqueOrThrowArgs>(args: SelectSubset<T, GradingScaleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GradingScaleClient<$Result.GetResult<Prisma.$GradingScalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GradingScale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradingScaleFindFirstArgs} args - Arguments to find a GradingScale
     * @example
     * // Get one GradingScale
     * const gradingScale = await prisma.gradingScale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GradingScaleFindFirstArgs>(args?: SelectSubset<T, GradingScaleFindFirstArgs<ExtArgs>>): Prisma__GradingScaleClient<$Result.GetResult<Prisma.$GradingScalePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GradingScale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradingScaleFindFirstOrThrowArgs} args - Arguments to find a GradingScale
     * @example
     * // Get one GradingScale
     * const gradingScale = await prisma.gradingScale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GradingScaleFindFirstOrThrowArgs>(args?: SelectSubset<T, GradingScaleFindFirstOrThrowArgs<ExtArgs>>): Prisma__GradingScaleClient<$Result.GetResult<Prisma.$GradingScalePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GradingScales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradingScaleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GradingScales
     * const gradingScales = await prisma.gradingScale.findMany()
     * 
     * // Get first 10 GradingScales
     * const gradingScales = await prisma.gradingScale.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gradingScaleWithIdOnly = await prisma.gradingScale.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GradingScaleFindManyArgs>(args?: SelectSubset<T, GradingScaleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradingScalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GradingScale.
     * @param {GradingScaleCreateArgs} args - Arguments to create a GradingScale.
     * @example
     * // Create one GradingScale
     * const GradingScale = await prisma.gradingScale.create({
     *   data: {
     *     // ... data to create a GradingScale
     *   }
     * })
     * 
     */
    create<T extends GradingScaleCreateArgs>(args: SelectSubset<T, GradingScaleCreateArgs<ExtArgs>>): Prisma__GradingScaleClient<$Result.GetResult<Prisma.$GradingScalePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GradingScales.
     * @param {GradingScaleCreateManyArgs} args - Arguments to create many GradingScales.
     * @example
     * // Create many GradingScales
     * const gradingScale = await prisma.gradingScale.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GradingScaleCreateManyArgs>(args?: SelectSubset<T, GradingScaleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GradingScales and returns the data saved in the database.
     * @param {GradingScaleCreateManyAndReturnArgs} args - Arguments to create many GradingScales.
     * @example
     * // Create many GradingScales
     * const gradingScale = await prisma.gradingScale.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GradingScales and only return the `id`
     * const gradingScaleWithIdOnly = await prisma.gradingScale.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GradingScaleCreateManyAndReturnArgs>(args?: SelectSubset<T, GradingScaleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradingScalePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GradingScale.
     * @param {GradingScaleDeleteArgs} args - Arguments to delete one GradingScale.
     * @example
     * // Delete one GradingScale
     * const GradingScale = await prisma.gradingScale.delete({
     *   where: {
     *     // ... filter to delete one GradingScale
     *   }
     * })
     * 
     */
    delete<T extends GradingScaleDeleteArgs>(args: SelectSubset<T, GradingScaleDeleteArgs<ExtArgs>>): Prisma__GradingScaleClient<$Result.GetResult<Prisma.$GradingScalePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GradingScale.
     * @param {GradingScaleUpdateArgs} args - Arguments to update one GradingScale.
     * @example
     * // Update one GradingScale
     * const gradingScale = await prisma.gradingScale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GradingScaleUpdateArgs>(args: SelectSubset<T, GradingScaleUpdateArgs<ExtArgs>>): Prisma__GradingScaleClient<$Result.GetResult<Prisma.$GradingScalePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GradingScales.
     * @param {GradingScaleDeleteManyArgs} args - Arguments to filter GradingScales to delete.
     * @example
     * // Delete a few GradingScales
     * const { count } = await prisma.gradingScale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GradingScaleDeleteManyArgs>(args?: SelectSubset<T, GradingScaleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GradingScales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradingScaleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GradingScales
     * const gradingScale = await prisma.gradingScale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GradingScaleUpdateManyArgs>(args: SelectSubset<T, GradingScaleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GradingScales and returns the data updated in the database.
     * @param {GradingScaleUpdateManyAndReturnArgs} args - Arguments to update many GradingScales.
     * @example
     * // Update many GradingScales
     * const gradingScale = await prisma.gradingScale.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GradingScales and only return the `id`
     * const gradingScaleWithIdOnly = await prisma.gradingScale.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GradingScaleUpdateManyAndReturnArgs>(args: SelectSubset<T, GradingScaleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradingScalePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GradingScale.
     * @param {GradingScaleUpsertArgs} args - Arguments to update or create a GradingScale.
     * @example
     * // Update or create a GradingScale
     * const gradingScale = await prisma.gradingScale.upsert({
     *   create: {
     *     // ... data to create a GradingScale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GradingScale we want to update
     *   }
     * })
     */
    upsert<T extends GradingScaleUpsertArgs>(args: SelectSubset<T, GradingScaleUpsertArgs<ExtArgs>>): Prisma__GradingScaleClient<$Result.GetResult<Prisma.$GradingScalePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GradingScales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradingScaleCountArgs} args - Arguments to filter GradingScales to count.
     * @example
     * // Count the number of GradingScales
     * const count = await prisma.gradingScale.count({
     *   where: {
     *     // ... the filter for the GradingScales we want to count
     *   }
     * })
    **/
    count<T extends GradingScaleCountArgs>(
      args?: Subset<T, GradingScaleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GradingScaleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GradingScale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradingScaleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GradingScaleAggregateArgs>(args: Subset<T, GradingScaleAggregateArgs>): Prisma.PrismaPromise<GetGradingScaleAggregateType<T>>

    /**
     * Group by GradingScale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradingScaleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GradingScaleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GradingScaleGroupByArgs['orderBy'] }
        : { orderBy?: GradingScaleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GradingScaleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGradingScaleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GradingScale model
   */
  readonly fields: GradingScaleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GradingScale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GradingScaleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    configuration<T extends ResultConfigurationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResultConfigurationDefaultArgs<ExtArgs>>): Prisma__ResultConfigurationClient<$Result.GetResult<Prisma.$ResultConfigurationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GradingScale model
   */ 
  interface GradingScaleFieldRefs {
    readonly id: FieldRef<"GradingScale", 'String'>
    readonly minScore: FieldRef<"GradingScale", 'Float'>
    readonly maxScore: FieldRef<"GradingScale", 'Float'>
    readonly grade: FieldRef<"GradingScale", 'String'>
    readonly remark: FieldRef<"GradingScale", 'String'>
    readonly configurationId: FieldRef<"GradingScale", 'String'>
    readonly createdAt: FieldRef<"GradingScale", 'DateTime'>
    readonly updatedAt: FieldRef<"GradingScale", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GradingScale findUnique
   */
  export type GradingScaleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradingScale
     */
    select?: GradingScaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradingScale
     */
    omit?: GradingScaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingScaleInclude<ExtArgs> | null
    /**
     * Filter, which GradingScale to fetch.
     */
    where: GradingScaleWhereUniqueInput
  }

  /**
   * GradingScale findUniqueOrThrow
   */
  export type GradingScaleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradingScale
     */
    select?: GradingScaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradingScale
     */
    omit?: GradingScaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingScaleInclude<ExtArgs> | null
    /**
     * Filter, which GradingScale to fetch.
     */
    where: GradingScaleWhereUniqueInput
  }

  /**
   * GradingScale findFirst
   */
  export type GradingScaleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradingScale
     */
    select?: GradingScaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradingScale
     */
    omit?: GradingScaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingScaleInclude<ExtArgs> | null
    /**
     * Filter, which GradingScale to fetch.
     */
    where?: GradingScaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GradingScales to fetch.
     */
    orderBy?: GradingScaleOrderByWithRelationInput | GradingScaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GradingScales.
     */
    cursor?: GradingScaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GradingScales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GradingScales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GradingScales.
     */
    distinct?: GradingScaleScalarFieldEnum | GradingScaleScalarFieldEnum[]
  }

  /**
   * GradingScale findFirstOrThrow
   */
  export type GradingScaleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradingScale
     */
    select?: GradingScaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradingScale
     */
    omit?: GradingScaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingScaleInclude<ExtArgs> | null
    /**
     * Filter, which GradingScale to fetch.
     */
    where?: GradingScaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GradingScales to fetch.
     */
    orderBy?: GradingScaleOrderByWithRelationInput | GradingScaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GradingScales.
     */
    cursor?: GradingScaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GradingScales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GradingScales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GradingScales.
     */
    distinct?: GradingScaleScalarFieldEnum | GradingScaleScalarFieldEnum[]
  }

  /**
   * GradingScale findMany
   */
  export type GradingScaleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradingScale
     */
    select?: GradingScaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradingScale
     */
    omit?: GradingScaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingScaleInclude<ExtArgs> | null
    /**
     * Filter, which GradingScales to fetch.
     */
    where?: GradingScaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GradingScales to fetch.
     */
    orderBy?: GradingScaleOrderByWithRelationInput | GradingScaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GradingScales.
     */
    cursor?: GradingScaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GradingScales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GradingScales.
     */
    skip?: number
    distinct?: GradingScaleScalarFieldEnum | GradingScaleScalarFieldEnum[]
  }

  /**
   * GradingScale create
   */
  export type GradingScaleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradingScale
     */
    select?: GradingScaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradingScale
     */
    omit?: GradingScaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingScaleInclude<ExtArgs> | null
    /**
     * The data needed to create a GradingScale.
     */
    data: XOR<GradingScaleCreateInput, GradingScaleUncheckedCreateInput>
  }

  /**
   * GradingScale createMany
   */
  export type GradingScaleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GradingScales.
     */
    data: GradingScaleCreateManyInput | GradingScaleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GradingScale createManyAndReturn
   */
  export type GradingScaleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradingScale
     */
    select?: GradingScaleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GradingScale
     */
    omit?: GradingScaleOmit<ExtArgs> | null
    /**
     * The data used to create many GradingScales.
     */
    data: GradingScaleCreateManyInput | GradingScaleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingScaleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GradingScale update
   */
  export type GradingScaleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradingScale
     */
    select?: GradingScaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradingScale
     */
    omit?: GradingScaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingScaleInclude<ExtArgs> | null
    /**
     * The data needed to update a GradingScale.
     */
    data: XOR<GradingScaleUpdateInput, GradingScaleUncheckedUpdateInput>
    /**
     * Choose, which GradingScale to update.
     */
    where: GradingScaleWhereUniqueInput
  }

  /**
   * GradingScale updateMany
   */
  export type GradingScaleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GradingScales.
     */
    data: XOR<GradingScaleUpdateManyMutationInput, GradingScaleUncheckedUpdateManyInput>
    /**
     * Filter which GradingScales to update
     */
    where?: GradingScaleWhereInput
    /**
     * Limit how many GradingScales to update.
     */
    limit?: number
  }

  /**
   * GradingScale updateManyAndReturn
   */
  export type GradingScaleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradingScale
     */
    select?: GradingScaleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GradingScale
     */
    omit?: GradingScaleOmit<ExtArgs> | null
    /**
     * The data used to update GradingScales.
     */
    data: XOR<GradingScaleUpdateManyMutationInput, GradingScaleUncheckedUpdateManyInput>
    /**
     * Filter which GradingScales to update
     */
    where?: GradingScaleWhereInput
    /**
     * Limit how many GradingScales to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingScaleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GradingScale upsert
   */
  export type GradingScaleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradingScale
     */
    select?: GradingScaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradingScale
     */
    omit?: GradingScaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingScaleInclude<ExtArgs> | null
    /**
     * The filter to search for the GradingScale to update in case it exists.
     */
    where: GradingScaleWhereUniqueInput
    /**
     * In case the GradingScale found by the `where` argument doesn't exist, create a new GradingScale with this data.
     */
    create: XOR<GradingScaleCreateInput, GradingScaleUncheckedCreateInput>
    /**
     * In case the GradingScale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GradingScaleUpdateInput, GradingScaleUncheckedUpdateInput>
  }

  /**
   * GradingScale delete
   */
  export type GradingScaleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradingScale
     */
    select?: GradingScaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradingScale
     */
    omit?: GradingScaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingScaleInclude<ExtArgs> | null
    /**
     * Filter which GradingScale to delete.
     */
    where: GradingScaleWhereUniqueInput
  }

  /**
   * GradingScale deleteMany
   */
  export type GradingScaleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GradingScales to delete
     */
    where?: GradingScaleWhereInput
    /**
     * Limit how many GradingScales to delete.
     */
    limit?: number
  }

  /**
   * GradingScale without action
   */
  export type GradingScaleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradingScale
     */
    select?: GradingScaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradingScale
     */
    omit?: GradingScaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingScaleInclude<ExtArgs> | null
  }


  /**
   * Model ComponentScore
   */

  export type AggregateComponentScore = {
    _count: ComponentScoreCountAggregateOutputType | null
    _avg: ComponentScoreAvgAggregateOutputType | null
    _sum: ComponentScoreSumAggregateOutputType | null
    _min: ComponentScoreMinAggregateOutputType | null
    _max: ComponentScoreMaxAggregateOutputType | null
  }

  export type ComponentScoreAvgAggregateOutputType = {
    score: number | null
  }

  export type ComponentScoreSumAggregateOutputType = {
    score: number | null
  }

  export type ComponentScoreMinAggregateOutputType = {
    id: string | null
    score: number | null
    componentId: string | null
    resultId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComponentScoreMaxAggregateOutputType = {
    id: string | null
    score: number | null
    componentId: string | null
    resultId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComponentScoreCountAggregateOutputType = {
    id: number
    score: number
    componentId: number
    resultId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ComponentScoreAvgAggregateInputType = {
    score?: true
  }

  export type ComponentScoreSumAggregateInputType = {
    score?: true
  }

  export type ComponentScoreMinAggregateInputType = {
    id?: true
    score?: true
    componentId?: true
    resultId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComponentScoreMaxAggregateInputType = {
    id?: true
    score?: true
    componentId?: true
    resultId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComponentScoreCountAggregateInputType = {
    id?: true
    score?: true
    componentId?: true
    resultId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ComponentScoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComponentScore to aggregate.
     */
    where?: ComponentScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComponentScores to fetch.
     */
    orderBy?: ComponentScoreOrderByWithRelationInput | ComponentScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComponentScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComponentScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComponentScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ComponentScores
    **/
    _count?: true | ComponentScoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComponentScoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComponentScoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComponentScoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComponentScoreMaxAggregateInputType
  }

  export type GetComponentScoreAggregateType<T extends ComponentScoreAggregateArgs> = {
        [P in keyof T & keyof AggregateComponentScore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComponentScore[P]>
      : GetScalarType<T[P], AggregateComponentScore[P]>
  }




  export type ComponentScoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComponentScoreWhereInput
    orderBy?: ComponentScoreOrderByWithAggregationInput | ComponentScoreOrderByWithAggregationInput[]
    by: ComponentScoreScalarFieldEnum[] | ComponentScoreScalarFieldEnum
    having?: ComponentScoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComponentScoreCountAggregateInputType | true
    _avg?: ComponentScoreAvgAggregateInputType
    _sum?: ComponentScoreSumAggregateInputType
    _min?: ComponentScoreMinAggregateInputType
    _max?: ComponentScoreMaxAggregateInputType
  }

  export type ComponentScoreGroupByOutputType = {
    id: string
    score: number
    componentId: string
    resultId: string
    createdAt: Date
    updatedAt: Date
    _count: ComponentScoreCountAggregateOutputType | null
    _avg: ComponentScoreAvgAggregateOutputType | null
    _sum: ComponentScoreSumAggregateOutputType | null
    _min: ComponentScoreMinAggregateOutputType | null
    _max: ComponentScoreMaxAggregateOutputType | null
  }

  type GetComponentScoreGroupByPayload<T extends ComponentScoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComponentScoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComponentScoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComponentScoreGroupByOutputType[P]>
            : GetScalarType<T[P], ComponentScoreGroupByOutputType[P]>
        }
      >
    >


  export type ComponentScoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    score?: boolean
    componentId?: boolean
    resultId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    component?: boolean | AssessmentComponentDefaultArgs<ExtArgs>
    result?: boolean | ResultDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["componentScore"]>

  export type ComponentScoreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    score?: boolean
    componentId?: boolean
    resultId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    component?: boolean | AssessmentComponentDefaultArgs<ExtArgs>
    result?: boolean | ResultDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["componentScore"]>

  export type ComponentScoreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    score?: boolean
    componentId?: boolean
    resultId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    component?: boolean | AssessmentComponentDefaultArgs<ExtArgs>
    result?: boolean | ResultDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["componentScore"]>

  export type ComponentScoreSelectScalar = {
    id?: boolean
    score?: boolean
    componentId?: boolean
    resultId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ComponentScoreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "score" | "componentId" | "resultId" | "createdAt" | "updatedAt", ExtArgs["result"]["componentScore"]>
  export type ComponentScoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    component?: boolean | AssessmentComponentDefaultArgs<ExtArgs>
    result?: boolean | ResultDefaultArgs<ExtArgs>
  }
  export type ComponentScoreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    component?: boolean | AssessmentComponentDefaultArgs<ExtArgs>
    result?: boolean | ResultDefaultArgs<ExtArgs>
  }
  export type ComponentScoreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    component?: boolean | AssessmentComponentDefaultArgs<ExtArgs>
    result?: boolean | ResultDefaultArgs<ExtArgs>
  }

  export type $ComponentScorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ComponentScore"
    objects: {
      component: Prisma.$AssessmentComponentPayload<ExtArgs>
      result: Prisma.$ResultPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      score: number
      componentId: string
      resultId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["componentScore"]>
    composites: {}
  }

  type ComponentScoreGetPayload<S extends boolean | null | undefined | ComponentScoreDefaultArgs> = $Result.GetResult<Prisma.$ComponentScorePayload, S>

  type ComponentScoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ComponentScoreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComponentScoreCountAggregateInputType | true
    }

  export interface ComponentScoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ComponentScore'], meta: { name: 'ComponentScore' } }
    /**
     * Find zero or one ComponentScore that matches the filter.
     * @param {ComponentScoreFindUniqueArgs} args - Arguments to find a ComponentScore
     * @example
     * // Get one ComponentScore
     * const componentScore = await prisma.componentScore.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComponentScoreFindUniqueArgs>(args: SelectSubset<T, ComponentScoreFindUniqueArgs<ExtArgs>>): Prisma__ComponentScoreClient<$Result.GetResult<Prisma.$ComponentScorePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ComponentScore that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComponentScoreFindUniqueOrThrowArgs} args - Arguments to find a ComponentScore
     * @example
     * // Get one ComponentScore
     * const componentScore = await prisma.componentScore.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComponentScoreFindUniqueOrThrowArgs>(args: SelectSubset<T, ComponentScoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComponentScoreClient<$Result.GetResult<Prisma.$ComponentScorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComponentScore that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentScoreFindFirstArgs} args - Arguments to find a ComponentScore
     * @example
     * // Get one ComponentScore
     * const componentScore = await prisma.componentScore.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComponentScoreFindFirstArgs>(args?: SelectSubset<T, ComponentScoreFindFirstArgs<ExtArgs>>): Prisma__ComponentScoreClient<$Result.GetResult<Prisma.$ComponentScorePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComponentScore that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentScoreFindFirstOrThrowArgs} args - Arguments to find a ComponentScore
     * @example
     * // Get one ComponentScore
     * const componentScore = await prisma.componentScore.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComponentScoreFindFirstOrThrowArgs>(args?: SelectSubset<T, ComponentScoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComponentScoreClient<$Result.GetResult<Prisma.$ComponentScorePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ComponentScores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentScoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ComponentScores
     * const componentScores = await prisma.componentScore.findMany()
     * 
     * // Get first 10 ComponentScores
     * const componentScores = await prisma.componentScore.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const componentScoreWithIdOnly = await prisma.componentScore.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComponentScoreFindManyArgs>(args?: SelectSubset<T, ComponentScoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComponentScorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ComponentScore.
     * @param {ComponentScoreCreateArgs} args - Arguments to create a ComponentScore.
     * @example
     * // Create one ComponentScore
     * const ComponentScore = await prisma.componentScore.create({
     *   data: {
     *     // ... data to create a ComponentScore
     *   }
     * })
     * 
     */
    create<T extends ComponentScoreCreateArgs>(args: SelectSubset<T, ComponentScoreCreateArgs<ExtArgs>>): Prisma__ComponentScoreClient<$Result.GetResult<Prisma.$ComponentScorePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ComponentScores.
     * @param {ComponentScoreCreateManyArgs} args - Arguments to create many ComponentScores.
     * @example
     * // Create many ComponentScores
     * const componentScore = await prisma.componentScore.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComponentScoreCreateManyArgs>(args?: SelectSubset<T, ComponentScoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ComponentScores and returns the data saved in the database.
     * @param {ComponentScoreCreateManyAndReturnArgs} args - Arguments to create many ComponentScores.
     * @example
     * // Create many ComponentScores
     * const componentScore = await prisma.componentScore.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ComponentScores and only return the `id`
     * const componentScoreWithIdOnly = await prisma.componentScore.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComponentScoreCreateManyAndReturnArgs>(args?: SelectSubset<T, ComponentScoreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComponentScorePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ComponentScore.
     * @param {ComponentScoreDeleteArgs} args - Arguments to delete one ComponentScore.
     * @example
     * // Delete one ComponentScore
     * const ComponentScore = await prisma.componentScore.delete({
     *   where: {
     *     // ... filter to delete one ComponentScore
     *   }
     * })
     * 
     */
    delete<T extends ComponentScoreDeleteArgs>(args: SelectSubset<T, ComponentScoreDeleteArgs<ExtArgs>>): Prisma__ComponentScoreClient<$Result.GetResult<Prisma.$ComponentScorePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ComponentScore.
     * @param {ComponentScoreUpdateArgs} args - Arguments to update one ComponentScore.
     * @example
     * // Update one ComponentScore
     * const componentScore = await prisma.componentScore.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComponentScoreUpdateArgs>(args: SelectSubset<T, ComponentScoreUpdateArgs<ExtArgs>>): Prisma__ComponentScoreClient<$Result.GetResult<Prisma.$ComponentScorePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ComponentScores.
     * @param {ComponentScoreDeleteManyArgs} args - Arguments to filter ComponentScores to delete.
     * @example
     * // Delete a few ComponentScores
     * const { count } = await prisma.componentScore.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComponentScoreDeleteManyArgs>(args?: SelectSubset<T, ComponentScoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComponentScores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentScoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ComponentScores
     * const componentScore = await prisma.componentScore.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComponentScoreUpdateManyArgs>(args: SelectSubset<T, ComponentScoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComponentScores and returns the data updated in the database.
     * @param {ComponentScoreUpdateManyAndReturnArgs} args - Arguments to update many ComponentScores.
     * @example
     * // Update many ComponentScores
     * const componentScore = await prisma.componentScore.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ComponentScores and only return the `id`
     * const componentScoreWithIdOnly = await prisma.componentScore.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ComponentScoreUpdateManyAndReturnArgs>(args: SelectSubset<T, ComponentScoreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComponentScorePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ComponentScore.
     * @param {ComponentScoreUpsertArgs} args - Arguments to update or create a ComponentScore.
     * @example
     * // Update or create a ComponentScore
     * const componentScore = await prisma.componentScore.upsert({
     *   create: {
     *     // ... data to create a ComponentScore
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ComponentScore we want to update
     *   }
     * })
     */
    upsert<T extends ComponentScoreUpsertArgs>(args: SelectSubset<T, ComponentScoreUpsertArgs<ExtArgs>>): Prisma__ComponentScoreClient<$Result.GetResult<Prisma.$ComponentScorePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ComponentScores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentScoreCountArgs} args - Arguments to filter ComponentScores to count.
     * @example
     * // Count the number of ComponentScores
     * const count = await prisma.componentScore.count({
     *   where: {
     *     // ... the filter for the ComponentScores we want to count
     *   }
     * })
    **/
    count<T extends ComponentScoreCountArgs>(
      args?: Subset<T, ComponentScoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComponentScoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ComponentScore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentScoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComponentScoreAggregateArgs>(args: Subset<T, ComponentScoreAggregateArgs>): Prisma.PrismaPromise<GetComponentScoreAggregateType<T>>

    /**
     * Group by ComponentScore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentScoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComponentScoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComponentScoreGroupByArgs['orderBy'] }
        : { orderBy?: ComponentScoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComponentScoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComponentScoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ComponentScore model
   */
  readonly fields: ComponentScoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ComponentScore.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComponentScoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    component<T extends AssessmentComponentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssessmentComponentDefaultArgs<ExtArgs>>): Prisma__AssessmentComponentClient<$Result.GetResult<Prisma.$AssessmentComponentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    result<T extends ResultDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResultDefaultArgs<ExtArgs>>): Prisma__ResultClient<$Result.GetResult<Prisma.$ResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ComponentScore model
   */ 
  interface ComponentScoreFieldRefs {
    readonly id: FieldRef<"ComponentScore", 'String'>
    readonly score: FieldRef<"ComponentScore", 'Float'>
    readonly componentId: FieldRef<"ComponentScore", 'String'>
    readonly resultId: FieldRef<"ComponentScore", 'String'>
    readonly createdAt: FieldRef<"ComponentScore", 'DateTime'>
    readonly updatedAt: FieldRef<"ComponentScore", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ComponentScore findUnique
   */
  export type ComponentScoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentScore
     */
    select?: ComponentScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentScore
     */
    omit?: ComponentScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentScoreInclude<ExtArgs> | null
    /**
     * Filter, which ComponentScore to fetch.
     */
    where: ComponentScoreWhereUniqueInput
  }

  /**
   * ComponentScore findUniqueOrThrow
   */
  export type ComponentScoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentScore
     */
    select?: ComponentScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentScore
     */
    omit?: ComponentScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentScoreInclude<ExtArgs> | null
    /**
     * Filter, which ComponentScore to fetch.
     */
    where: ComponentScoreWhereUniqueInput
  }

  /**
   * ComponentScore findFirst
   */
  export type ComponentScoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentScore
     */
    select?: ComponentScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentScore
     */
    omit?: ComponentScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentScoreInclude<ExtArgs> | null
    /**
     * Filter, which ComponentScore to fetch.
     */
    where?: ComponentScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComponentScores to fetch.
     */
    orderBy?: ComponentScoreOrderByWithRelationInput | ComponentScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComponentScores.
     */
    cursor?: ComponentScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComponentScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComponentScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComponentScores.
     */
    distinct?: ComponentScoreScalarFieldEnum | ComponentScoreScalarFieldEnum[]
  }

  /**
   * ComponentScore findFirstOrThrow
   */
  export type ComponentScoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentScore
     */
    select?: ComponentScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentScore
     */
    omit?: ComponentScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentScoreInclude<ExtArgs> | null
    /**
     * Filter, which ComponentScore to fetch.
     */
    where?: ComponentScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComponentScores to fetch.
     */
    orderBy?: ComponentScoreOrderByWithRelationInput | ComponentScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComponentScores.
     */
    cursor?: ComponentScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComponentScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComponentScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComponentScores.
     */
    distinct?: ComponentScoreScalarFieldEnum | ComponentScoreScalarFieldEnum[]
  }

  /**
   * ComponentScore findMany
   */
  export type ComponentScoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentScore
     */
    select?: ComponentScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentScore
     */
    omit?: ComponentScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentScoreInclude<ExtArgs> | null
    /**
     * Filter, which ComponentScores to fetch.
     */
    where?: ComponentScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComponentScores to fetch.
     */
    orderBy?: ComponentScoreOrderByWithRelationInput | ComponentScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ComponentScores.
     */
    cursor?: ComponentScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComponentScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComponentScores.
     */
    skip?: number
    distinct?: ComponentScoreScalarFieldEnum | ComponentScoreScalarFieldEnum[]
  }

  /**
   * ComponentScore create
   */
  export type ComponentScoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentScore
     */
    select?: ComponentScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentScore
     */
    omit?: ComponentScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentScoreInclude<ExtArgs> | null
    /**
     * The data needed to create a ComponentScore.
     */
    data: XOR<ComponentScoreCreateInput, ComponentScoreUncheckedCreateInput>
  }

  /**
   * ComponentScore createMany
   */
  export type ComponentScoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ComponentScores.
     */
    data: ComponentScoreCreateManyInput | ComponentScoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComponentScore createManyAndReturn
   */
  export type ComponentScoreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentScore
     */
    select?: ComponentScoreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentScore
     */
    omit?: ComponentScoreOmit<ExtArgs> | null
    /**
     * The data used to create many ComponentScores.
     */
    data: ComponentScoreCreateManyInput | ComponentScoreCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentScoreIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ComponentScore update
   */
  export type ComponentScoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentScore
     */
    select?: ComponentScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentScore
     */
    omit?: ComponentScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentScoreInclude<ExtArgs> | null
    /**
     * The data needed to update a ComponentScore.
     */
    data: XOR<ComponentScoreUpdateInput, ComponentScoreUncheckedUpdateInput>
    /**
     * Choose, which ComponentScore to update.
     */
    where: ComponentScoreWhereUniqueInput
  }

  /**
   * ComponentScore updateMany
   */
  export type ComponentScoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ComponentScores.
     */
    data: XOR<ComponentScoreUpdateManyMutationInput, ComponentScoreUncheckedUpdateManyInput>
    /**
     * Filter which ComponentScores to update
     */
    where?: ComponentScoreWhereInput
    /**
     * Limit how many ComponentScores to update.
     */
    limit?: number
  }

  /**
   * ComponentScore updateManyAndReturn
   */
  export type ComponentScoreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentScore
     */
    select?: ComponentScoreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentScore
     */
    omit?: ComponentScoreOmit<ExtArgs> | null
    /**
     * The data used to update ComponentScores.
     */
    data: XOR<ComponentScoreUpdateManyMutationInput, ComponentScoreUncheckedUpdateManyInput>
    /**
     * Filter which ComponentScores to update
     */
    where?: ComponentScoreWhereInput
    /**
     * Limit how many ComponentScores to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentScoreIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ComponentScore upsert
   */
  export type ComponentScoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentScore
     */
    select?: ComponentScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentScore
     */
    omit?: ComponentScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentScoreInclude<ExtArgs> | null
    /**
     * The filter to search for the ComponentScore to update in case it exists.
     */
    where: ComponentScoreWhereUniqueInput
    /**
     * In case the ComponentScore found by the `where` argument doesn't exist, create a new ComponentScore with this data.
     */
    create: XOR<ComponentScoreCreateInput, ComponentScoreUncheckedCreateInput>
    /**
     * In case the ComponentScore was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComponentScoreUpdateInput, ComponentScoreUncheckedUpdateInput>
  }

  /**
   * ComponentScore delete
   */
  export type ComponentScoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentScore
     */
    select?: ComponentScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentScore
     */
    omit?: ComponentScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentScoreInclude<ExtArgs> | null
    /**
     * Filter which ComponentScore to delete.
     */
    where: ComponentScoreWhereUniqueInput
  }

  /**
   * ComponentScore deleteMany
   */
  export type ComponentScoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComponentScores to delete
     */
    where?: ComponentScoreWhereInput
    /**
     * Limit how many ComponentScores to delete.
     */
    limit?: number
  }

  /**
   * ComponentScore without action
   */
  export type ComponentScoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentScore
     */
    select?: ComponentScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentScore
     */
    omit?: ComponentScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentScoreInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    role: 'role',
    profileImage: 'profileImage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    emailVerified: 'emailVerified',
    image: 'image',
    schoolId: 'schoolId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    adminType: 'adminType',
    permissions: 'permissions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const TeacherScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    employeeId: 'employeeId',
    qualifications: 'qualifications',
    specialization: 'specialization',
    joiningDate: 'joiningDate',
    departmentId: 'departmentId',
    address: 'address',
    city: 'city',
    state: 'state',
    country: 'country',
    phone: 'phone',
    dateOfBirth: 'dateOfBirth',
    gender: 'gender',
    emergencyContact: 'emergencyContact',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeacherScalarFieldEnum = (typeof TeacherScalarFieldEnum)[keyof typeof TeacherScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    admissionDate: 'admissionDate',
    departmentId: 'departmentId',
    address: 'address',
    city: 'city',
    state: 'state',
    country: 'country',
    phone: 'phone',
    dateOfBirth: 'dateOfBirth',
    gender: 'gender',
    religion: 'religion',
    bloodGroup: 'bloodGroup',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    classId: 'classId'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const ParentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    occupation: 'occupation',
    address: 'address',
    city: 'city',
    state: 'state',
    country: 'country',
    phone: 'phone',
    alternatePhone: 'alternatePhone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ParentScalarFieldEnum = (typeof ParentScalarFieldEnum)[keyof typeof ParentScalarFieldEnum]


  export const SchoolScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    phone: 'phone',
    email: 'email',
    logo: 'logo',
    subdomain: 'subdomain',
    primaryColor: 'primaryColor',
    secondaryColor: 'secondaryColor',
    shortName: 'shortName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SchoolScalarFieldEnum = (typeof SchoolScalarFieldEnum)[keyof typeof SchoolScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const ClassScalarFieldEnum: {
    id: 'id',
    name: 'name',
    section: 'section',
    schoolId: 'schoolId',
    teacherId: 'teacherId',
    levelId: 'levelId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClassScalarFieldEnum = (typeof ClassScalarFieldEnum)[keyof typeof ClassScalarFieldEnum]


  export const SubjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    description: 'description',
    schoolId: 'schoolId',
    departmentId: 'departmentId',
    levelId: 'levelId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubjectScalarFieldEnum = (typeof SubjectScalarFieldEnum)[keyof typeof SubjectScalarFieldEnum]


  export const AcademicSessionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    startDate: 'startDate',
    endDate: 'endDate',
    isCurrent: 'isCurrent',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AcademicSessionScalarFieldEnum = (typeof AcademicSessionScalarFieldEnum)[keyof typeof AcademicSessionScalarFieldEnum]


  export const StudentClassScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    classId: 'classId',
    sessionId: 'sessionId',
    rollNumber: 'rollNumber',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentClassScalarFieldEnum = (typeof StudentClassScalarFieldEnum)[keyof typeof StudentClassScalarFieldEnum]


  export const StudentParentScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    parentId: 'parentId',
    relation: 'relation',
    isPrimary: 'isPrimary',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentParentScalarFieldEnum = (typeof StudentParentScalarFieldEnum)[keyof typeof StudentParentScalarFieldEnum]


  export const SubjectTeacherScalarFieldEnum: {
    id: 'id',
    subjectId: 'subjectId',
    teacherId: 'teacherId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubjectTeacherScalarFieldEnum = (typeof SubjectTeacherScalarFieldEnum)[keyof typeof SubjectTeacherScalarFieldEnum]


  export const ClassSubjectScalarFieldEnum: {
    id: 'id',
    classId: 'classId',
    subjectId: 'subjectId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClassSubjectScalarFieldEnum = (typeof ClassSubjectScalarFieldEnum)[keyof typeof ClassSubjectScalarFieldEnum]


  export const AttendanceScalarFieldEnum: {
    id: 'id',
    date: 'date',
    status: 'status',
    studentId: 'studentId',
    sessionId: 'sessionId',
    remarks: 'remarks',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AttendanceScalarFieldEnum = (typeof AttendanceScalarFieldEnum)[keyof typeof AttendanceScalarFieldEnum]


  export const ResultScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    subjectId: 'subjectId',
    periodId: 'periodId',
    sessionId: 'sessionId',
    total: 'total',
    grade: 'grade',
    remark: 'remark',
    cumulativeAverage: 'cumulativeAverage',
    affectiveTraits: 'affectiveTraits',
    psychomotorSkills: 'psychomotorSkills',
    customFields: 'customFields',
    teacherComment: 'teacherComment',
    adminComment: 'adminComment',
    approvedById: 'approvedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ResultScalarFieldEnum = (typeof ResultScalarFieldEnum)[keyof typeof ResultScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    startDate: 'startDate',
    endDate: 'endDate',
    location: 'location',
    isPublic: 'isPublic',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const StudentSubjectScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    subjectId: 'subjectId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentSubjectScalarFieldEnum = (typeof StudentSubjectScalarFieldEnum)[keyof typeof StudentSubjectScalarFieldEnum]


  export const BillScalarFieldEnum: {
    id: 'id',
    name: 'name',
    amount: 'amount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    schoolId: 'schoolId',
    accountId: 'accountId'
  };

  export type BillScalarFieldEnum = (typeof BillScalarFieldEnum)[keyof typeof BillScalarFieldEnum]


  export const BillItemScalarFieldEnum: {
    id: 'id',
    billId: 'billId',
    name: 'name',
    amount: 'amount',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BillItemScalarFieldEnum = (typeof BillItemScalarFieldEnum)[keyof typeof BillItemScalarFieldEnum]


  export const PaymentAccountScalarFieldEnum: {
    id: 'id',
    name: 'name',
    accountNo: 'accountNo',
    bankName: 'bankName',
    branchCode: 'branchCode',
    description: 'description',
    isActive: 'isActive',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentAccountScalarFieldEnum = (typeof PaymentAccountScalarFieldEnum)[keyof typeof PaymentAccountScalarFieldEnum]


  export const BillAssignmentScalarFieldEnum: {
    id: 'id',
    billId: 'billId',
    targetType: 'targetType',
    targetId: 'targetId',
    dueDate: 'dueDate',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BillAssignmentScalarFieldEnum = (typeof BillAssignmentScalarFieldEnum)[keyof typeof BillAssignmentScalarFieldEnum]


  export const StudentPaymentScalarFieldEnum: {
    id: 'id',
    billAssignmentId: 'billAssignmentId',
    studentId: 'studentId',
    amountPaid: 'amountPaid',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentPaymentScalarFieldEnum = (typeof StudentPaymentScalarFieldEnum)[keyof typeof StudentPaymentScalarFieldEnum]


  export const PaymentRequestScalarFieldEnum: {
    id: 'id',
    billId: 'billId',
    billAssignmentId: 'billAssignmentId',
    studentPaymentId: 'studentPaymentId',
    studentId: 'studentId',
    amount: 'amount',
    receiptUrl: 'receiptUrl',
    status: 'status',
    notes: 'notes',
    processedById: 'processedById',
    processedAt: 'processedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentRequestScalarFieldEnum = (typeof PaymentRequestScalarFieldEnum)[keyof typeof PaymentRequestScalarFieldEnum]


  export const SchoolLevelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    order: 'order',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SchoolLevelScalarFieldEnum = (typeof SchoolLevelScalarFieldEnum)[keyof typeof SchoolLevelScalarFieldEnum]


  export const UserActivityLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    page: 'page',
    action: 'action',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type UserActivityLogScalarFieldEnum = (typeof UserActivityLogScalarFieldEnum)[keyof typeof UserActivityLogScalarFieldEnum]


  export const ApiRequestLogScalarFieldEnum: {
    id: 'id',
    route: 'route',
    method: 'method',
    status: 'status',
    duration: 'duration',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type ApiRequestLogScalarFieldEnum = (typeof ApiRequestLogScalarFieldEnum)[keyof typeof ApiRequestLogScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const ResultConfigurationScalarFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    sessionId: 'sessionId',
    cumulativeEnabled: 'cumulativeEnabled',
    cumulativeMethod: 'cumulativeMethod',
    showCumulativePerTerm: 'showCumulativePerTerm',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ResultConfigurationScalarFieldEnum = (typeof ResultConfigurationScalarFieldEnum)[keyof typeof ResultConfigurationScalarFieldEnum]


  export const ResultPeriodScalarFieldEnum: {
    id: 'id',
    name: 'name',
    weight: 'weight',
    configurationId: 'configurationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ResultPeriodScalarFieldEnum = (typeof ResultPeriodScalarFieldEnum)[keyof typeof ResultPeriodScalarFieldEnum]


  export const AssessmentComponentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    key: 'key',
    maxScore: 'maxScore',
    configurationId: 'configurationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AssessmentComponentScalarFieldEnum = (typeof AssessmentComponentScalarFieldEnum)[keyof typeof AssessmentComponentScalarFieldEnum]


  export const GradingScaleScalarFieldEnum: {
    id: 'id',
    minScore: 'minScore',
    maxScore: 'maxScore',
    grade: 'grade',
    remark: 'remark',
    configurationId: 'configurationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GradingScaleScalarFieldEnum = (typeof GradingScaleScalarFieldEnum)[keyof typeof GradingScaleScalarFieldEnum]


  export const ComponentScoreScalarFieldEnum: {
    id: 'id',
    score: 'score',
    componentId: 'componentId',
    resultId: 'resultId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ComponentScoreScalarFieldEnum = (typeof ComponentScoreScalarFieldEnum)[keyof typeof ComponentScoreScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'AdminType'
   */
  export type EnumAdminTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminType'>
    


  /**
   * Reference to a field of type 'AdminType[]'
   */
  export type ListEnumAdminTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'EnrollmentStatus'
   */
  export type EnumEnrollmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnrollmentStatus'>
    


  /**
   * Reference to a field of type 'EnrollmentStatus[]'
   */
  export type ListEnumEnrollmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnrollmentStatus[]'>
    


  /**
   * Reference to a field of type 'AttendanceStatus'
   */
  export type EnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus'>
    


  /**
   * Reference to a field of type 'AttendanceStatus[]'
   */
  export type ListEnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'BillAssignmentType'
   */
  export type EnumBillAssignmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillAssignmentType'>
    


  /**
   * Reference to a field of type 'BillAssignmentType[]'
   */
  export type ListEnumBillAssignmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillAssignmentType[]'>
    


  /**
   * Reference to a field of type 'BillStatus'
   */
  export type EnumBillStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillStatus'>
    


  /**
   * Reference to a field of type 'BillStatus[]'
   */
  export type ListEnumBillStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    profileImage?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    schoolId?: StringNullableFilter<"User"> | string | null
    accounts?: AccountListRelationFilter
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    parent?: XOR<ParentNullableScalarRelationFilter, ParentWhereInput> | null
    processedPayments?: PaymentRequestListRelationFilter
    approvedResults?: ResultListRelationFilter
    sessions?: SessionListRelationFilter
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    teacher?: XOR<TeacherNullableScalarRelationFilter, TeacherWhereInput> | null
    school?: XOR<SchoolNullableScalarRelationFilter, SchoolWhereInput> | null
    activityLogs?: UserActivityLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    schoolId?: SortOrderInput | SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    admin?: AdminOrderByWithRelationInput
    parent?: ParentOrderByWithRelationInput
    processedPayments?: PaymentRequestOrderByRelationAggregateInput
    approvedResults?: ResultOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    student?: StudentOrderByWithRelationInput
    teacher?: TeacherOrderByWithRelationInput
    school?: SchoolOrderByWithRelationInput
    activityLogs?: UserActivityLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    profileImage?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    schoolId?: StringNullableFilter<"User"> | string | null
    accounts?: AccountListRelationFilter
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    parent?: XOR<ParentNullableScalarRelationFilter, ParentWhereInput> | null
    processedPayments?: PaymentRequestListRelationFilter
    approvedResults?: ResultListRelationFilter
    sessions?: SessionListRelationFilter
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    teacher?: XOR<TeacherNullableScalarRelationFilter, TeacherWhereInput> | null
    school?: XOR<SchoolNullableScalarRelationFilter, SchoolWhereInput> | null
    activityLogs?: UserActivityLogListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    schoolId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    profileImage?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    schoolId?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: StringFilter<"Admin"> | string
    userId?: StringFilter<"Admin"> | string
    adminType?: EnumAdminTypeFilter<"Admin"> | $Enums.AdminType
    permissions?: JsonNullableFilter<"Admin">
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    adminType?: SortOrder
    permissions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    adminType?: EnumAdminTypeFilter<"Admin"> | $Enums.AdminType
    permissions?: JsonNullableFilter<"Admin">
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    adminType?: SortOrder
    permissions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Admin"> | string
    userId?: StringWithAggregatesFilter<"Admin"> | string
    adminType?: EnumAdminTypeWithAggregatesFilter<"Admin"> | $Enums.AdminType
    permissions?: JsonNullableWithAggregatesFilter<"Admin">
    createdAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
  }

  export type TeacherWhereInput = {
    AND?: TeacherWhereInput | TeacherWhereInput[]
    OR?: TeacherWhereInput[]
    NOT?: TeacherWhereInput | TeacherWhereInput[]
    id?: StringFilter<"Teacher"> | string
    userId?: StringFilter<"Teacher"> | string
    employeeId?: StringNullableFilter<"Teacher"> | string | null
    qualifications?: StringNullableFilter<"Teacher"> | string | null
    specialization?: StringNullableFilter<"Teacher"> | string | null
    joiningDate?: DateTimeNullableFilter<"Teacher"> | Date | string | null
    departmentId?: StringNullableFilter<"Teacher"> | string | null
    address?: StringNullableFilter<"Teacher"> | string | null
    city?: StringNullableFilter<"Teacher"> | string | null
    state?: StringNullableFilter<"Teacher"> | string | null
    country?: StringNullableFilter<"Teacher"> | string | null
    phone?: StringNullableFilter<"Teacher"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Teacher"> | Date | string | null
    gender?: StringNullableFilter<"Teacher"> | string | null
    emergencyContact?: StringNullableFilter<"Teacher"> | string | null
    createdAt?: DateTimeFilter<"Teacher"> | Date | string
    updatedAt?: DateTimeFilter<"Teacher"> | Date | string
    classes?: ClassListRelationFilter
    subjects?: SubjectTeacherListRelationFilter
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TeacherOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    employeeId?: SortOrderInput | SortOrder
    qualifications?: SortOrderInput | SortOrder
    specialization?: SortOrderInput | SortOrder
    joiningDate?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    classes?: ClassOrderByRelationAggregateInput
    subjects?: SubjectTeacherOrderByRelationAggregateInput
    department?: DepartmentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TeacherWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    employeeId?: string
    AND?: TeacherWhereInput | TeacherWhereInput[]
    OR?: TeacherWhereInput[]
    NOT?: TeacherWhereInput | TeacherWhereInput[]
    qualifications?: StringNullableFilter<"Teacher"> | string | null
    specialization?: StringNullableFilter<"Teacher"> | string | null
    joiningDate?: DateTimeNullableFilter<"Teacher"> | Date | string | null
    departmentId?: StringNullableFilter<"Teacher"> | string | null
    address?: StringNullableFilter<"Teacher"> | string | null
    city?: StringNullableFilter<"Teacher"> | string | null
    state?: StringNullableFilter<"Teacher"> | string | null
    country?: StringNullableFilter<"Teacher"> | string | null
    phone?: StringNullableFilter<"Teacher"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Teacher"> | Date | string | null
    gender?: StringNullableFilter<"Teacher"> | string | null
    emergencyContact?: StringNullableFilter<"Teacher"> | string | null
    createdAt?: DateTimeFilter<"Teacher"> | Date | string
    updatedAt?: DateTimeFilter<"Teacher"> | Date | string
    classes?: ClassListRelationFilter
    subjects?: SubjectTeacherListRelationFilter
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId" | "employeeId">

  export type TeacherOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    employeeId?: SortOrderInput | SortOrder
    qualifications?: SortOrderInput | SortOrder
    specialization?: SortOrderInput | SortOrder
    joiningDate?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeacherCountOrderByAggregateInput
    _max?: TeacherMaxOrderByAggregateInput
    _min?: TeacherMinOrderByAggregateInput
  }

  export type TeacherScalarWhereWithAggregatesInput = {
    AND?: TeacherScalarWhereWithAggregatesInput | TeacherScalarWhereWithAggregatesInput[]
    OR?: TeacherScalarWhereWithAggregatesInput[]
    NOT?: TeacherScalarWhereWithAggregatesInput | TeacherScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Teacher"> | string
    userId?: StringWithAggregatesFilter<"Teacher"> | string
    employeeId?: StringNullableWithAggregatesFilter<"Teacher"> | string | null
    qualifications?: StringNullableWithAggregatesFilter<"Teacher"> | string | null
    specialization?: StringNullableWithAggregatesFilter<"Teacher"> | string | null
    joiningDate?: DateTimeNullableWithAggregatesFilter<"Teacher"> | Date | string | null
    departmentId?: StringNullableWithAggregatesFilter<"Teacher"> | string | null
    address?: StringNullableWithAggregatesFilter<"Teacher"> | string | null
    city?: StringNullableWithAggregatesFilter<"Teacher"> | string | null
    state?: StringNullableWithAggregatesFilter<"Teacher"> | string | null
    country?: StringNullableWithAggregatesFilter<"Teacher"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Teacher"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"Teacher"> | Date | string | null
    gender?: StringNullableWithAggregatesFilter<"Teacher"> | string | null
    emergencyContact?: StringNullableWithAggregatesFilter<"Teacher"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Teacher"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Teacher"> | Date | string
  }

  export type StudentWhereInput = {
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    id?: StringFilter<"Student"> | string
    userId?: StringFilter<"Student"> | string
    admissionDate?: DateTimeNullableFilter<"Student"> | Date | string | null
    departmentId?: StringNullableFilter<"Student"> | string | null
    address?: StringNullableFilter<"Student"> | string | null
    city?: StringNullableFilter<"Student"> | string | null
    state?: StringNullableFilter<"Student"> | string | null
    country?: StringNullableFilter<"Student"> | string | null
    phone?: StringNullableFilter<"Student"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Student"> | Date | string | null
    gender?: StringNullableFilter<"Student"> | string | null
    religion?: StringNullableFilter<"Student"> | string | null
    bloodGroup?: StringNullableFilter<"Student"> | string | null
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    classId?: StringNullableFilter<"Student"> | string | null
    attendance?: AttendanceListRelationFilter
    paymentRequests?: PaymentRequestListRelationFilter
    results?: ResultListRelationFilter
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    classes?: StudentClassListRelationFilter
    parents?: StudentParentListRelationFilter
    payments?: StudentPaymentListRelationFilter
    subjects?: StudentSubjectListRelationFilter
  }

  export type StudentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    admissionDate?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    religion?: SortOrderInput | SortOrder
    bloodGroup?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    classId?: SortOrderInput | SortOrder
    attendance?: AttendanceOrderByRelationAggregateInput
    paymentRequests?: PaymentRequestOrderByRelationAggregateInput
    results?: ResultOrderByRelationAggregateInput
    department?: DepartmentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    classes?: StudentClassOrderByRelationAggregateInput
    parents?: StudentParentOrderByRelationAggregateInput
    payments?: StudentPaymentOrderByRelationAggregateInput
    subjects?: StudentSubjectOrderByRelationAggregateInput
  }

  export type StudentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    admissionDate?: DateTimeNullableFilter<"Student"> | Date | string | null
    departmentId?: StringNullableFilter<"Student"> | string | null
    address?: StringNullableFilter<"Student"> | string | null
    city?: StringNullableFilter<"Student"> | string | null
    state?: StringNullableFilter<"Student"> | string | null
    country?: StringNullableFilter<"Student"> | string | null
    phone?: StringNullableFilter<"Student"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Student"> | Date | string | null
    gender?: StringNullableFilter<"Student"> | string | null
    religion?: StringNullableFilter<"Student"> | string | null
    bloodGroup?: StringNullableFilter<"Student"> | string | null
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    classId?: StringNullableFilter<"Student"> | string | null
    attendance?: AttendanceListRelationFilter
    paymentRequests?: PaymentRequestListRelationFilter
    results?: ResultListRelationFilter
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    classes?: StudentClassListRelationFilter
    parents?: StudentParentListRelationFilter
    payments?: StudentPaymentListRelationFilter
    subjects?: StudentSubjectListRelationFilter
  }, "id" | "userId">

  export type StudentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    admissionDate?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    religion?: SortOrderInput | SortOrder
    bloodGroup?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    classId?: SortOrderInput | SortOrder
    _count?: StudentCountOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    OR?: StudentScalarWhereWithAggregatesInput[]
    NOT?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Student"> | string
    userId?: StringWithAggregatesFilter<"Student"> | string
    admissionDate?: DateTimeNullableWithAggregatesFilter<"Student"> | Date | string | null
    departmentId?: StringNullableWithAggregatesFilter<"Student"> | string | null
    address?: StringNullableWithAggregatesFilter<"Student"> | string | null
    city?: StringNullableWithAggregatesFilter<"Student"> | string | null
    state?: StringNullableWithAggregatesFilter<"Student"> | string | null
    country?: StringNullableWithAggregatesFilter<"Student"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Student"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"Student"> | Date | string | null
    gender?: StringNullableWithAggregatesFilter<"Student"> | string | null
    religion?: StringNullableWithAggregatesFilter<"Student"> | string | null
    bloodGroup?: StringNullableWithAggregatesFilter<"Student"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    classId?: StringNullableWithAggregatesFilter<"Student"> | string | null
  }

  export type ParentWhereInput = {
    AND?: ParentWhereInput | ParentWhereInput[]
    OR?: ParentWhereInput[]
    NOT?: ParentWhereInput | ParentWhereInput[]
    id?: StringFilter<"Parent"> | string
    userId?: StringFilter<"Parent"> | string
    occupation?: StringNullableFilter<"Parent"> | string | null
    address?: StringNullableFilter<"Parent"> | string | null
    city?: StringNullableFilter<"Parent"> | string | null
    state?: StringNullableFilter<"Parent"> | string | null
    country?: StringNullableFilter<"Parent"> | string | null
    phone?: StringNullableFilter<"Parent"> | string | null
    alternatePhone?: StringNullableFilter<"Parent"> | string | null
    createdAt?: DateTimeFilter<"Parent"> | Date | string
    updatedAt?: DateTimeFilter<"Parent"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    children?: StudentParentListRelationFilter
  }

  export type ParentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    occupation?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    alternatePhone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    children?: StudentParentOrderByRelationAggregateInput
  }

  export type ParentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ParentWhereInput | ParentWhereInput[]
    OR?: ParentWhereInput[]
    NOT?: ParentWhereInput | ParentWhereInput[]
    occupation?: StringNullableFilter<"Parent"> | string | null
    address?: StringNullableFilter<"Parent"> | string | null
    city?: StringNullableFilter<"Parent"> | string | null
    state?: StringNullableFilter<"Parent"> | string | null
    country?: StringNullableFilter<"Parent"> | string | null
    phone?: StringNullableFilter<"Parent"> | string | null
    alternatePhone?: StringNullableFilter<"Parent"> | string | null
    createdAt?: DateTimeFilter<"Parent"> | Date | string
    updatedAt?: DateTimeFilter<"Parent"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    children?: StudentParentListRelationFilter
  }, "id" | "userId">

  export type ParentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    occupation?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    alternatePhone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ParentCountOrderByAggregateInput
    _max?: ParentMaxOrderByAggregateInput
    _min?: ParentMinOrderByAggregateInput
  }

  export type ParentScalarWhereWithAggregatesInput = {
    AND?: ParentScalarWhereWithAggregatesInput | ParentScalarWhereWithAggregatesInput[]
    OR?: ParentScalarWhereWithAggregatesInput[]
    NOT?: ParentScalarWhereWithAggregatesInput | ParentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Parent"> | string
    userId?: StringWithAggregatesFilter<"Parent"> | string
    occupation?: StringNullableWithAggregatesFilter<"Parent"> | string | null
    address?: StringNullableWithAggregatesFilter<"Parent"> | string | null
    city?: StringNullableWithAggregatesFilter<"Parent"> | string | null
    state?: StringNullableWithAggregatesFilter<"Parent"> | string | null
    country?: StringNullableWithAggregatesFilter<"Parent"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Parent"> | string | null
    alternatePhone?: StringNullableWithAggregatesFilter<"Parent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Parent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Parent"> | Date | string
  }

  export type SchoolWhereInput = {
    AND?: SchoolWhereInput | SchoolWhereInput[]
    OR?: SchoolWhereInput[]
    NOT?: SchoolWhereInput | SchoolWhereInput[]
    id?: StringFilter<"School"> | string
    name?: StringFilter<"School"> | string
    address?: StringNullableFilter<"School"> | string | null
    phone?: StringNullableFilter<"School"> | string | null
    email?: StringFilter<"School"> | string
    logo?: StringNullableFilter<"School"> | string | null
    subdomain?: StringFilter<"School"> | string
    primaryColor?: StringNullableFilter<"School"> | string | null
    secondaryColor?: StringNullableFilter<"School"> | string | null
    shortName?: StringFilter<"School"> | string
    createdAt?: DateTimeFilter<"School"> | Date | string
    updatedAt?: DateTimeFilter<"School"> | Date | string
    sessions?: AcademicSessionListRelationFilter
    bills?: BillListRelationFilter
    classes?: ClassListRelationFilter
    departments?: DepartmentListRelationFilter
    events?: EventListRelationFilter
    paymentAccounts?: PaymentAccountListRelationFilter
    levels?: SchoolLevelListRelationFilter
    subjects?: SubjectListRelationFilter
    users?: UserListRelationFilter
    resultConfigs?: ResultConfigurationListRelationFilter
  }

  export type SchoolOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrder
    logo?: SortOrderInput | SortOrder
    subdomain?: SortOrder
    primaryColor?: SortOrderInput | SortOrder
    secondaryColor?: SortOrderInput | SortOrder
    shortName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessions?: AcademicSessionOrderByRelationAggregateInput
    bills?: BillOrderByRelationAggregateInput
    classes?: ClassOrderByRelationAggregateInput
    departments?: DepartmentOrderByRelationAggregateInput
    events?: EventOrderByRelationAggregateInput
    paymentAccounts?: PaymentAccountOrderByRelationAggregateInput
    levels?: SchoolLevelOrderByRelationAggregateInput
    subjects?: SubjectOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    resultConfigs?: ResultConfigurationOrderByRelationAggregateInput
  }

  export type SchoolWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    subdomain?: string
    shortName?: string
    AND?: SchoolWhereInput | SchoolWhereInput[]
    OR?: SchoolWhereInput[]
    NOT?: SchoolWhereInput | SchoolWhereInput[]
    name?: StringFilter<"School"> | string
    address?: StringNullableFilter<"School"> | string | null
    phone?: StringNullableFilter<"School"> | string | null
    logo?: StringNullableFilter<"School"> | string | null
    primaryColor?: StringNullableFilter<"School"> | string | null
    secondaryColor?: StringNullableFilter<"School"> | string | null
    createdAt?: DateTimeFilter<"School"> | Date | string
    updatedAt?: DateTimeFilter<"School"> | Date | string
    sessions?: AcademicSessionListRelationFilter
    bills?: BillListRelationFilter
    classes?: ClassListRelationFilter
    departments?: DepartmentListRelationFilter
    events?: EventListRelationFilter
    paymentAccounts?: PaymentAccountListRelationFilter
    levels?: SchoolLevelListRelationFilter
    subjects?: SubjectListRelationFilter
    users?: UserListRelationFilter
    resultConfigs?: ResultConfigurationListRelationFilter
  }, "id" | "email" | "subdomain" | "shortName">

  export type SchoolOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrder
    logo?: SortOrderInput | SortOrder
    subdomain?: SortOrder
    primaryColor?: SortOrderInput | SortOrder
    secondaryColor?: SortOrderInput | SortOrder
    shortName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SchoolCountOrderByAggregateInput
    _max?: SchoolMaxOrderByAggregateInput
    _min?: SchoolMinOrderByAggregateInput
  }

  export type SchoolScalarWhereWithAggregatesInput = {
    AND?: SchoolScalarWhereWithAggregatesInput | SchoolScalarWhereWithAggregatesInput[]
    OR?: SchoolScalarWhereWithAggregatesInput[]
    NOT?: SchoolScalarWhereWithAggregatesInput | SchoolScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"School"> | string
    name?: StringWithAggregatesFilter<"School"> | string
    address?: StringNullableWithAggregatesFilter<"School"> | string | null
    phone?: StringNullableWithAggregatesFilter<"School"> | string | null
    email?: StringWithAggregatesFilter<"School"> | string
    logo?: StringNullableWithAggregatesFilter<"School"> | string | null
    subdomain?: StringWithAggregatesFilter<"School"> | string
    primaryColor?: StringNullableWithAggregatesFilter<"School"> | string | null
    secondaryColor?: StringNullableWithAggregatesFilter<"School"> | string | null
    shortName?: StringWithAggregatesFilter<"School"> | string
    createdAt?: DateTimeWithAggregatesFilter<"School"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"School"> | Date | string
  }

  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    id?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    description?: StringNullableFilter<"Department"> | string | null
    schoolId?: StringFilter<"Department"> | string
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    students?: StudentListRelationFilter
    subjects?: SubjectListRelationFilter
    teachers?: TeacherListRelationFilter
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    students?: StudentOrderByRelationAggregateInput
    subjects?: SubjectOrderByRelationAggregateInput
    teachers?: TeacherOrderByRelationAggregateInput
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    name?: StringFilter<"Department"> | string
    description?: StringNullableFilter<"Department"> | string | null
    schoolId?: StringFilter<"Department"> | string
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    students?: StudentListRelationFilter
    subjects?: SubjectListRelationFilter
    teachers?: TeacherListRelationFilter
  }, "id">

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Department"> | string
    name?: StringWithAggregatesFilter<"Department"> | string
    description?: StringNullableWithAggregatesFilter<"Department"> | string | null
    schoolId?: StringWithAggregatesFilter<"Department"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
  }

  export type ClassWhereInput = {
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    id?: StringFilter<"Class"> | string
    name?: StringFilter<"Class"> | string
    section?: StringNullableFilter<"Class"> | string | null
    schoolId?: StringFilter<"Class"> | string
    teacherId?: StringNullableFilter<"Class"> | string | null
    levelId?: StringNullableFilter<"Class"> | string | null
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
    level?: XOR<SchoolLevelNullableScalarRelationFilter, SchoolLevelWhereInput> | null
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    teacher?: XOR<TeacherNullableScalarRelationFilter, TeacherWhereInput> | null
    subjects?: ClassSubjectListRelationFilter
    students?: StudentClassListRelationFilter
  }

  export type ClassOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    section?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    teacherId?: SortOrderInput | SortOrder
    levelId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    level?: SchoolLevelOrderByWithRelationInput
    school?: SchoolOrderByWithRelationInput
    teacher?: TeacherOrderByWithRelationInput
    subjects?: ClassSubjectOrderByRelationAggregateInput
    students?: StudentClassOrderByRelationAggregateInput
  }

  export type ClassWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    name?: StringFilter<"Class"> | string
    section?: StringNullableFilter<"Class"> | string | null
    schoolId?: StringFilter<"Class"> | string
    teacherId?: StringNullableFilter<"Class"> | string | null
    levelId?: StringNullableFilter<"Class"> | string | null
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
    level?: XOR<SchoolLevelNullableScalarRelationFilter, SchoolLevelWhereInput> | null
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    teacher?: XOR<TeacherNullableScalarRelationFilter, TeacherWhereInput> | null
    subjects?: ClassSubjectListRelationFilter
    students?: StudentClassListRelationFilter
  }, "id">

  export type ClassOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    section?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    teacherId?: SortOrderInput | SortOrder
    levelId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClassCountOrderByAggregateInput
    _max?: ClassMaxOrderByAggregateInput
    _min?: ClassMinOrderByAggregateInput
  }

  export type ClassScalarWhereWithAggregatesInput = {
    AND?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    OR?: ClassScalarWhereWithAggregatesInput[]
    NOT?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Class"> | string
    name?: StringWithAggregatesFilter<"Class"> | string
    section?: StringNullableWithAggregatesFilter<"Class"> | string | null
    schoolId?: StringWithAggregatesFilter<"Class"> | string
    teacherId?: StringNullableWithAggregatesFilter<"Class"> | string | null
    levelId?: StringNullableWithAggregatesFilter<"Class"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Class"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Class"> | Date | string
  }

  export type SubjectWhereInput = {
    AND?: SubjectWhereInput | SubjectWhereInput[]
    OR?: SubjectWhereInput[]
    NOT?: SubjectWhereInput | SubjectWhereInput[]
    id?: StringFilter<"Subject"> | string
    name?: StringFilter<"Subject"> | string
    code?: StringNullableFilter<"Subject"> | string | null
    description?: StringNullableFilter<"Subject"> | string | null
    schoolId?: StringFilter<"Subject"> | string
    departmentId?: StringNullableFilter<"Subject"> | string | null
    levelId?: StringNullableFilter<"Subject"> | string | null
    createdAt?: DateTimeFilter<"Subject"> | Date | string
    updatedAt?: DateTimeFilter<"Subject"> | Date | string
    classes?: ClassSubjectListRelationFilter
    results?: ResultListRelationFilter
    students?: StudentSubjectListRelationFilter
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    level?: XOR<SchoolLevelNullableScalarRelationFilter, SchoolLevelWhereInput> | null
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    teachers?: SubjectTeacherListRelationFilter
  }

  export type SubjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    levelId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    classes?: ClassSubjectOrderByRelationAggregateInput
    results?: ResultOrderByRelationAggregateInput
    students?: StudentSubjectOrderByRelationAggregateInput
    department?: DepartmentOrderByWithRelationInput
    level?: SchoolLevelOrderByWithRelationInput
    school?: SchoolOrderByWithRelationInput
    teachers?: SubjectTeacherOrderByRelationAggregateInput
  }

  export type SubjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: SubjectWhereInput | SubjectWhereInput[]
    OR?: SubjectWhereInput[]
    NOT?: SubjectWhereInput | SubjectWhereInput[]
    name?: StringFilter<"Subject"> | string
    description?: StringNullableFilter<"Subject"> | string | null
    schoolId?: StringFilter<"Subject"> | string
    departmentId?: StringNullableFilter<"Subject"> | string | null
    levelId?: StringNullableFilter<"Subject"> | string | null
    createdAt?: DateTimeFilter<"Subject"> | Date | string
    updatedAt?: DateTimeFilter<"Subject"> | Date | string
    classes?: ClassSubjectListRelationFilter
    results?: ResultListRelationFilter
    students?: StudentSubjectListRelationFilter
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    level?: XOR<SchoolLevelNullableScalarRelationFilter, SchoolLevelWhereInput> | null
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    teachers?: SubjectTeacherListRelationFilter
  }, "id" | "code">

  export type SubjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    levelId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubjectCountOrderByAggregateInput
    _max?: SubjectMaxOrderByAggregateInput
    _min?: SubjectMinOrderByAggregateInput
  }

  export type SubjectScalarWhereWithAggregatesInput = {
    AND?: SubjectScalarWhereWithAggregatesInput | SubjectScalarWhereWithAggregatesInput[]
    OR?: SubjectScalarWhereWithAggregatesInput[]
    NOT?: SubjectScalarWhereWithAggregatesInput | SubjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subject"> | string
    name?: StringWithAggregatesFilter<"Subject"> | string
    code?: StringNullableWithAggregatesFilter<"Subject"> | string | null
    description?: StringNullableWithAggregatesFilter<"Subject"> | string | null
    schoolId?: StringWithAggregatesFilter<"Subject"> | string
    departmentId?: StringNullableWithAggregatesFilter<"Subject"> | string | null
    levelId?: StringNullableWithAggregatesFilter<"Subject"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Subject"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subject"> | Date | string
  }

  export type AcademicSessionWhereInput = {
    AND?: AcademicSessionWhereInput | AcademicSessionWhereInput[]
    OR?: AcademicSessionWhereInput[]
    NOT?: AcademicSessionWhereInput | AcademicSessionWhereInput[]
    id?: StringFilter<"AcademicSession"> | string
    name?: StringFilter<"AcademicSession"> | string
    startDate?: DateTimeFilter<"AcademicSession"> | Date | string
    endDate?: DateTimeFilter<"AcademicSession"> | Date | string
    isCurrent?: BoolFilter<"AcademicSession"> | boolean
    schoolId?: StringFilter<"AcademicSession"> | string
    createdAt?: DateTimeFilter<"AcademicSession"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicSession"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    attendance?: AttendanceListRelationFilter
    results?: ResultListRelationFilter
    studentClasses?: StudentClassListRelationFilter
    resultConfigurations?: ResultConfigurationListRelationFilter
  }

  export type AcademicSessionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isCurrent?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    attendance?: AttendanceOrderByRelationAggregateInput
    results?: ResultOrderByRelationAggregateInput
    studentClasses?: StudentClassOrderByRelationAggregateInput
    resultConfigurations?: ResultConfigurationOrderByRelationAggregateInput
  }

  export type AcademicSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AcademicSessionWhereInput | AcademicSessionWhereInput[]
    OR?: AcademicSessionWhereInput[]
    NOT?: AcademicSessionWhereInput | AcademicSessionWhereInput[]
    name?: StringFilter<"AcademicSession"> | string
    startDate?: DateTimeFilter<"AcademicSession"> | Date | string
    endDate?: DateTimeFilter<"AcademicSession"> | Date | string
    isCurrent?: BoolFilter<"AcademicSession"> | boolean
    schoolId?: StringFilter<"AcademicSession"> | string
    createdAt?: DateTimeFilter<"AcademicSession"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicSession"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    attendance?: AttendanceListRelationFilter
    results?: ResultListRelationFilter
    studentClasses?: StudentClassListRelationFilter
    resultConfigurations?: ResultConfigurationListRelationFilter
  }, "id">

  export type AcademicSessionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isCurrent?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AcademicSessionCountOrderByAggregateInput
    _max?: AcademicSessionMaxOrderByAggregateInput
    _min?: AcademicSessionMinOrderByAggregateInput
  }

  export type AcademicSessionScalarWhereWithAggregatesInput = {
    AND?: AcademicSessionScalarWhereWithAggregatesInput | AcademicSessionScalarWhereWithAggregatesInput[]
    OR?: AcademicSessionScalarWhereWithAggregatesInput[]
    NOT?: AcademicSessionScalarWhereWithAggregatesInput | AcademicSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AcademicSession"> | string
    name?: StringWithAggregatesFilter<"AcademicSession"> | string
    startDate?: DateTimeWithAggregatesFilter<"AcademicSession"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"AcademicSession"> | Date | string
    isCurrent?: BoolWithAggregatesFilter<"AcademicSession"> | boolean
    schoolId?: StringWithAggregatesFilter<"AcademicSession"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AcademicSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AcademicSession"> | Date | string
  }

  export type StudentClassWhereInput = {
    AND?: StudentClassWhereInput | StudentClassWhereInput[]
    OR?: StudentClassWhereInput[]
    NOT?: StudentClassWhereInput | StudentClassWhereInput[]
    id?: StringFilter<"StudentClass"> | string
    studentId?: StringFilter<"StudentClass"> | string
    classId?: StringFilter<"StudentClass"> | string
    sessionId?: StringFilter<"StudentClass"> | string
    rollNumber?: StringNullableFilter<"StudentClass"> | string | null
    status?: EnumEnrollmentStatusFilter<"StudentClass"> | $Enums.EnrollmentStatus
    createdAt?: DateTimeFilter<"StudentClass"> | Date | string
    updatedAt?: DateTimeFilter<"StudentClass"> | Date | string
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    session?: XOR<AcademicSessionScalarRelationFilter, AcademicSessionWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }

  export type StudentClassOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    sessionId?: SortOrder
    rollNumber?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    class?: ClassOrderByWithRelationInput
    session?: AcademicSessionOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
  }

  export type StudentClassWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId_classId_sessionId?: StudentClassStudentIdClassIdSessionIdCompoundUniqueInput
    AND?: StudentClassWhereInput | StudentClassWhereInput[]
    OR?: StudentClassWhereInput[]
    NOT?: StudentClassWhereInput | StudentClassWhereInput[]
    studentId?: StringFilter<"StudentClass"> | string
    classId?: StringFilter<"StudentClass"> | string
    sessionId?: StringFilter<"StudentClass"> | string
    rollNumber?: StringNullableFilter<"StudentClass"> | string | null
    status?: EnumEnrollmentStatusFilter<"StudentClass"> | $Enums.EnrollmentStatus
    createdAt?: DateTimeFilter<"StudentClass"> | Date | string
    updatedAt?: DateTimeFilter<"StudentClass"> | Date | string
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    session?: XOR<AcademicSessionScalarRelationFilter, AcademicSessionWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }, "id" | "studentId_classId_sessionId">

  export type StudentClassOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    sessionId?: SortOrder
    rollNumber?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentClassCountOrderByAggregateInput
    _max?: StudentClassMaxOrderByAggregateInput
    _min?: StudentClassMinOrderByAggregateInput
  }

  export type StudentClassScalarWhereWithAggregatesInput = {
    AND?: StudentClassScalarWhereWithAggregatesInput | StudentClassScalarWhereWithAggregatesInput[]
    OR?: StudentClassScalarWhereWithAggregatesInput[]
    NOT?: StudentClassScalarWhereWithAggregatesInput | StudentClassScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentClass"> | string
    studentId?: StringWithAggregatesFilter<"StudentClass"> | string
    classId?: StringWithAggregatesFilter<"StudentClass"> | string
    sessionId?: StringWithAggregatesFilter<"StudentClass"> | string
    rollNumber?: StringNullableWithAggregatesFilter<"StudentClass"> | string | null
    status?: EnumEnrollmentStatusWithAggregatesFilter<"StudentClass"> | $Enums.EnrollmentStatus
    createdAt?: DateTimeWithAggregatesFilter<"StudentClass"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentClass"> | Date | string
  }

  export type StudentParentWhereInput = {
    AND?: StudentParentWhereInput | StudentParentWhereInput[]
    OR?: StudentParentWhereInput[]
    NOT?: StudentParentWhereInput | StudentParentWhereInput[]
    id?: StringFilter<"StudentParent"> | string
    studentId?: StringFilter<"StudentParent"> | string
    parentId?: StringFilter<"StudentParent"> | string
    relation?: StringNullableFilter<"StudentParent"> | string | null
    isPrimary?: BoolFilter<"StudentParent"> | boolean
    createdAt?: DateTimeFilter<"StudentParent"> | Date | string
    updatedAt?: DateTimeFilter<"StudentParent"> | Date | string
    parent?: XOR<ParentScalarRelationFilter, ParentWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }

  export type StudentParentOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    parentId?: SortOrder
    relation?: SortOrderInput | SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parent?: ParentOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
  }

  export type StudentParentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId_parentId?: StudentParentStudentIdParentIdCompoundUniqueInput
    AND?: StudentParentWhereInput | StudentParentWhereInput[]
    OR?: StudentParentWhereInput[]
    NOT?: StudentParentWhereInput | StudentParentWhereInput[]
    studentId?: StringFilter<"StudentParent"> | string
    parentId?: StringFilter<"StudentParent"> | string
    relation?: StringNullableFilter<"StudentParent"> | string | null
    isPrimary?: BoolFilter<"StudentParent"> | boolean
    createdAt?: DateTimeFilter<"StudentParent"> | Date | string
    updatedAt?: DateTimeFilter<"StudentParent"> | Date | string
    parent?: XOR<ParentScalarRelationFilter, ParentWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }, "id" | "studentId_parentId">

  export type StudentParentOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    parentId?: SortOrder
    relation?: SortOrderInput | SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentParentCountOrderByAggregateInput
    _max?: StudentParentMaxOrderByAggregateInput
    _min?: StudentParentMinOrderByAggregateInput
  }

  export type StudentParentScalarWhereWithAggregatesInput = {
    AND?: StudentParentScalarWhereWithAggregatesInput | StudentParentScalarWhereWithAggregatesInput[]
    OR?: StudentParentScalarWhereWithAggregatesInput[]
    NOT?: StudentParentScalarWhereWithAggregatesInput | StudentParentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentParent"> | string
    studentId?: StringWithAggregatesFilter<"StudentParent"> | string
    parentId?: StringWithAggregatesFilter<"StudentParent"> | string
    relation?: StringNullableWithAggregatesFilter<"StudentParent"> | string | null
    isPrimary?: BoolWithAggregatesFilter<"StudentParent"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"StudentParent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentParent"> | Date | string
  }

  export type SubjectTeacherWhereInput = {
    AND?: SubjectTeacherWhereInput | SubjectTeacherWhereInput[]
    OR?: SubjectTeacherWhereInput[]
    NOT?: SubjectTeacherWhereInput | SubjectTeacherWhereInput[]
    id?: StringFilter<"SubjectTeacher"> | string
    subjectId?: StringFilter<"SubjectTeacher"> | string
    teacherId?: StringFilter<"SubjectTeacher"> | string
    createdAt?: DateTimeFilter<"SubjectTeacher"> | Date | string
    updatedAt?: DateTimeFilter<"SubjectTeacher"> | Date | string
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    teacher?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
  }

  export type SubjectTeacherOrderByWithRelationInput = {
    id?: SortOrder
    subjectId?: SortOrder
    teacherId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subject?: SubjectOrderByWithRelationInput
    teacher?: TeacherOrderByWithRelationInput
  }

  export type SubjectTeacherWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    subjectId_teacherId?: SubjectTeacherSubjectIdTeacherIdCompoundUniqueInput
    AND?: SubjectTeacherWhereInput | SubjectTeacherWhereInput[]
    OR?: SubjectTeacherWhereInput[]
    NOT?: SubjectTeacherWhereInput | SubjectTeacherWhereInput[]
    subjectId?: StringFilter<"SubjectTeacher"> | string
    teacherId?: StringFilter<"SubjectTeacher"> | string
    createdAt?: DateTimeFilter<"SubjectTeacher"> | Date | string
    updatedAt?: DateTimeFilter<"SubjectTeacher"> | Date | string
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    teacher?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
  }, "id" | "subjectId_teacherId">

  export type SubjectTeacherOrderByWithAggregationInput = {
    id?: SortOrder
    subjectId?: SortOrder
    teacherId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubjectTeacherCountOrderByAggregateInput
    _max?: SubjectTeacherMaxOrderByAggregateInput
    _min?: SubjectTeacherMinOrderByAggregateInput
  }

  export type SubjectTeacherScalarWhereWithAggregatesInput = {
    AND?: SubjectTeacherScalarWhereWithAggregatesInput | SubjectTeacherScalarWhereWithAggregatesInput[]
    OR?: SubjectTeacherScalarWhereWithAggregatesInput[]
    NOT?: SubjectTeacherScalarWhereWithAggregatesInput | SubjectTeacherScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubjectTeacher"> | string
    subjectId?: StringWithAggregatesFilter<"SubjectTeacher"> | string
    teacherId?: StringWithAggregatesFilter<"SubjectTeacher"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SubjectTeacher"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubjectTeacher"> | Date | string
  }

  export type ClassSubjectWhereInput = {
    AND?: ClassSubjectWhereInput | ClassSubjectWhereInput[]
    OR?: ClassSubjectWhereInput[]
    NOT?: ClassSubjectWhereInput | ClassSubjectWhereInput[]
    id?: StringFilter<"ClassSubject"> | string
    classId?: StringFilter<"ClassSubject"> | string
    subjectId?: StringFilter<"ClassSubject"> | string
    createdAt?: DateTimeFilter<"ClassSubject"> | Date | string
    updatedAt?: DateTimeFilter<"ClassSubject"> | Date | string
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
  }

  export type ClassSubjectOrderByWithRelationInput = {
    id?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    class?: ClassOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
  }

  export type ClassSubjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    classId_subjectId?: ClassSubjectClassIdSubjectIdCompoundUniqueInput
    AND?: ClassSubjectWhereInput | ClassSubjectWhereInput[]
    OR?: ClassSubjectWhereInput[]
    NOT?: ClassSubjectWhereInput | ClassSubjectWhereInput[]
    classId?: StringFilter<"ClassSubject"> | string
    subjectId?: StringFilter<"ClassSubject"> | string
    createdAt?: DateTimeFilter<"ClassSubject"> | Date | string
    updatedAt?: DateTimeFilter<"ClassSubject"> | Date | string
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
  }, "id" | "classId_subjectId">

  export type ClassSubjectOrderByWithAggregationInput = {
    id?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClassSubjectCountOrderByAggregateInput
    _max?: ClassSubjectMaxOrderByAggregateInput
    _min?: ClassSubjectMinOrderByAggregateInput
  }

  export type ClassSubjectScalarWhereWithAggregatesInput = {
    AND?: ClassSubjectScalarWhereWithAggregatesInput | ClassSubjectScalarWhereWithAggregatesInput[]
    OR?: ClassSubjectScalarWhereWithAggregatesInput[]
    NOT?: ClassSubjectScalarWhereWithAggregatesInput | ClassSubjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClassSubject"> | string
    classId?: StringWithAggregatesFilter<"ClassSubject"> | string
    subjectId?: StringWithAggregatesFilter<"ClassSubject"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ClassSubject"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClassSubject"> | Date | string
  }

  export type AttendanceWhereInput = {
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    id?: StringFilter<"Attendance"> | string
    date?: DateTimeFilter<"Attendance"> | Date | string
    status?: EnumAttendanceStatusFilter<"Attendance"> | $Enums.AttendanceStatus
    studentId?: StringFilter<"Attendance"> | string
    sessionId?: StringFilter<"Attendance"> | string
    remarks?: StringNullableFilter<"Attendance"> | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
    session?: XOR<AcademicSessionScalarRelationFilter, AcademicSessionWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }

  export type AttendanceOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    studentId?: SortOrder
    sessionId?: SortOrder
    remarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    session?: AcademicSessionOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
  }

  export type AttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId_date_sessionId?: AttendanceStudentIdDateSessionIdCompoundUniqueInput
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    date?: DateTimeFilter<"Attendance"> | Date | string
    status?: EnumAttendanceStatusFilter<"Attendance"> | $Enums.AttendanceStatus
    studentId?: StringFilter<"Attendance"> | string
    sessionId?: StringFilter<"Attendance"> | string
    remarks?: StringNullableFilter<"Attendance"> | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
    session?: XOR<AcademicSessionScalarRelationFilter, AcademicSessionWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }, "id" | "studentId_date_sessionId">

  export type AttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    studentId?: SortOrder
    sessionId?: SortOrder
    remarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AttendanceCountOrderByAggregateInput
    _max?: AttendanceMaxOrderByAggregateInput
    _min?: AttendanceMinOrderByAggregateInput
  }

  export type AttendanceScalarWhereWithAggregatesInput = {
    AND?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    OR?: AttendanceScalarWhereWithAggregatesInput[]
    NOT?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Attendance"> | string
    date?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    status?: EnumAttendanceStatusWithAggregatesFilter<"Attendance"> | $Enums.AttendanceStatus
    studentId?: StringWithAggregatesFilter<"Attendance"> | string
    sessionId?: StringWithAggregatesFilter<"Attendance"> | string
    remarks?: StringNullableWithAggregatesFilter<"Attendance"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
  }

  export type ResultWhereInput = {
    AND?: ResultWhereInput | ResultWhereInput[]
    OR?: ResultWhereInput[]
    NOT?: ResultWhereInput | ResultWhereInput[]
    id?: StringFilter<"Result"> | string
    studentId?: StringFilter<"Result"> | string
    subjectId?: StringFilter<"Result"> | string
    periodId?: StringFilter<"Result"> | string
    sessionId?: StringFilter<"Result"> | string
    total?: FloatFilter<"Result"> | number
    grade?: StringFilter<"Result"> | string
    remark?: StringFilter<"Result"> | string
    cumulativeAverage?: FloatNullableFilter<"Result"> | number | null
    affectiveTraits?: JsonNullableFilter<"Result">
    psychomotorSkills?: JsonNullableFilter<"Result">
    customFields?: JsonNullableFilter<"Result">
    teacherComment?: StringNullableFilter<"Result"> | string | null
    adminComment?: StringNullableFilter<"Result"> | string | null
    approvedById?: StringNullableFilter<"Result"> | string | null
    createdAt?: DateTimeFilter<"Result"> | Date | string
    updatedAt?: DateTimeFilter<"Result"> | Date | string
    componentScores?: ComponentScoreListRelationFilter
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    period?: XOR<ResultPeriodScalarRelationFilter, ResultPeriodWhereInput>
    session?: XOR<AcademicSessionScalarRelationFilter, AcademicSessionWhereInput>
    approvedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ResultOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    periodId?: SortOrder
    sessionId?: SortOrder
    total?: SortOrder
    grade?: SortOrder
    remark?: SortOrder
    cumulativeAverage?: SortOrderInput | SortOrder
    affectiveTraits?: SortOrderInput | SortOrder
    psychomotorSkills?: SortOrderInput | SortOrder
    customFields?: SortOrderInput | SortOrder
    teacherComment?: SortOrderInput | SortOrder
    adminComment?: SortOrderInput | SortOrder
    approvedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    componentScores?: ComponentScoreOrderByRelationAggregateInput
    student?: StudentOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
    period?: ResultPeriodOrderByWithRelationInput
    session?: AcademicSessionOrderByWithRelationInput
    approvedBy?: UserOrderByWithRelationInput
  }

  export type ResultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId_subjectId_periodId_sessionId?: ResultStudentIdSubjectIdPeriodIdSessionIdCompoundUniqueInput
    AND?: ResultWhereInput | ResultWhereInput[]
    OR?: ResultWhereInput[]
    NOT?: ResultWhereInput | ResultWhereInput[]
    studentId?: StringFilter<"Result"> | string
    subjectId?: StringFilter<"Result"> | string
    periodId?: StringFilter<"Result"> | string
    sessionId?: StringFilter<"Result"> | string
    total?: FloatFilter<"Result"> | number
    grade?: StringFilter<"Result"> | string
    remark?: StringFilter<"Result"> | string
    cumulativeAverage?: FloatNullableFilter<"Result"> | number | null
    affectiveTraits?: JsonNullableFilter<"Result">
    psychomotorSkills?: JsonNullableFilter<"Result">
    customFields?: JsonNullableFilter<"Result">
    teacherComment?: StringNullableFilter<"Result"> | string | null
    adminComment?: StringNullableFilter<"Result"> | string | null
    approvedById?: StringNullableFilter<"Result"> | string | null
    createdAt?: DateTimeFilter<"Result"> | Date | string
    updatedAt?: DateTimeFilter<"Result"> | Date | string
    componentScores?: ComponentScoreListRelationFilter
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    period?: XOR<ResultPeriodScalarRelationFilter, ResultPeriodWhereInput>
    session?: XOR<AcademicSessionScalarRelationFilter, AcademicSessionWhereInput>
    approvedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "studentId_subjectId_periodId_sessionId">

  export type ResultOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    periodId?: SortOrder
    sessionId?: SortOrder
    total?: SortOrder
    grade?: SortOrder
    remark?: SortOrder
    cumulativeAverage?: SortOrderInput | SortOrder
    affectiveTraits?: SortOrderInput | SortOrder
    psychomotorSkills?: SortOrderInput | SortOrder
    customFields?: SortOrderInput | SortOrder
    teacherComment?: SortOrderInput | SortOrder
    adminComment?: SortOrderInput | SortOrder
    approvedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ResultCountOrderByAggregateInput
    _avg?: ResultAvgOrderByAggregateInput
    _max?: ResultMaxOrderByAggregateInput
    _min?: ResultMinOrderByAggregateInput
    _sum?: ResultSumOrderByAggregateInput
  }

  export type ResultScalarWhereWithAggregatesInput = {
    AND?: ResultScalarWhereWithAggregatesInput | ResultScalarWhereWithAggregatesInput[]
    OR?: ResultScalarWhereWithAggregatesInput[]
    NOT?: ResultScalarWhereWithAggregatesInput | ResultScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Result"> | string
    studentId?: StringWithAggregatesFilter<"Result"> | string
    subjectId?: StringWithAggregatesFilter<"Result"> | string
    periodId?: StringWithAggregatesFilter<"Result"> | string
    sessionId?: StringWithAggregatesFilter<"Result"> | string
    total?: FloatWithAggregatesFilter<"Result"> | number
    grade?: StringWithAggregatesFilter<"Result"> | string
    remark?: StringWithAggregatesFilter<"Result"> | string
    cumulativeAverage?: FloatNullableWithAggregatesFilter<"Result"> | number | null
    affectiveTraits?: JsonNullableWithAggregatesFilter<"Result">
    psychomotorSkills?: JsonNullableWithAggregatesFilter<"Result">
    customFields?: JsonNullableWithAggregatesFilter<"Result">
    teacherComment?: StringNullableWithAggregatesFilter<"Result"> | string | null
    adminComment?: StringNullableWithAggregatesFilter<"Result"> | string | null
    approvedById?: StringNullableWithAggregatesFilter<"Result"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Result"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Result"> | Date | string
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    id?: StringFilter<"Event"> | string
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    startDate?: DateTimeFilter<"Event"> | Date | string
    endDate?: DateTimeNullableFilter<"Event"> | Date | string | null
    location?: StringNullableFilter<"Event"> | string | null
    isPublic?: BoolFilter<"Event"> | boolean
    schoolId?: StringFilter<"Event"> | string
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    startDate?: DateTimeFilter<"Event"> | Date | string
    endDate?: DateTimeNullableFilter<"Event"> | Date | string | null
    location?: StringNullableFilter<"Event"> | string | null
    isPublic?: BoolFilter<"Event"> | boolean
    schoolId?: StringFilter<"Event"> | string
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
  }, "id">

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Event"> | string
    title?: StringWithAggregatesFilter<"Event"> | string
    description?: StringNullableWithAggregatesFilter<"Event"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Event"> | Date | string | null
    location?: StringNullableWithAggregatesFilter<"Event"> | string | null
    isPublic?: BoolWithAggregatesFilter<"Event"> | boolean
    schoolId?: StringWithAggregatesFilter<"Event"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
  }

  export type StudentSubjectWhereInput = {
    AND?: StudentSubjectWhereInput | StudentSubjectWhereInput[]
    OR?: StudentSubjectWhereInput[]
    NOT?: StudentSubjectWhereInput | StudentSubjectWhereInput[]
    id?: StringFilter<"StudentSubject"> | string
    studentId?: StringFilter<"StudentSubject"> | string
    subjectId?: StringFilter<"StudentSubject"> | string
    createdAt?: DateTimeFilter<"StudentSubject"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSubject"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
  }

  export type StudentSubjectOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
  }

  export type StudentSubjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId_subjectId?: StudentSubjectStudentIdSubjectIdCompoundUniqueInput
    AND?: StudentSubjectWhereInput | StudentSubjectWhereInput[]
    OR?: StudentSubjectWhereInput[]
    NOT?: StudentSubjectWhereInput | StudentSubjectWhereInput[]
    studentId?: StringFilter<"StudentSubject"> | string
    subjectId?: StringFilter<"StudentSubject"> | string
    createdAt?: DateTimeFilter<"StudentSubject"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSubject"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
  }, "id" | "studentId_subjectId">

  export type StudentSubjectOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentSubjectCountOrderByAggregateInput
    _max?: StudentSubjectMaxOrderByAggregateInput
    _min?: StudentSubjectMinOrderByAggregateInput
  }

  export type StudentSubjectScalarWhereWithAggregatesInput = {
    AND?: StudentSubjectScalarWhereWithAggregatesInput | StudentSubjectScalarWhereWithAggregatesInput[]
    OR?: StudentSubjectScalarWhereWithAggregatesInput[]
    NOT?: StudentSubjectScalarWhereWithAggregatesInput | StudentSubjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentSubject"> | string
    studentId?: StringWithAggregatesFilter<"StudentSubject"> | string
    subjectId?: StringWithAggregatesFilter<"StudentSubject"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StudentSubject"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentSubject"> | Date | string
  }

  export type BillWhereInput = {
    AND?: BillWhereInput | BillWhereInput[]
    OR?: BillWhereInput[]
    NOT?: BillWhereInput | BillWhereInput[]
    id?: StringFilter<"Bill"> | string
    name?: StringFilter<"Bill"> | string
    amount?: FloatFilter<"Bill"> | number
    createdAt?: DateTimeFilter<"Bill"> | Date | string
    updatedAt?: DateTimeFilter<"Bill"> | Date | string
    schoolId?: StringFilter<"Bill"> | string
    accountId?: StringFilter<"Bill"> | string
    account?: XOR<PaymentAccountScalarRelationFilter, PaymentAccountWhereInput>
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    assignments?: BillAssignmentListRelationFilter
    items?: BillItemListRelationFilter
    paymentRequests?: PaymentRequestListRelationFilter
  }

  export type BillOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    schoolId?: SortOrder
    accountId?: SortOrder
    account?: PaymentAccountOrderByWithRelationInput
    school?: SchoolOrderByWithRelationInput
    assignments?: BillAssignmentOrderByRelationAggregateInput
    items?: BillItemOrderByRelationAggregateInput
    paymentRequests?: PaymentRequestOrderByRelationAggregateInput
  }

  export type BillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BillWhereInput | BillWhereInput[]
    OR?: BillWhereInput[]
    NOT?: BillWhereInput | BillWhereInput[]
    name?: StringFilter<"Bill"> | string
    amount?: FloatFilter<"Bill"> | number
    createdAt?: DateTimeFilter<"Bill"> | Date | string
    updatedAt?: DateTimeFilter<"Bill"> | Date | string
    schoolId?: StringFilter<"Bill"> | string
    accountId?: StringFilter<"Bill"> | string
    account?: XOR<PaymentAccountScalarRelationFilter, PaymentAccountWhereInput>
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    assignments?: BillAssignmentListRelationFilter
    items?: BillItemListRelationFilter
    paymentRequests?: PaymentRequestListRelationFilter
  }, "id">

  export type BillOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    schoolId?: SortOrder
    accountId?: SortOrder
    _count?: BillCountOrderByAggregateInput
    _avg?: BillAvgOrderByAggregateInput
    _max?: BillMaxOrderByAggregateInput
    _min?: BillMinOrderByAggregateInput
    _sum?: BillSumOrderByAggregateInput
  }

  export type BillScalarWhereWithAggregatesInput = {
    AND?: BillScalarWhereWithAggregatesInput | BillScalarWhereWithAggregatesInput[]
    OR?: BillScalarWhereWithAggregatesInput[]
    NOT?: BillScalarWhereWithAggregatesInput | BillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Bill"> | string
    name?: StringWithAggregatesFilter<"Bill"> | string
    amount?: FloatWithAggregatesFilter<"Bill"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Bill"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Bill"> | Date | string
    schoolId?: StringWithAggregatesFilter<"Bill"> | string
    accountId?: StringWithAggregatesFilter<"Bill"> | string
  }

  export type BillItemWhereInput = {
    AND?: BillItemWhereInput | BillItemWhereInput[]
    OR?: BillItemWhereInput[]
    NOT?: BillItemWhereInput | BillItemWhereInput[]
    id?: StringFilter<"BillItem"> | string
    billId?: StringFilter<"BillItem"> | string
    name?: StringFilter<"BillItem"> | string
    amount?: FloatFilter<"BillItem"> | number
    description?: StringNullableFilter<"BillItem"> | string | null
    createdAt?: DateTimeFilter<"BillItem"> | Date | string
    updatedAt?: DateTimeFilter<"BillItem"> | Date | string
    bill?: XOR<BillScalarRelationFilter, BillWhereInput>
  }

  export type BillItemOrderByWithRelationInput = {
    id?: SortOrder
    billId?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bill?: BillOrderByWithRelationInput
  }

  export type BillItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BillItemWhereInput | BillItemWhereInput[]
    OR?: BillItemWhereInput[]
    NOT?: BillItemWhereInput | BillItemWhereInput[]
    billId?: StringFilter<"BillItem"> | string
    name?: StringFilter<"BillItem"> | string
    amount?: FloatFilter<"BillItem"> | number
    description?: StringNullableFilter<"BillItem"> | string | null
    createdAt?: DateTimeFilter<"BillItem"> | Date | string
    updatedAt?: DateTimeFilter<"BillItem"> | Date | string
    bill?: XOR<BillScalarRelationFilter, BillWhereInput>
  }, "id">

  export type BillItemOrderByWithAggregationInput = {
    id?: SortOrder
    billId?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BillItemCountOrderByAggregateInput
    _avg?: BillItemAvgOrderByAggregateInput
    _max?: BillItemMaxOrderByAggregateInput
    _min?: BillItemMinOrderByAggregateInput
    _sum?: BillItemSumOrderByAggregateInput
  }

  export type BillItemScalarWhereWithAggregatesInput = {
    AND?: BillItemScalarWhereWithAggregatesInput | BillItemScalarWhereWithAggregatesInput[]
    OR?: BillItemScalarWhereWithAggregatesInput[]
    NOT?: BillItemScalarWhereWithAggregatesInput | BillItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BillItem"> | string
    billId?: StringWithAggregatesFilter<"BillItem"> | string
    name?: StringWithAggregatesFilter<"BillItem"> | string
    amount?: FloatWithAggregatesFilter<"BillItem"> | number
    description?: StringNullableWithAggregatesFilter<"BillItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BillItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BillItem"> | Date | string
  }

  export type PaymentAccountWhereInput = {
    AND?: PaymentAccountWhereInput | PaymentAccountWhereInput[]
    OR?: PaymentAccountWhereInput[]
    NOT?: PaymentAccountWhereInput | PaymentAccountWhereInput[]
    id?: StringFilter<"PaymentAccount"> | string
    name?: StringFilter<"PaymentAccount"> | string
    accountNo?: StringFilter<"PaymentAccount"> | string
    bankName?: StringFilter<"PaymentAccount"> | string
    branchCode?: StringNullableFilter<"PaymentAccount"> | string | null
    description?: StringNullableFilter<"PaymentAccount"> | string | null
    isActive?: BoolFilter<"PaymentAccount"> | boolean
    schoolId?: StringFilter<"PaymentAccount"> | string
    createdAt?: DateTimeFilter<"PaymentAccount"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentAccount"> | Date | string
    bills?: BillListRelationFilter
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
  }

  export type PaymentAccountOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    accountNo?: SortOrder
    bankName?: SortOrder
    branchCode?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bills?: BillOrderByRelationAggregateInput
    school?: SchoolOrderByWithRelationInput
  }

  export type PaymentAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentAccountWhereInput | PaymentAccountWhereInput[]
    OR?: PaymentAccountWhereInput[]
    NOT?: PaymentAccountWhereInput | PaymentAccountWhereInput[]
    name?: StringFilter<"PaymentAccount"> | string
    accountNo?: StringFilter<"PaymentAccount"> | string
    bankName?: StringFilter<"PaymentAccount"> | string
    branchCode?: StringNullableFilter<"PaymentAccount"> | string | null
    description?: StringNullableFilter<"PaymentAccount"> | string | null
    isActive?: BoolFilter<"PaymentAccount"> | boolean
    schoolId?: StringFilter<"PaymentAccount"> | string
    createdAt?: DateTimeFilter<"PaymentAccount"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentAccount"> | Date | string
    bills?: BillListRelationFilter
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
  }, "id">

  export type PaymentAccountOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    accountNo?: SortOrder
    bankName?: SortOrder
    branchCode?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentAccountCountOrderByAggregateInput
    _max?: PaymentAccountMaxOrderByAggregateInput
    _min?: PaymentAccountMinOrderByAggregateInput
  }

  export type PaymentAccountScalarWhereWithAggregatesInput = {
    AND?: PaymentAccountScalarWhereWithAggregatesInput | PaymentAccountScalarWhereWithAggregatesInput[]
    OR?: PaymentAccountScalarWhereWithAggregatesInput[]
    NOT?: PaymentAccountScalarWhereWithAggregatesInput | PaymentAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentAccount"> | string
    name?: StringWithAggregatesFilter<"PaymentAccount"> | string
    accountNo?: StringWithAggregatesFilter<"PaymentAccount"> | string
    bankName?: StringWithAggregatesFilter<"PaymentAccount"> | string
    branchCode?: StringNullableWithAggregatesFilter<"PaymentAccount"> | string | null
    description?: StringNullableWithAggregatesFilter<"PaymentAccount"> | string | null
    isActive?: BoolWithAggregatesFilter<"PaymentAccount"> | boolean
    schoolId?: StringWithAggregatesFilter<"PaymentAccount"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PaymentAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentAccount"> | Date | string
  }

  export type BillAssignmentWhereInput = {
    AND?: BillAssignmentWhereInput | BillAssignmentWhereInput[]
    OR?: BillAssignmentWhereInput[]
    NOT?: BillAssignmentWhereInput | BillAssignmentWhereInput[]
    id?: StringFilter<"BillAssignment"> | string
    billId?: StringFilter<"BillAssignment"> | string
    targetType?: EnumBillAssignmentTypeFilter<"BillAssignment"> | $Enums.BillAssignmentType
    targetId?: StringFilter<"BillAssignment"> | string
    dueDate?: DateTimeFilter<"BillAssignment"> | Date | string
    status?: EnumBillStatusFilter<"BillAssignment"> | $Enums.BillStatus
    createdAt?: DateTimeFilter<"BillAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"BillAssignment"> | Date | string
    bill?: XOR<BillScalarRelationFilter, BillWhereInput>
    paymentRequests?: PaymentRequestListRelationFilter
    studentPayments?: StudentPaymentListRelationFilter
  }

  export type BillAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    billId?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bill?: BillOrderByWithRelationInput
    paymentRequests?: PaymentRequestOrderByRelationAggregateInput
    studentPayments?: StudentPaymentOrderByRelationAggregateInput
  }

  export type BillAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BillAssignmentWhereInput | BillAssignmentWhereInput[]
    OR?: BillAssignmentWhereInput[]
    NOT?: BillAssignmentWhereInput | BillAssignmentWhereInput[]
    billId?: StringFilter<"BillAssignment"> | string
    targetType?: EnumBillAssignmentTypeFilter<"BillAssignment"> | $Enums.BillAssignmentType
    targetId?: StringFilter<"BillAssignment"> | string
    dueDate?: DateTimeFilter<"BillAssignment"> | Date | string
    status?: EnumBillStatusFilter<"BillAssignment"> | $Enums.BillStatus
    createdAt?: DateTimeFilter<"BillAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"BillAssignment"> | Date | string
    bill?: XOR<BillScalarRelationFilter, BillWhereInput>
    paymentRequests?: PaymentRequestListRelationFilter
    studentPayments?: StudentPaymentListRelationFilter
  }, "id">

  export type BillAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    billId?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BillAssignmentCountOrderByAggregateInput
    _max?: BillAssignmentMaxOrderByAggregateInput
    _min?: BillAssignmentMinOrderByAggregateInput
  }

  export type BillAssignmentScalarWhereWithAggregatesInput = {
    AND?: BillAssignmentScalarWhereWithAggregatesInput | BillAssignmentScalarWhereWithAggregatesInput[]
    OR?: BillAssignmentScalarWhereWithAggregatesInput[]
    NOT?: BillAssignmentScalarWhereWithAggregatesInput | BillAssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BillAssignment"> | string
    billId?: StringWithAggregatesFilter<"BillAssignment"> | string
    targetType?: EnumBillAssignmentTypeWithAggregatesFilter<"BillAssignment"> | $Enums.BillAssignmentType
    targetId?: StringWithAggregatesFilter<"BillAssignment"> | string
    dueDate?: DateTimeWithAggregatesFilter<"BillAssignment"> | Date | string
    status?: EnumBillStatusWithAggregatesFilter<"BillAssignment"> | $Enums.BillStatus
    createdAt?: DateTimeWithAggregatesFilter<"BillAssignment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BillAssignment"> | Date | string
  }

  export type StudentPaymentWhereInput = {
    AND?: StudentPaymentWhereInput | StudentPaymentWhereInput[]
    OR?: StudentPaymentWhereInput[]
    NOT?: StudentPaymentWhereInput | StudentPaymentWhereInput[]
    id?: StringFilter<"StudentPayment"> | string
    billAssignmentId?: StringFilter<"StudentPayment"> | string
    studentId?: StringFilter<"StudentPayment"> | string
    amountPaid?: FloatFilter<"StudentPayment"> | number
    createdAt?: DateTimeFilter<"StudentPayment"> | Date | string
    updatedAt?: DateTimeFilter<"StudentPayment"> | Date | string
    paymentRequests?: PaymentRequestListRelationFilter
    billAssignment?: XOR<BillAssignmentScalarRelationFilter, BillAssignmentWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }

  export type StudentPaymentOrderByWithRelationInput = {
    id?: SortOrder
    billAssignmentId?: SortOrder
    studentId?: SortOrder
    amountPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentRequests?: PaymentRequestOrderByRelationAggregateInput
    billAssignment?: BillAssignmentOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
  }

  export type StudentPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudentPaymentWhereInput | StudentPaymentWhereInput[]
    OR?: StudentPaymentWhereInput[]
    NOT?: StudentPaymentWhereInput | StudentPaymentWhereInput[]
    billAssignmentId?: StringFilter<"StudentPayment"> | string
    studentId?: StringFilter<"StudentPayment"> | string
    amountPaid?: FloatFilter<"StudentPayment"> | number
    createdAt?: DateTimeFilter<"StudentPayment"> | Date | string
    updatedAt?: DateTimeFilter<"StudentPayment"> | Date | string
    paymentRequests?: PaymentRequestListRelationFilter
    billAssignment?: XOR<BillAssignmentScalarRelationFilter, BillAssignmentWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }, "id">

  export type StudentPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    billAssignmentId?: SortOrder
    studentId?: SortOrder
    amountPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentPaymentCountOrderByAggregateInput
    _avg?: StudentPaymentAvgOrderByAggregateInput
    _max?: StudentPaymentMaxOrderByAggregateInput
    _min?: StudentPaymentMinOrderByAggregateInput
    _sum?: StudentPaymentSumOrderByAggregateInput
  }

  export type StudentPaymentScalarWhereWithAggregatesInput = {
    AND?: StudentPaymentScalarWhereWithAggregatesInput | StudentPaymentScalarWhereWithAggregatesInput[]
    OR?: StudentPaymentScalarWhereWithAggregatesInput[]
    NOT?: StudentPaymentScalarWhereWithAggregatesInput | StudentPaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentPayment"> | string
    billAssignmentId?: StringWithAggregatesFilter<"StudentPayment"> | string
    studentId?: StringWithAggregatesFilter<"StudentPayment"> | string
    amountPaid?: FloatWithAggregatesFilter<"StudentPayment"> | number
    createdAt?: DateTimeWithAggregatesFilter<"StudentPayment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentPayment"> | Date | string
  }

  export type PaymentRequestWhereInput = {
    AND?: PaymentRequestWhereInput | PaymentRequestWhereInput[]
    OR?: PaymentRequestWhereInput[]
    NOT?: PaymentRequestWhereInput | PaymentRequestWhereInput[]
    id?: StringFilter<"PaymentRequest"> | string
    billId?: StringFilter<"PaymentRequest"> | string
    billAssignmentId?: StringFilter<"PaymentRequest"> | string
    studentPaymentId?: StringNullableFilter<"PaymentRequest"> | string | null
    studentId?: StringFilter<"PaymentRequest"> | string
    amount?: FloatFilter<"PaymentRequest"> | number
    receiptUrl?: StringNullableFilter<"PaymentRequest"> | string | null
    status?: EnumPaymentStatusFilter<"PaymentRequest"> | $Enums.PaymentStatus
    notes?: StringNullableFilter<"PaymentRequest"> | string | null
    processedById?: StringNullableFilter<"PaymentRequest"> | string | null
    processedAt?: DateTimeNullableFilter<"PaymentRequest"> | Date | string | null
    createdAt?: DateTimeFilter<"PaymentRequest"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentRequest"> | Date | string
    billAssignment?: XOR<BillAssignmentScalarRelationFilter, BillAssignmentWhereInput>
    bill?: XOR<BillScalarRelationFilter, BillWhereInput>
    processedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    studentPayment?: XOR<StudentPaymentNullableScalarRelationFilter, StudentPaymentWhereInput> | null
  }

  export type PaymentRequestOrderByWithRelationInput = {
    id?: SortOrder
    billId?: SortOrder
    billAssignmentId?: SortOrder
    studentPaymentId?: SortOrderInput | SortOrder
    studentId?: SortOrder
    amount?: SortOrder
    receiptUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    processedById?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    billAssignment?: BillAssignmentOrderByWithRelationInput
    bill?: BillOrderByWithRelationInput
    processedBy?: UserOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
    studentPayment?: StudentPaymentOrderByWithRelationInput
  }

  export type PaymentRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentRequestWhereInput | PaymentRequestWhereInput[]
    OR?: PaymentRequestWhereInput[]
    NOT?: PaymentRequestWhereInput | PaymentRequestWhereInput[]
    billId?: StringFilter<"PaymentRequest"> | string
    billAssignmentId?: StringFilter<"PaymentRequest"> | string
    studentPaymentId?: StringNullableFilter<"PaymentRequest"> | string | null
    studentId?: StringFilter<"PaymentRequest"> | string
    amount?: FloatFilter<"PaymentRequest"> | number
    receiptUrl?: StringNullableFilter<"PaymentRequest"> | string | null
    status?: EnumPaymentStatusFilter<"PaymentRequest"> | $Enums.PaymentStatus
    notes?: StringNullableFilter<"PaymentRequest"> | string | null
    processedById?: StringNullableFilter<"PaymentRequest"> | string | null
    processedAt?: DateTimeNullableFilter<"PaymentRequest"> | Date | string | null
    createdAt?: DateTimeFilter<"PaymentRequest"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentRequest"> | Date | string
    billAssignment?: XOR<BillAssignmentScalarRelationFilter, BillAssignmentWhereInput>
    bill?: XOR<BillScalarRelationFilter, BillWhereInput>
    processedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    studentPayment?: XOR<StudentPaymentNullableScalarRelationFilter, StudentPaymentWhereInput> | null
  }, "id">

  export type PaymentRequestOrderByWithAggregationInput = {
    id?: SortOrder
    billId?: SortOrder
    billAssignmentId?: SortOrder
    studentPaymentId?: SortOrderInput | SortOrder
    studentId?: SortOrder
    amount?: SortOrder
    receiptUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    processedById?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentRequestCountOrderByAggregateInput
    _avg?: PaymentRequestAvgOrderByAggregateInput
    _max?: PaymentRequestMaxOrderByAggregateInput
    _min?: PaymentRequestMinOrderByAggregateInput
    _sum?: PaymentRequestSumOrderByAggregateInput
  }

  export type PaymentRequestScalarWhereWithAggregatesInput = {
    AND?: PaymentRequestScalarWhereWithAggregatesInput | PaymentRequestScalarWhereWithAggregatesInput[]
    OR?: PaymentRequestScalarWhereWithAggregatesInput[]
    NOT?: PaymentRequestScalarWhereWithAggregatesInput | PaymentRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentRequest"> | string
    billId?: StringWithAggregatesFilter<"PaymentRequest"> | string
    billAssignmentId?: StringWithAggregatesFilter<"PaymentRequest"> | string
    studentPaymentId?: StringNullableWithAggregatesFilter<"PaymentRequest"> | string | null
    studentId?: StringWithAggregatesFilter<"PaymentRequest"> | string
    amount?: FloatWithAggregatesFilter<"PaymentRequest"> | number
    receiptUrl?: StringNullableWithAggregatesFilter<"PaymentRequest"> | string | null
    status?: EnumPaymentStatusWithAggregatesFilter<"PaymentRequest"> | $Enums.PaymentStatus
    notes?: StringNullableWithAggregatesFilter<"PaymentRequest"> | string | null
    processedById?: StringNullableWithAggregatesFilter<"PaymentRequest"> | string | null
    processedAt?: DateTimeNullableWithAggregatesFilter<"PaymentRequest"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PaymentRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentRequest"> | Date | string
  }

  export type SchoolLevelWhereInput = {
    AND?: SchoolLevelWhereInput | SchoolLevelWhereInput[]
    OR?: SchoolLevelWhereInput[]
    NOT?: SchoolLevelWhereInput | SchoolLevelWhereInput[]
    id?: StringFilter<"SchoolLevel"> | string
    name?: StringFilter<"SchoolLevel"> | string
    description?: StringNullableFilter<"SchoolLevel"> | string | null
    order?: IntFilter<"SchoolLevel"> | number
    schoolId?: StringFilter<"SchoolLevel"> | string
    createdAt?: DateTimeFilter<"SchoolLevel"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolLevel"> | Date | string
    classes?: ClassListRelationFilter
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    subjects?: SubjectListRelationFilter
  }

  export type SchoolLevelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    classes?: ClassOrderByRelationAggregateInput
    school?: SchoolOrderByWithRelationInput
    subjects?: SubjectOrderByRelationAggregateInput
  }

  export type SchoolLevelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    schoolId_name?: SchoolLevelSchoolIdNameCompoundUniqueInput
    AND?: SchoolLevelWhereInput | SchoolLevelWhereInput[]
    OR?: SchoolLevelWhereInput[]
    NOT?: SchoolLevelWhereInput | SchoolLevelWhereInput[]
    name?: StringFilter<"SchoolLevel"> | string
    description?: StringNullableFilter<"SchoolLevel"> | string | null
    order?: IntFilter<"SchoolLevel"> | number
    schoolId?: StringFilter<"SchoolLevel"> | string
    createdAt?: DateTimeFilter<"SchoolLevel"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolLevel"> | Date | string
    classes?: ClassListRelationFilter
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    subjects?: SubjectListRelationFilter
  }, "id" | "schoolId_name">

  export type SchoolLevelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SchoolLevelCountOrderByAggregateInput
    _avg?: SchoolLevelAvgOrderByAggregateInput
    _max?: SchoolLevelMaxOrderByAggregateInput
    _min?: SchoolLevelMinOrderByAggregateInput
    _sum?: SchoolLevelSumOrderByAggregateInput
  }

  export type SchoolLevelScalarWhereWithAggregatesInput = {
    AND?: SchoolLevelScalarWhereWithAggregatesInput | SchoolLevelScalarWhereWithAggregatesInput[]
    OR?: SchoolLevelScalarWhereWithAggregatesInput[]
    NOT?: SchoolLevelScalarWhereWithAggregatesInput | SchoolLevelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SchoolLevel"> | string
    name?: StringWithAggregatesFilter<"SchoolLevel"> | string
    description?: StringNullableWithAggregatesFilter<"SchoolLevel"> | string | null
    order?: IntWithAggregatesFilter<"SchoolLevel"> | number
    schoolId?: StringWithAggregatesFilter<"SchoolLevel"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SchoolLevel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SchoolLevel"> | Date | string
  }

  export type UserActivityLogWhereInput = {
    AND?: UserActivityLogWhereInput | UserActivityLogWhereInput[]
    OR?: UserActivityLogWhereInput[]
    NOT?: UserActivityLogWhereInput | UserActivityLogWhereInput[]
    id?: StringFilter<"UserActivityLog"> | string
    userId?: StringFilter<"UserActivityLog"> | string
    page?: StringFilter<"UserActivityLog"> | string
    action?: StringFilter<"UserActivityLog"> | string
    metadata?: JsonNullableFilter<"UserActivityLog">
    createdAt?: DateTimeFilter<"UserActivityLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    page?: SortOrder
    action?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserActivityLogWhereInput | UserActivityLogWhereInput[]
    OR?: UserActivityLogWhereInput[]
    NOT?: UserActivityLogWhereInput | UserActivityLogWhereInput[]
    userId?: StringFilter<"UserActivityLog"> | string
    page?: StringFilter<"UserActivityLog"> | string
    action?: StringFilter<"UserActivityLog"> | string
    metadata?: JsonNullableFilter<"UserActivityLog">
    createdAt?: DateTimeFilter<"UserActivityLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    page?: SortOrder
    action?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UserActivityLogCountOrderByAggregateInput
    _max?: UserActivityLogMaxOrderByAggregateInput
    _min?: UserActivityLogMinOrderByAggregateInput
  }

  export type UserActivityLogScalarWhereWithAggregatesInput = {
    AND?: UserActivityLogScalarWhereWithAggregatesInput | UserActivityLogScalarWhereWithAggregatesInput[]
    OR?: UserActivityLogScalarWhereWithAggregatesInput[]
    NOT?: UserActivityLogScalarWhereWithAggregatesInput | UserActivityLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserActivityLog"> | string
    userId?: StringWithAggregatesFilter<"UserActivityLog"> | string
    page?: StringWithAggregatesFilter<"UserActivityLog"> | string
    action?: StringWithAggregatesFilter<"UserActivityLog"> | string
    metadata?: JsonNullableWithAggregatesFilter<"UserActivityLog">
    createdAt?: DateTimeWithAggregatesFilter<"UserActivityLog"> | Date | string
  }

  export type ApiRequestLogWhereInput = {
    AND?: ApiRequestLogWhereInput | ApiRequestLogWhereInput[]
    OR?: ApiRequestLogWhereInput[]
    NOT?: ApiRequestLogWhereInput | ApiRequestLogWhereInput[]
    id?: StringFilter<"ApiRequestLog"> | string
    route?: StringFilter<"ApiRequestLog"> | string
    method?: StringFilter<"ApiRequestLog"> | string
    status?: IntFilter<"ApiRequestLog"> | number
    duration?: IntFilter<"ApiRequestLog"> | number
    metadata?: JsonNullableFilter<"ApiRequestLog">
    createdAt?: DateTimeFilter<"ApiRequestLog"> | Date | string
  }

  export type ApiRequestLogOrderByWithRelationInput = {
    id?: SortOrder
    route?: SortOrder
    method?: SortOrder
    status?: SortOrder
    duration?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type ApiRequestLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ApiRequestLogWhereInput | ApiRequestLogWhereInput[]
    OR?: ApiRequestLogWhereInput[]
    NOT?: ApiRequestLogWhereInput | ApiRequestLogWhereInput[]
    route?: StringFilter<"ApiRequestLog"> | string
    method?: StringFilter<"ApiRequestLog"> | string
    status?: IntFilter<"ApiRequestLog"> | number
    duration?: IntFilter<"ApiRequestLog"> | number
    metadata?: JsonNullableFilter<"ApiRequestLog">
    createdAt?: DateTimeFilter<"ApiRequestLog"> | Date | string
  }, "id">

  export type ApiRequestLogOrderByWithAggregationInput = {
    id?: SortOrder
    route?: SortOrder
    method?: SortOrder
    status?: SortOrder
    duration?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ApiRequestLogCountOrderByAggregateInput
    _avg?: ApiRequestLogAvgOrderByAggregateInput
    _max?: ApiRequestLogMaxOrderByAggregateInput
    _min?: ApiRequestLogMinOrderByAggregateInput
    _sum?: ApiRequestLogSumOrderByAggregateInput
  }

  export type ApiRequestLogScalarWhereWithAggregatesInput = {
    AND?: ApiRequestLogScalarWhereWithAggregatesInput | ApiRequestLogScalarWhereWithAggregatesInput[]
    OR?: ApiRequestLogScalarWhereWithAggregatesInput[]
    NOT?: ApiRequestLogScalarWhereWithAggregatesInput | ApiRequestLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiRequestLog"> | string
    route?: StringWithAggregatesFilter<"ApiRequestLog"> | string
    method?: StringWithAggregatesFilter<"ApiRequestLog"> | string
    status?: IntWithAggregatesFilter<"ApiRequestLog"> | number
    duration?: IntWithAggregatesFilter<"ApiRequestLog"> | number
    metadata?: JsonNullableWithAggregatesFilter<"ApiRequestLog">
    createdAt?: DateTimeWithAggregatesFilter<"ApiRequestLog"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type ResultConfigurationWhereInput = {
    AND?: ResultConfigurationWhereInput | ResultConfigurationWhereInput[]
    OR?: ResultConfigurationWhereInput[]
    NOT?: ResultConfigurationWhereInput | ResultConfigurationWhereInput[]
    id?: StringFilter<"ResultConfiguration"> | string
    schoolId?: StringFilter<"ResultConfiguration"> | string
    sessionId?: StringFilter<"ResultConfiguration"> | string
    cumulativeEnabled?: BoolFilter<"ResultConfiguration"> | boolean
    cumulativeMethod?: StringFilter<"ResultConfiguration"> | string
    showCumulativePerTerm?: BoolFilter<"ResultConfiguration"> | boolean
    createdAt?: DateTimeFilter<"ResultConfiguration"> | Date | string
    updatedAt?: DateTimeFilter<"ResultConfiguration"> | Date | string
    periods?: ResultPeriodListRelationFilter
    assessmentComponents?: AssessmentComponentListRelationFilter
    gradingScale?: GradingScaleListRelationFilter
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    session?: XOR<AcademicSessionScalarRelationFilter, AcademicSessionWhereInput>
  }

  export type ResultConfigurationOrderByWithRelationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    sessionId?: SortOrder
    cumulativeEnabled?: SortOrder
    cumulativeMethod?: SortOrder
    showCumulativePerTerm?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    periods?: ResultPeriodOrderByRelationAggregateInput
    assessmentComponents?: AssessmentComponentOrderByRelationAggregateInput
    gradingScale?: GradingScaleOrderByRelationAggregateInput
    school?: SchoolOrderByWithRelationInput
    session?: AcademicSessionOrderByWithRelationInput
  }

  export type ResultConfigurationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    schoolId_sessionId?: ResultConfigurationSchoolIdSessionIdCompoundUniqueInput
    AND?: ResultConfigurationWhereInput | ResultConfigurationWhereInput[]
    OR?: ResultConfigurationWhereInput[]
    NOT?: ResultConfigurationWhereInput | ResultConfigurationWhereInput[]
    schoolId?: StringFilter<"ResultConfiguration"> | string
    sessionId?: StringFilter<"ResultConfiguration"> | string
    cumulativeEnabled?: BoolFilter<"ResultConfiguration"> | boolean
    cumulativeMethod?: StringFilter<"ResultConfiguration"> | string
    showCumulativePerTerm?: BoolFilter<"ResultConfiguration"> | boolean
    createdAt?: DateTimeFilter<"ResultConfiguration"> | Date | string
    updatedAt?: DateTimeFilter<"ResultConfiguration"> | Date | string
    periods?: ResultPeriodListRelationFilter
    assessmentComponents?: AssessmentComponentListRelationFilter
    gradingScale?: GradingScaleListRelationFilter
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    session?: XOR<AcademicSessionScalarRelationFilter, AcademicSessionWhereInput>
  }, "id" | "schoolId_sessionId">

  export type ResultConfigurationOrderByWithAggregationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    sessionId?: SortOrder
    cumulativeEnabled?: SortOrder
    cumulativeMethod?: SortOrder
    showCumulativePerTerm?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ResultConfigurationCountOrderByAggregateInput
    _max?: ResultConfigurationMaxOrderByAggregateInput
    _min?: ResultConfigurationMinOrderByAggregateInput
  }

  export type ResultConfigurationScalarWhereWithAggregatesInput = {
    AND?: ResultConfigurationScalarWhereWithAggregatesInput | ResultConfigurationScalarWhereWithAggregatesInput[]
    OR?: ResultConfigurationScalarWhereWithAggregatesInput[]
    NOT?: ResultConfigurationScalarWhereWithAggregatesInput | ResultConfigurationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ResultConfiguration"> | string
    schoolId?: StringWithAggregatesFilter<"ResultConfiguration"> | string
    sessionId?: StringWithAggregatesFilter<"ResultConfiguration"> | string
    cumulativeEnabled?: BoolWithAggregatesFilter<"ResultConfiguration"> | boolean
    cumulativeMethod?: StringWithAggregatesFilter<"ResultConfiguration"> | string
    showCumulativePerTerm?: BoolWithAggregatesFilter<"ResultConfiguration"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ResultConfiguration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ResultConfiguration"> | Date | string
  }

  export type ResultPeriodWhereInput = {
    AND?: ResultPeriodWhereInput | ResultPeriodWhereInput[]
    OR?: ResultPeriodWhereInput[]
    NOT?: ResultPeriodWhereInput | ResultPeriodWhereInput[]
    id?: StringFilter<"ResultPeriod"> | string
    name?: StringFilter<"ResultPeriod"> | string
    weight?: FloatFilter<"ResultPeriod"> | number
    configurationId?: StringFilter<"ResultPeriod"> | string
    createdAt?: DateTimeFilter<"ResultPeriod"> | Date | string
    updatedAt?: DateTimeFilter<"ResultPeriod"> | Date | string
    configuration?: XOR<ResultConfigurationScalarRelationFilter, ResultConfigurationWhereInput>
    results?: ResultListRelationFilter
  }

  export type ResultPeriodOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    weight?: SortOrder
    configurationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    configuration?: ResultConfigurationOrderByWithRelationInput
    results?: ResultOrderByRelationAggregateInput
  }

  export type ResultPeriodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ResultPeriodWhereInput | ResultPeriodWhereInput[]
    OR?: ResultPeriodWhereInput[]
    NOT?: ResultPeriodWhereInput | ResultPeriodWhereInput[]
    name?: StringFilter<"ResultPeriod"> | string
    weight?: FloatFilter<"ResultPeriod"> | number
    configurationId?: StringFilter<"ResultPeriod"> | string
    createdAt?: DateTimeFilter<"ResultPeriod"> | Date | string
    updatedAt?: DateTimeFilter<"ResultPeriod"> | Date | string
    configuration?: XOR<ResultConfigurationScalarRelationFilter, ResultConfigurationWhereInput>
    results?: ResultListRelationFilter
  }, "id">

  export type ResultPeriodOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    weight?: SortOrder
    configurationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ResultPeriodCountOrderByAggregateInput
    _avg?: ResultPeriodAvgOrderByAggregateInput
    _max?: ResultPeriodMaxOrderByAggregateInput
    _min?: ResultPeriodMinOrderByAggregateInput
    _sum?: ResultPeriodSumOrderByAggregateInput
  }

  export type ResultPeriodScalarWhereWithAggregatesInput = {
    AND?: ResultPeriodScalarWhereWithAggregatesInput | ResultPeriodScalarWhereWithAggregatesInput[]
    OR?: ResultPeriodScalarWhereWithAggregatesInput[]
    NOT?: ResultPeriodScalarWhereWithAggregatesInput | ResultPeriodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ResultPeriod"> | string
    name?: StringWithAggregatesFilter<"ResultPeriod"> | string
    weight?: FloatWithAggregatesFilter<"ResultPeriod"> | number
    configurationId?: StringWithAggregatesFilter<"ResultPeriod"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ResultPeriod"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ResultPeriod"> | Date | string
  }

  export type AssessmentComponentWhereInput = {
    AND?: AssessmentComponentWhereInput | AssessmentComponentWhereInput[]
    OR?: AssessmentComponentWhereInput[]
    NOT?: AssessmentComponentWhereInput | AssessmentComponentWhereInput[]
    id?: StringFilter<"AssessmentComponent"> | string
    name?: StringFilter<"AssessmentComponent"> | string
    key?: StringFilter<"AssessmentComponent"> | string
    maxScore?: FloatFilter<"AssessmentComponent"> | number
    configurationId?: StringFilter<"AssessmentComponent"> | string
    createdAt?: DateTimeFilter<"AssessmentComponent"> | Date | string
    updatedAt?: DateTimeFilter<"AssessmentComponent"> | Date | string
    configuration?: XOR<ResultConfigurationScalarRelationFilter, ResultConfigurationWhereInput>
    scores?: ComponentScoreListRelationFilter
  }

  export type AssessmentComponentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
    maxScore?: SortOrder
    configurationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    configuration?: ResultConfigurationOrderByWithRelationInput
    scores?: ComponentScoreOrderByRelationAggregateInput
  }

  export type AssessmentComponentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AssessmentComponentWhereInput | AssessmentComponentWhereInput[]
    OR?: AssessmentComponentWhereInput[]
    NOT?: AssessmentComponentWhereInput | AssessmentComponentWhereInput[]
    name?: StringFilter<"AssessmentComponent"> | string
    key?: StringFilter<"AssessmentComponent"> | string
    maxScore?: FloatFilter<"AssessmentComponent"> | number
    configurationId?: StringFilter<"AssessmentComponent"> | string
    createdAt?: DateTimeFilter<"AssessmentComponent"> | Date | string
    updatedAt?: DateTimeFilter<"AssessmentComponent"> | Date | string
    configuration?: XOR<ResultConfigurationScalarRelationFilter, ResultConfigurationWhereInput>
    scores?: ComponentScoreListRelationFilter
  }, "id">

  export type AssessmentComponentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
    maxScore?: SortOrder
    configurationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AssessmentComponentCountOrderByAggregateInput
    _avg?: AssessmentComponentAvgOrderByAggregateInput
    _max?: AssessmentComponentMaxOrderByAggregateInput
    _min?: AssessmentComponentMinOrderByAggregateInput
    _sum?: AssessmentComponentSumOrderByAggregateInput
  }

  export type AssessmentComponentScalarWhereWithAggregatesInput = {
    AND?: AssessmentComponentScalarWhereWithAggregatesInput | AssessmentComponentScalarWhereWithAggregatesInput[]
    OR?: AssessmentComponentScalarWhereWithAggregatesInput[]
    NOT?: AssessmentComponentScalarWhereWithAggregatesInput | AssessmentComponentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AssessmentComponent"> | string
    name?: StringWithAggregatesFilter<"AssessmentComponent"> | string
    key?: StringWithAggregatesFilter<"AssessmentComponent"> | string
    maxScore?: FloatWithAggregatesFilter<"AssessmentComponent"> | number
    configurationId?: StringWithAggregatesFilter<"AssessmentComponent"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AssessmentComponent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AssessmentComponent"> | Date | string
  }

  export type GradingScaleWhereInput = {
    AND?: GradingScaleWhereInput | GradingScaleWhereInput[]
    OR?: GradingScaleWhereInput[]
    NOT?: GradingScaleWhereInput | GradingScaleWhereInput[]
    id?: StringFilter<"GradingScale"> | string
    minScore?: FloatFilter<"GradingScale"> | number
    maxScore?: FloatFilter<"GradingScale"> | number
    grade?: StringFilter<"GradingScale"> | string
    remark?: StringFilter<"GradingScale"> | string
    configurationId?: StringFilter<"GradingScale"> | string
    createdAt?: DateTimeFilter<"GradingScale"> | Date | string
    updatedAt?: DateTimeFilter<"GradingScale"> | Date | string
    configuration?: XOR<ResultConfigurationScalarRelationFilter, ResultConfigurationWhereInput>
  }

  export type GradingScaleOrderByWithRelationInput = {
    id?: SortOrder
    minScore?: SortOrder
    maxScore?: SortOrder
    grade?: SortOrder
    remark?: SortOrder
    configurationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    configuration?: ResultConfigurationOrderByWithRelationInput
  }

  export type GradingScaleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GradingScaleWhereInput | GradingScaleWhereInput[]
    OR?: GradingScaleWhereInput[]
    NOT?: GradingScaleWhereInput | GradingScaleWhereInput[]
    minScore?: FloatFilter<"GradingScale"> | number
    maxScore?: FloatFilter<"GradingScale"> | number
    grade?: StringFilter<"GradingScale"> | string
    remark?: StringFilter<"GradingScale"> | string
    configurationId?: StringFilter<"GradingScale"> | string
    createdAt?: DateTimeFilter<"GradingScale"> | Date | string
    updatedAt?: DateTimeFilter<"GradingScale"> | Date | string
    configuration?: XOR<ResultConfigurationScalarRelationFilter, ResultConfigurationWhereInput>
  }, "id">

  export type GradingScaleOrderByWithAggregationInput = {
    id?: SortOrder
    minScore?: SortOrder
    maxScore?: SortOrder
    grade?: SortOrder
    remark?: SortOrder
    configurationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GradingScaleCountOrderByAggregateInput
    _avg?: GradingScaleAvgOrderByAggregateInput
    _max?: GradingScaleMaxOrderByAggregateInput
    _min?: GradingScaleMinOrderByAggregateInput
    _sum?: GradingScaleSumOrderByAggregateInput
  }

  export type GradingScaleScalarWhereWithAggregatesInput = {
    AND?: GradingScaleScalarWhereWithAggregatesInput | GradingScaleScalarWhereWithAggregatesInput[]
    OR?: GradingScaleScalarWhereWithAggregatesInput[]
    NOT?: GradingScaleScalarWhereWithAggregatesInput | GradingScaleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GradingScale"> | string
    minScore?: FloatWithAggregatesFilter<"GradingScale"> | number
    maxScore?: FloatWithAggregatesFilter<"GradingScale"> | number
    grade?: StringWithAggregatesFilter<"GradingScale"> | string
    remark?: StringWithAggregatesFilter<"GradingScale"> | string
    configurationId?: StringWithAggregatesFilter<"GradingScale"> | string
    createdAt?: DateTimeWithAggregatesFilter<"GradingScale"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GradingScale"> | Date | string
  }

  export type ComponentScoreWhereInput = {
    AND?: ComponentScoreWhereInput | ComponentScoreWhereInput[]
    OR?: ComponentScoreWhereInput[]
    NOT?: ComponentScoreWhereInput | ComponentScoreWhereInput[]
    id?: StringFilter<"ComponentScore"> | string
    score?: FloatFilter<"ComponentScore"> | number
    componentId?: StringFilter<"ComponentScore"> | string
    resultId?: StringFilter<"ComponentScore"> | string
    createdAt?: DateTimeFilter<"ComponentScore"> | Date | string
    updatedAt?: DateTimeFilter<"ComponentScore"> | Date | string
    component?: XOR<AssessmentComponentScalarRelationFilter, AssessmentComponentWhereInput>
    result?: XOR<ResultScalarRelationFilter, ResultWhereInput>
  }

  export type ComponentScoreOrderByWithRelationInput = {
    id?: SortOrder
    score?: SortOrder
    componentId?: SortOrder
    resultId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    component?: AssessmentComponentOrderByWithRelationInput
    result?: ResultOrderByWithRelationInput
  }

  export type ComponentScoreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ComponentScoreWhereInput | ComponentScoreWhereInput[]
    OR?: ComponentScoreWhereInput[]
    NOT?: ComponentScoreWhereInput | ComponentScoreWhereInput[]
    score?: FloatFilter<"ComponentScore"> | number
    componentId?: StringFilter<"ComponentScore"> | string
    resultId?: StringFilter<"ComponentScore"> | string
    createdAt?: DateTimeFilter<"ComponentScore"> | Date | string
    updatedAt?: DateTimeFilter<"ComponentScore"> | Date | string
    component?: XOR<AssessmentComponentScalarRelationFilter, AssessmentComponentWhereInput>
    result?: XOR<ResultScalarRelationFilter, ResultWhereInput>
  }, "id">

  export type ComponentScoreOrderByWithAggregationInput = {
    id?: SortOrder
    score?: SortOrder
    componentId?: SortOrder
    resultId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ComponentScoreCountOrderByAggregateInput
    _avg?: ComponentScoreAvgOrderByAggregateInput
    _max?: ComponentScoreMaxOrderByAggregateInput
    _min?: ComponentScoreMinOrderByAggregateInput
    _sum?: ComponentScoreSumOrderByAggregateInput
  }

  export type ComponentScoreScalarWhereWithAggregatesInput = {
    AND?: ComponentScoreScalarWhereWithAggregatesInput | ComponentScoreScalarWhereWithAggregatesInput[]
    OR?: ComponentScoreScalarWhereWithAggregatesInput[]
    NOT?: ComponentScoreScalarWhereWithAggregatesInput | ComponentScoreScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ComponentScore"> | string
    score?: FloatWithAggregatesFilter<"ComponentScore"> | number
    componentId?: StringWithAggregatesFilter<"ComponentScore"> | string
    resultId?: StringWithAggregatesFilter<"ComponentScore"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ComponentScore"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ComponentScore"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.UserRole
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    parent?: ParentCreateNestedOneWithoutUserInput
    processedPayments?: PaymentRequestCreateNestedManyWithoutProcessedByInput
    approvedResults?: ResultCreateNestedManyWithoutApprovedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    activityLogs?: UserActivityLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.UserRole
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    schoolId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    parent?: ParentUncheckedCreateNestedOneWithoutUserInput
    processedPayments?: PaymentRequestUncheckedCreateNestedManyWithoutProcessedByInput
    approvedResults?: ResultUncheckedCreateNestedManyWithoutApprovedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    activityLogs?: UserActivityLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    parent?: ParentUpdateOneWithoutUserNestedInput
    processedPayments?: PaymentRequestUpdateManyWithoutProcessedByNestedInput
    approvedResults?: ResultUpdateManyWithoutApprovedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    activityLogs?: UserActivityLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    parent?: ParentUncheckedUpdateOneWithoutUserNestedInput
    processedPayments?: PaymentRequestUncheckedUpdateManyWithoutProcessedByNestedInput
    approvedResults?: ResultUncheckedUpdateManyWithoutApprovedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    activityLogs?: UserActivityLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.UserRole
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    schoolId?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminCreateInput = {
    id?: string
    adminType: $Enums.AdminType
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateInput = {
    id?: string
    userId: string
    adminType: $Enums.AdminType
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminType?: EnumAdminTypeFieldUpdateOperationsInput | $Enums.AdminType
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    adminType?: EnumAdminTypeFieldUpdateOperationsInput | $Enums.AdminType
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateManyInput = {
    id?: string
    userId: string
    adminType: $Enums.AdminType
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminType?: EnumAdminTypeFieldUpdateOperationsInput | $Enums.AdminType
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    adminType?: EnumAdminTypeFieldUpdateOperationsInput | $Enums.AdminType
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherCreateInput = {
    id?: string
    employeeId?: string | null
    qualifications?: string | null
    specialization?: string | null
    joiningDate?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    emergencyContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassCreateNestedManyWithoutTeacherInput
    subjects?: SubjectTeacherCreateNestedManyWithoutTeacherInput
    department?: DepartmentCreateNestedOneWithoutTeachersInput
    user: UserCreateNestedOneWithoutTeacherInput
  }

  export type TeacherUncheckedCreateInput = {
    id?: string
    userId: string
    employeeId?: string | null
    qualifications?: string | null
    specialization?: string | null
    joiningDate?: Date | string | null
    departmentId?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    emergencyContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    subjects?: SubjectTeacherUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassUpdateManyWithoutTeacherNestedInput
    subjects?: SubjectTeacherUpdateManyWithoutTeacherNestedInput
    department?: DepartmentUpdateOneWithoutTeachersNestedInput
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    subjects?: SubjectTeacherUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherCreateManyInput = {
    id?: string
    userId: string
    employeeId?: string | null
    qualifications?: string | null
    specialization?: string | null
    joiningDate?: Date | string | null
    departmentId?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    emergencyContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateInput = {
    id?: string
    admissionDate?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    religion?: string | null
    bloodGroup?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classId?: string | null
    attendance?: AttendanceCreateNestedManyWithoutStudentInput
    paymentRequests?: PaymentRequestCreateNestedManyWithoutStudentInput
    results?: ResultCreateNestedManyWithoutStudentInput
    department?: DepartmentCreateNestedOneWithoutStudentsInput
    user: UserCreateNestedOneWithoutStudentInput
    classes?: StudentClassCreateNestedManyWithoutStudentInput
    parents?: StudentParentCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateInput = {
    id?: string
    userId: string
    admissionDate?: Date | string | null
    departmentId?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    religion?: string | null
    bloodGroup?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classId?: string | null
    attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    paymentRequests?: PaymentRequestUncheckedCreateNestedManyWithoutStudentInput
    results?: ResultUncheckedCreateNestedManyWithoutStudentInput
    classes?: StudentClassUncheckedCreateNestedManyWithoutStudentInput
    parents?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentUncheckedCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    paymentRequests?: PaymentRequestUpdateManyWithoutStudentNestedInput
    results?: ResultUpdateManyWithoutStudentNestedInput
    department?: DepartmentUpdateOneWithoutStudentsNestedInput
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    classes?: StudentClassUpdateManyWithoutStudentNestedInput
    parents?: StudentParentUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    paymentRequests?: PaymentRequestUncheckedUpdateManyWithoutStudentNestedInput
    results?: ResultUncheckedUpdateManyWithoutStudentNestedInput
    classes?: StudentClassUncheckedUpdateManyWithoutStudentNestedInput
    parents?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUncheckedUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateManyInput = {
    id?: string
    userId: string
    admissionDate?: Date | string | null
    departmentId?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    religion?: string | null
    bloodGroup?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classId?: string | null
  }

  export type StudentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ParentCreateInput = {
    id?: string
    occupation?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    alternatePhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutParentInput
    children?: StudentParentCreateNestedManyWithoutParentInput
  }

  export type ParentUncheckedCreateInput = {
    id?: string
    userId: string
    occupation?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    alternatePhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: StudentParentUncheckedCreateNestedManyWithoutParentInput
  }

  export type ParentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutParentNestedInput
    children?: StudentParentUpdateManyWithoutParentNestedInput
  }

  export type ParentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: StudentParentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ParentCreateManyInput = {
    id?: string
    userId: string
    occupation?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    alternatePhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolCreateInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email: string
    logo?: string | null
    subdomain: string
    primaryColor?: string | null
    secondaryColor?: string | null
    shortName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: AcademicSessionCreateNestedManyWithoutSchoolInput
    bills?: BillCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    departments?: DepartmentCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    paymentAccounts?: PaymentAccountCreateNestedManyWithoutSchoolInput
    levels?: SchoolLevelCreateNestedManyWithoutSchoolInput
    subjects?: SubjectCreateNestedManyWithoutSchoolInput
    users?: UserCreateNestedManyWithoutSchoolInput
    resultConfigs?: ResultConfigurationCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email: string
    logo?: string | null
    subdomain: string
    primaryColor?: string | null
    secondaryColor?: string | null
    shortName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: AcademicSessionUncheckedCreateNestedManyWithoutSchoolInput
    bills?: BillUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    paymentAccounts?: PaymentAccountUncheckedCreateNestedManyWithoutSchoolInput
    levels?: SchoolLevelUncheckedCreateNestedManyWithoutSchoolInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutSchoolInput
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    resultConfigs?: ResultConfigurationUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: StringFieldUpdateOperationsInput | string
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    shortName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: AcademicSessionUpdateManyWithoutSchoolNestedInput
    bills?: BillUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    departments?: DepartmentUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    paymentAccounts?: PaymentAccountUpdateManyWithoutSchoolNestedInput
    levels?: SchoolLevelUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUpdateManyWithoutSchoolNestedInput
    users?: UserUpdateManyWithoutSchoolNestedInput
    resultConfigs?: ResultConfigurationUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: StringFieldUpdateOperationsInput | string
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    shortName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: AcademicSessionUncheckedUpdateManyWithoutSchoolNestedInput
    bills?: BillUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    paymentAccounts?: PaymentAccountUncheckedUpdateManyWithoutSchoolNestedInput
    levels?: SchoolLevelUncheckedUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutSchoolNestedInput
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    resultConfigs?: ResultConfigurationUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolCreateManyInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email: string
    logo?: string | null
    subdomain: string
    primaryColor?: string | null
    secondaryColor?: string | null
    shortName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: StringFieldUpdateOperationsInput | string
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    shortName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: StringFieldUpdateOperationsInput | string
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    shortName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutDepartmentsInput
    students?: StudentCreateNestedManyWithoutDepartmentInput
    subjects?: SubjectCreateNestedManyWithoutDepartmentInput
    teachers?: TeacherCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutDepartmentInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutDepartmentInput
    teachers?: TeacherUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutDepartmentsNestedInput
    students?: StudentUpdateManyWithoutDepartmentNestedInput
    subjects?: SubjectUpdateManyWithoutDepartmentNestedInput
    teachers?: TeacherUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutDepartmentNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutDepartmentNestedInput
    teachers?: TeacherUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassCreateInput = {
    id?: string
    name: string
    section?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    level?: SchoolLevelCreateNestedOneWithoutClassesInput
    school: SchoolCreateNestedOneWithoutClassesInput
    teacher?: TeacherCreateNestedOneWithoutClassesInput
    subjects?: ClassSubjectCreateNestedManyWithoutClassInput
    students?: StudentClassCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateInput = {
    id?: string
    name: string
    section?: string | null
    schoolId: string
    teacherId?: string | null
    levelId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: ClassSubjectUncheckedCreateNestedManyWithoutClassInput
    students?: StudentClassUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: SchoolLevelUpdateOneWithoutClassesNestedInput
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    teacher?: TeacherUpdateOneWithoutClassesNestedInput
    subjects?: ClassSubjectUpdateManyWithoutClassNestedInput
    students?: StudentClassUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: ClassSubjectUncheckedUpdateManyWithoutClassNestedInput
    students?: StudentClassUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassCreateManyInput = {
    id?: string
    name: string
    section?: string | null
    schoolId: string
    teacherId?: string | null
    levelId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectCreateInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassSubjectCreateNestedManyWithoutSubjectInput
    results?: ResultCreateNestedManyWithoutSubjectInput
    students?: StudentSubjectCreateNestedManyWithoutSubjectInput
    department?: DepartmentCreateNestedOneWithoutSubjectsInput
    level?: SchoolLevelCreateNestedOneWithoutSubjectsInput
    school: SchoolCreateNestedOneWithoutSubjectsInput
    teachers?: SubjectTeacherCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    schoolId: string
    departmentId?: string | null
    levelId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassSubjectUncheckedCreateNestedManyWithoutSubjectInput
    results?: ResultUncheckedCreateNestedManyWithoutSubjectInput
    students?: StudentSubjectUncheckedCreateNestedManyWithoutSubjectInput
    teachers?: SubjectTeacherUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassSubjectUpdateManyWithoutSubjectNestedInput
    results?: ResultUpdateManyWithoutSubjectNestedInput
    students?: StudentSubjectUpdateManyWithoutSubjectNestedInput
    department?: DepartmentUpdateOneWithoutSubjectsNestedInput
    level?: SchoolLevelUpdateOneWithoutSubjectsNestedInput
    school?: SchoolUpdateOneRequiredWithoutSubjectsNestedInput
    teachers?: SubjectTeacherUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    results?: ResultUncheckedUpdateManyWithoutSubjectNestedInput
    students?: StudentSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    teachers?: SubjectTeacherUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectCreateManyInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    schoolId: string
    departmentId?: string | null
    levelId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicSessionCreateInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutSessionsInput
    attendance?: AttendanceCreateNestedManyWithoutSessionInput
    results?: ResultCreateNestedManyWithoutSessionInput
    studentClasses?: StudentClassCreateNestedManyWithoutSessionInput
    resultConfigurations?: ResultConfigurationCreateNestedManyWithoutSessionInput
  }

  export type AcademicSessionUncheckedCreateInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    attendance?: AttendanceUncheckedCreateNestedManyWithoutSessionInput
    results?: ResultUncheckedCreateNestedManyWithoutSessionInput
    studentClasses?: StudentClassUncheckedCreateNestedManyWithoutSessionInput
    resultConfigurations?: ResultConfigurationUncheckedCreateNestedManyWithoutSessionInput
  }

  export type AcademicSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutSessionsNestedInput
    attendance?: AttendanceUpdateManyWithoutSessionNestedInput
    results?: ResultUpdateManyWithoutSessionNestedInput
    studentClasses?: StudentClassUpdateManyWithoutSessionNestedInput
    resultConfigurations?: ResultConfigurationUpdateManyWithoutSessionNestedInput
  }

  export type AcademicSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: AttendanceUncheckedUpdateManyWithoutSessionNestedInput
    results?: ResultUncheckedUpdateManyWithoutSessionNestedInput
    studentClasses?: StudentClassUncheckedUpdateManyWithoutSessionNestedInput
    resultConfigurations?: ResultConfigurationUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type AcademicSessionCreateManyInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentClassCreateInput = {
    id?: string
    rollNumber?: string | null
    status?: $Enums.EnrollmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutStudentsInput
    session: AcademicSessionCreateNestedOneWithoutStudentClassesInput
    student: StudentCreateNestedOneWithoutClassesInput
  }

  export type StudentClassUncheckedCreateInput = {
    id?: string
    studentId: string
    classId: string
    sessionId: string
    rollNumber?: string | null
    status?: $Enums.EnrollmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentClassUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutStudentsNestedInput
    session?: AcademicSessionUpdateOneRequiredWithoutStudentClassesNestedInput
    student?: StudentUpdateOneRequiredWithoutClassesNestedInput
  }

  export type StudentClassUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentClassCreateManyInput = {
    id?: string
    studentId: string
    classId: string
    sessionId: string
    rollNumber?: string | null
    status?: $Enums.EnrollmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentClassUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentClassUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentParentCreateInput = {
    id?: string
    relation?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent: ParentCreateNestedOneWithoutChildrenInput
    student: StudentCreateNestedOneWithoutParentsInput
  }

  export type StudentParentUncheckedCreateInput = {
    id?: string
    studentId: string
    parentId: string
    relation?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentParentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: ParentUpdateOneRequiredWithoutChildrenNestedInput
    student?: StudentUpdateOneRequiredWithoutParentsNestedInput
  }

  export type StudentParentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentParentCreateManyInput = {
    id?: string
    studentId: string
    parentId: string
    relation?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentParentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentParentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectTeacherCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: SubjectCreateNestedOneWithoutTeachersInput
    teacher: TeacherCreateNestedOneWithoutSubjectsInput
  }

  export type SubjectTeacherUncheckedCreateInput = {
    id?: string
    subjectId: string
    teacherId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectTeacherUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneRequiredWithoutTeachersNestedInput
    teacher?: TeacherUpdateOneRequiredWithoutSubjectsNestedInput
  }

  export type SubjectTeacherUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectTeacherCreateManyInput = {
    id?: string
    subjectId: string
    teacherId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectTeacherUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectTeacherUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassSubjectCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutSubjectsInput
    subject: SubjectCreateNestedOneWithoutClassesInput
  }

  export type ClassSubjectUncheckedCreateInput = {
    id?: string
    classId: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassSubjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutSubjectsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutClassesNestedInput
  }

  export type ClassSubjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassSubjectCreateManyInput = {
    id?: string
    classId: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassSubjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassSubjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    session: AcademicSessionCreateNestedOneWithoutAttendanceInput
    student: StudentCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    studentId: string
    sessionId: string
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: AcademicSessionUpdateOneRequiredWithoutAttendanceNestedInput
    student?: StudentUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    studentId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateManyInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    studentId: string
    sessionId: string
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    studentId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultCreateInput = {
    id?: string
    total: number
    grade: string
    remark: string
    cumulativeAverage?: number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: string | null
    adminComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    componentScores?: ComponentScoreCreateNestedManyWithoutResultInput
    student: StudentCreateNestedOneWithoutResultsInput
    subject: SubjectCreateNestedOneWithoutResultsInput
    period: ResultPeriodCreateNestedOneWithoutResultsInput
    session: AcademicSessionCreateNestedOneWithoutResultsInput
    approvedBy?: UserCreateNestedOneWithoutApprovedResultsInput
  }

  export type ResultUncheckedCreateInput = {
    id?: string
    studentId: string
    subjectId: string
    periodId: string
    sessionId: string
    total: number
    grade: string
    remark: string
    cumulativeAverage?: number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: string | null
    adminComment?: string | null
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    componentScores?: ComponentScoreUncheckedCreateNestedManyWithoutResultInput
  }

  export type ResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remark?: StringFieldUpdateOperationsInput | string
    cumulativeAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: NullableStringFieldUpdateOperationsInput | string | null
    adminComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    componentScores?: ComponentScoreUpdateManyWithoutResultNestedInput
    student?: StudentUpdateOneRequiredWithoutResultsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutResultsNestedInput
    period?: ResultPeriodUpdateOneRequiredWithoutResultsNestedInput
    session?: AcademicSessionUpdateOneRequiredWithoutResultsNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedResultsNestedInput
  }

  export type ResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remark?: StringFieldUpdateOperationsInput | string
    cumulativeAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: NullableStringFieldUpdateOperationsInput | string | null
    adminComment?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    componentScores?: ComponentScoreUncheckedUpdateManyWithoutResultNestedInput
  }

  export type ResultCreateManyInput = {
    id?: string
    studentId: string
    subjectId: string
    periodId: string
    sessionId: string
    total: number
    grade: string
    remark: string
    cumulativeAverage?: number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: string | null
    adminComment?: string | null
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remark?: StringFieldUpdateOperationsInput | string
    cumulativeAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: NullableStringFieldUpdateOperationsInput | string | null
    adminComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remark?: StringFieldUpdateOperationsInput | string
    cumulativeAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: NullableStringFieldUpdateOperationsInput | string | null
    adminComment?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    location?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutEventsInput
  }

  export type EventUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    location?: string | null
    isPublic?: boolean
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutEventsNestedInput
  }

  export type EventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    location?: string | null
    isPublic?: boolean
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSubjectCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutSubjectsInput
    subject: SubjectCreateNestedOneWithoutStudentsInput
  }

  export type StudentSubjectUncheckedCreateInput = {
    id?: string
    studentId: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSubjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutSubjectsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutStudentsNestedInput
  }

  export type StudentSubjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSubjectCreateManyInput = {
    id?: string
    studentId: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSubjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSubjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillCreateInput = {
    id?: string
    name: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    account: PaymentAccountCreateNestedOneWithoutBillsInput
    school: SchoolCreateNestedOneWithoutBillsInput
    assignments?: BillAssignmentCreateNestedManyWithoutBillInput
    items?: BillItemCreateNestedManyWithoutBillInput
    paymentRequests?: PaymentRequestCreateNestedManyWithoutBillInput
  }

  export type BillUncheckedCreateInput = {
    id?: string
    name: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schoolId: string
    accountId: string
    assignments?: BillAssignmentUncheckedCreateNestedManyWithoutBillInput
    items?: BillItemUncheckedCreateNestedManyWithoutBillInput
    paymentRequests?: PaymentRequestUncheckedCreateNestedManyWithoutBillInput
  }

  export type BillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: PaymentAccountUpdateOneRequiredWithoutBillsNestedInput
    school?: SchoolUpdateOneRequiredWithoutBillsNestedInput
    assignments?: BillAssignmentUpdateManyWithoutBillNestedInput
    items?: BillItemUpdateManyWithoutBillNestedInput
    paymentRequests?: PaymentRequestUpdateManyWithoutBillNestedInput
  }

  export type BillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    assignments?: BillAssignmentUncheckedUpdateManyWithoutBillNestedInput
    items?: BillItemUncheckedUpdateManyWithoutBillNestedInput
    paymentRequests?: PaymentRequestUncheckedUpdateManyWithoutBillNestedInput
  }

  export type BillCreateManyInput = {
    id?: string
    name: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schoolId: string
    accountId: string
  }

  export type BillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
  }

  export type BillItemCreateInput = {
    id?: string
    name: string
    amount: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bill: BillCreateNestedOneWithoutItemsInput
  }

  export type BillItemUncheckedCreateInput = {
    id?: string
    billId: string
    name: string
    amount: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bill?: BillUpdateOneRequiredWithoutItemsNestedInput
  }

  export type BillItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    billId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillItemCreateManyInput = {
    id?: string
    billId: string
    name: string
    amount: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    billId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentAccountCreateInput = {
    id?: string
    name: string
    accountNo: string
    bankName: string
    branchCode?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bills?: BillCreateNestedManyWithoutAccountInput
    school: SchoolCreateNestedOneWithoutPaymentAccountsInput
  }

  export type PaymentAccountUncheckedCreateInput = {
    id?: string
    name: string
    accountNo: string
    bankName: string
    branchCode?: string | null
    description?: string | null
    isActive?: boolean
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bills?: BillUncheckedCreateNestedManyWithoutAccountInput
  }

  export type PaymentAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountNo?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    branchCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: BillUpdateManyWithoutAccountNestedInput
    school?: SchoolUpdateOneRequiredWithoutPaymentAccountsNestedInput
  }

  export type PaymentAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountNo?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    branchCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: BillUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type PaymentAccountCreateManyInput = {
    id?: string
    name: string
    accountNo: string
    bankName: string
    branchCode?: string | null
    description?: string | null
    isActive?: boolean
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountNo?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    branchCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountNo?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    branchCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillAssignmentCreateInput = {
    id?: string
    targetType: $Enums.BillAssignmentType
    targetId: string
    dueDate: Date | string
    status?: $Enums.BillStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    bill: BillCreateNestedOneWithoutAssignmentsInput
    paymentRequests?: PaymentRequestCreateNestedManyWithoutBillAssignmentInput
    studentPayments?: StudentPaymentCreateNestedManyWithoutBillAssignmentInput
  }

  export type BillAssignmentUncheckedCreateInput = {
    id?: string
    billId: string
    targetType: $Enums.BillAssignmentType
    targetId: string
    dueDate: Date | string
    status?: $Enums.BillStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentRequests?: PaymentRequestUncheckedCreateNestedManyWithoutBillAssignmentInput
    studentPayments?: StudentPaymentUncheckedCreateNestedManyWithoutBillAssignmentInput
  }

  export type BillAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumBillAssignmentTypeFieldUpdateOperationsInput | $Enums.BillAssignmentType
    targetId?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bill?: BillUpdateOneRequiredWithoutAssignmentsNestedInput
    paymentRequests?: PaymentRequestUpdateManyWithoutBillAssignmentNestedInput
    studentPayments?: StudentPaymentUpdateManyWithoutBillAssignmentNestedInput
  }

  export type BillAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    billId?: StringFieldUpdateOperationsInput | string
    targetType?: EnumBillAssignmentTypeFieldUpdateOperationsInput | $Enums.BillAssignmentType
    targetId?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentRequests?: PaymentRequestUncheckedUpdateManyWithoutBillAssignmentNestedInput
    studentPayments?: StudentPaymentUncheckedUpdateManyWithoutBillAssignmentNestedInput
  }

  export type BillAssignmentCreateManyInput = {
    id?: string
    billId: string
    targetType: $Enums.BillAssignmentType
    targetId: string
    dueDate: Date | string
    status?: $Enums.BillStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumBillAssignmentTypeFieldUpdateOperationsInput | $Enums.BillAssignmentType
    targetId?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    billId?: StringFieldUpdateOperationsInput | string
    targetType?: EnumBillAssignmentTypeFieldUpdateOperationsInput | $Enums.BillAssignmentType
    targetId?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentPaymentCreateInput = {
    id?: string
    amountPaid: number
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentRequests?: PaymentRequestCreateNestedManyWithoutStudentPaymentInput
    billAssignment: BillAssignmentCreateNestedOneWithoutStudentPaymentsInput
    student: StudentCreateNestedOneWithoutPaymentsInput
  }

  export type StudentPaymentUncheckedCreateInput = {
    id?: string
    billAssignmentId: string
    studentId: string
    amountPaid: number
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentRequests?: PaymentRequestUncheckedCreateNestedManyWithoutStudentPaymentInput
  }

  export type StudentPaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentRequests?: PaymentRequestUpdateManyWithoutStudentPaymentNestedInput
    billAssignment?: BillAssignmentUpdateOneRequiredWithoutStudentPaymentsNestedInput
    student?: StudentUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type StudentPaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    billAssignmentId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentRequests?: PaymentRequestUncheckedUpdateManyWithoutStudentPaymentNestedInput
  }

  export type StudentPaymentCreateManyInput = {
    id?: string
    billAssignmentId: string
    studentId: string
    amountPaid: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentPaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentPaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    billAssignmentId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentRequestCreateInput = {
    id?: string
    amount: number
    receiptUrl?: string | null
    status?: $Enums.PaymentStatus
    notes?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    billAssignment: BillAssignmentCreateNestedOneWithoutPaymentRequestsInput
    bill: BillCreateNestedOneWithoutPaymentRequestsInput
    processedBy?: UserCreateNestedOneWithoutProcessedPaymentsInput
    student: StudentCreateNestedOneWithoutPaymentRequestsInput
    studentPayment?: StudentPaymentCreateNestedOneWithoutPaymentRequestsInput
  }

  export type PaymentRequestUncheckedCreateInput = {
    id?: string
    billId: string
    billAssignmentId: string
    studentPaymentId?: string | null
    studentId: string
    amount: number
    receiptUrl?: string | null
    status?: $Enums.PaymentStatus
    notes?: string | null
    processedById?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billAssignment?: BillAssignmentUpdateOneRequiredWithoutPaymentRequestsNestedInput
    bill?: BillUpdateOneRequiredWithoutPaymentRequestsNestedInput
    processedBy?: UserUpdateOneWithoutProcessedPaymentsNestedInput
    student?: StudentUpdateOneRequiredWithoutPaymentRequestsNestedInput
    studentPayment?: StudentPaymentUpdateOneWithoutPaymentRequestsNestedInput
  }

  export type PaymentRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    billId?: StringFieldUpdateOperationsInput | string
    billAssignmentId?: StringFieldUpdateOperationsInput | string
    studentPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentRequestCreateManyInput = {
    id?: string
    billId: string
    billAssignmentId: string
    studentPaymentId?: string | null
    studentId: string
    amount: number
    receiptUrl?: string | null
    status?: $Enums.PaymentStatus
    notes?: string | null
    processedById?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    billId?: StringFieldUpdateOperationsInput | string
    billAssignmentId?: StringFieldUpdateOperationsInput | string
    studentPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolLevelCreateInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassCreateNestedManyWithoutLevelInput
    school: SchoolCreateNestedOneWithoutLevelsInput
    subjects?: SubjectCreateNestedManyWithoutLevelInput
  }

  export type SchoolLevelUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassUncheckedCreateNestedManyWithoutLevelInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutLevelInput
  }

  export type SchoolLevelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassUpdateManyWithoutLevelNestedInput
    school?: SchoolUpdateOneRequiredWithoutLevelsNestedInput
    subjects?: SubjectUpdateManyWithoutLevelNestedInput
  }

  export type SchoolLevelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassUncheckedUpdateManyWithoutLevelNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutLevelNestedInput
  }

  export type SchoolLevelCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolLevelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolLevelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivityLogCreateInput = {
    id?: string
    page: string
    action: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutActivityLogsInput
  }

  export type UserActivityLogUncheckedCreateInput = {
    id?: string
    userId: string
    page: string
    action: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UserActivityLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutActivityLogsNestedInput
  }

  export type UserActivityLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivityLogCreateManyInput = {
    id?: string
    userId: string
    page: string
    action: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UserActivityLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivityLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiRequestLogCreateInput = {
    id?: string
    route: string
    method: string
    status: number
    duration: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ApiRequestLogUncheckedCreateInput = {
    id?: string
    route: string
    method: string
    status: number
    duration: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ApiRequestLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiRequestLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiRequestLogCreateManyInput = {
    id?: string
    route: string
    method: string
    status: number
    duration: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ApiRequestLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiRequestLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultConfigurationCreateInput = {
    id?: string
    cumulativeEnabled?: boolean
    cumulativeMethod?: string
    showCumulativePerTerm?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    periods?: ResultPeriodCreateNestedManyWithoutConfigurationInput
    assessmentComponents?: AssessmentComponentCreateNestedManyWithoutConfigurationInput
    gradingScale?: GradingScaleCreateNestedManyWithoutConfigurationInput
    school: SchoolCreateNestedOneWithoutResultConfigsInput
    session: AcademicSessionCreateNestedOneWithoutResultConfigurationsInput
  }

  export type ResultConfigurationUncheckedCreateInput = {
    id?: string
    schoolId: string
    sessionId: string
    cumulativeEnabled?: boolean
    cumulativeMethod?: string
    showCumulativePerTerm?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    periods?: ResultPeriodUncheckedCreateNestedManyWithoutConfigurationInput
    assessmentComponents?: AssessmentComponentUncheckedCreateNestedManyWithoutConfigurationInput
    gradingScale?: GradingScaleUncheckedCreateNestedManyWithoutConfigurationInput
  }

  export type ResultConfigurationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cumulativeEnabled?: BoolFieldUpdateOperationsInput | boolean
    cumulativeMethod?: StringFieldUpdateOperationsInput | string
    showCumulativePerTerm?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    periods?: ResultPeriodUpdateManyWithoutConfigurationNestedInput
    assessmentComponents?: AssessmentComponentUpdateManyWithoutConfigurationNestedInput
    gradingScale?: GradingScaleUpdateManyWithoutConfigurationNestedInput
    school?: SchoolUpdateOneRequiredWithoutResultConfigsNestedInput
    session?: AcademicSessionUpdateOneRequiredWithoutResultConfigurationsNestedInput
  }

  export type ResultConfigurationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    cumulativeEnabled?: BoolFieldUpdateOperationsInput | boolean
    cumulativeMethod?: StringFieldUpdateOperationsInput | string
    showCumulativePerTerm?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    periods?: ResultPeriodUncheckedUpdateManyWithoutConfigurationNestedInput
    assessmentComponents?: AssessmentComponentUncheckedUpdateManyWithoutConfigurationNestedInput
    gradingScale?: GradingScaleUncheckedUpdateManyWithoutConfigurationNestedInput
  }

  export type ResultConfigurationCreateManyInput = {
    id?: string
    schoolId: string
    sessionId: string
    cumulativeEnabled?: boolean
    cumulativeMethod?: string
    showCumulativePerTerm?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResultConfigurationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cumulativeEnabled?: BoolFieldUpdateOperationsInput | boolean
    cumulativeMethod?: StringFieldUpdateOperationsInput | string
    showCumulativePerTerm?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultConfigurationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    cumulativeEnabled?: BoolFieldUpdateOperationsInput | boolean
    cumulativeMethod?: StringFieldUpdateOperationsInput | string
    showCumulativePerTerm?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultPeriodCreateInput = {
    id?: string
    name: string
    weight?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    configuration: ResultConfigurationCreateNestedOneWithoutPeriodsInput
    results?: ResultCreateNestedManyWithoutPeriodInput
  }

  export type ResultPeriodUncheckedCreateInput = {
    id?: string
    name: string
    weight?: number
    configurationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    results?: ResultUncheckedCreateNestedManyWithoutPeriodInput
  }

  export type ResultPeriodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    configuration?: ResultConfigurationUpdateOneRequiredWithoutPeriodsNestedInput
    results?: ResultUpdateManyWithoutPeriodNestedInput
  }

  export type ResultPeriodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    configurationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: ResultUncheckedUpdateManyWithoutPeriodNestedInput
  }

  export type ResultPeriodCreateManyInput = {
    id?: string
    name: string
    weight?: number
    configurationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResultPeriodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultPeriodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    configurationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentComponentCreateInput = {
    id?: string
    name: string
    key: string
    maxScore: number
    createdAt?: Date | string
    updatedAt?: Date | string
    configuration: ResultConfigurationCreateNestedOneWithoutAssessmentComponentsInput
    scores?: ComponentScoreCreateNestedManyWithoutComponentInput
  }

  export type AssessmentComponentUncheckedCreateInput = {
    id?: string
    name: string
    key: string
    maxScore: number
    configurationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    scores?: ComponentScoreUncheckedCreateNestedManyWithoutComponentInput
  }

  export type AssessmentComponentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    maxScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    configuration?: ResultConfigurationUpdateOneRequiredWithoutAssessmentComponentsNestedInput
    scores?: ComponentScoreUpdateManyWithoutComponentNestedInput
  }

  export type AssessmentComponentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    maxScore?: FloatFieldUpdateOperationsInput | number
    configurationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scores?: ComponentScoreUncheckedUpdateManyWithoutComponentNestedInput
  }

  export type AssessmentComponentCreateManyInput = {
    id?: string
    name: string
    key: string
    maxScore: number
    configurationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssessmentComponentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    maxScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentComponentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    maxScore?: FloatFieldUpdateOperationsInput | number
    configurationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradingScaleCreateInput = {
    id?: string
    minScore: number
    maxScore: number
    grade: string
    remark: string
    createdAt?: Date | string
    updatedAt?: Date | string
    configuration: ResultConfigurationCreateNestedOneWithoutGradingScaleInput
  }

  export type GradingScaleUncheckedCreateInput = {
    id?: string
    minScore: number
    maxScore: number
    grade: string
    remark: string
    configurationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GradingScaleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    minScore?: FloatFieldUpdateOperationsInput | number
    maxScore?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remark?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    configuration?: ResultConfigurationUpdateOneRequiredWithoutGradingScaleNestedInput
  }

  export type GradingScaleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    minScore?: FloatFieldUpdateOperationsInput | number
    maxScore?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remark?: StringFieldUpdateOperationsInput | string
    configurationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradingScaleCreateManyInput = {
    id?: string
    minScore: number
    maxScore: number
    grade: string
    remark: string
    configurationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GradingScaleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    minScore?: FloatFieldUpdateOperationsInput | number
    maxScore?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remark?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradingScaleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    minScore?: FloatFieldUpdateOperationsInput | number
    maxScore?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remark?: StringFieldUpdateOperationsInput | string
    configurationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComponentScoreCreateInput = {
    id?: string
    score: number
    createdAt?: Date | string
    updatedAt?: Date | string
    component: AssessmentComponentCreateNestedOneWithoutScoresInput
    result: ResultCreateNestedOneWithoutComponentScoresInput
  }

  export type ComponentScoreUncheckedCreateInput = {
    id?: string
    score: number
    componentId: string
    resultId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComponentScoreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    component?: AssessmentComponentUpdateOneRequiredWithoutScoresNestedInput
    result?: ResultUpdateOneRequiredWithoutComponentScoresNestedInput
  }

  export type ComponentScoreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    componentId?: StringFieldUpdateOperationsInput | string
    resultId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComponentScoreCreateManyInput = {
    id?: string
    score: number
    componentId: string
    resultId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComponentScoreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComponentScoreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    componentId?: StringFieldUpdateOperationsInput | string
    resultId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type AdminNullableScalarRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type ParentNullableScalarRelationFilter = {
    is?: ParentWhereInput | null
    isNot?: ParentWhereInput | null
  }

  export type PaymentRequestListRelationFilter = {
    every?: PaymentRequestWhereInput
    some?: PaymentRequestWhereInput
    none?: PaymentRequestWhereInput
  }

  export type ResultListRelationFilter = {
    every?: ResultWhereInput
    some?: ResultWhereInput
    none?: ResultWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type StudentNullableScalarRelationFilter = {
    is?: StudentWhereInput | null
    isNot?: StudentWhereInput | null
  }

  export type TeacherNullableScalarRelationFilter = {
    is?: TeacherWhereInput | null
    isNot?: TeacherWhereInput | null
  }

  export type SchoolNullableScalarRelationFilter = {
    is?: SchoolWhereInput | null
    isNot?: SchoolWhereInput | null
  }

  export type UserActivityLogListRelationFilter = {
    every?: UserActivityLogWhereInput
    some?: UserActivityLogWhereInput
    none?: UserActivityLogWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserActivityLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    profileImage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    schoolId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    profileImage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    schoolId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    profileImage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    schoolId?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumAdminTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminType | EnumAdminTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdminType[] | ListEnumAdminTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminType[] | ListEnumAdminTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminTypeFilter<$PrismaModel> | $Enums.AdminType
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adminType?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adminType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adminType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAdminTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminType | EnumAdminTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdminType[] | ListEnumAdminTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminType[] | ListEnumAdminTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminTypeWithAggregatesFilter<$PrismaModel> | $Enums.AdminType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminTypeFilter<$PrismaModel>
    _max?: NestedEnumAdminTypeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type ClassListRelationFilter = {
    every?: ClassWhereInput
    some?: ClassWhereInput
    none?: ClassWhereInput
  }

  export type SubjectTeacherListRelationFilter = {
    every?: SubjectTeacherWhereInput
    some?: SubjectTeacherWhereInput
    none?: SubjectTeacherWhereInput
  }

  export type DepartmentNullableScalarRelationFilter = {
    is?: DepartmentWhereInput | null
    isNot?: DepartmentWhereInput | null
  }

  export type ClassOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubjectTeacherOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeacherCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    employeeId?: SortOrder
    qualifications?: SortOrder
    specialization?: SortOrder
    joiningDate?: SortOrder
    departmentId?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    emergencyContact?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    employeeId?: SortOrder
    qualifications?: SortOrder
    specialization?: SortOrder
    joiningDate?: SortOrder
    departmentId?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    emergencyContact?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    employeeId?: SortOrder
    qualifications?: SortOrder
    specialization?: SortOrder
    joiningDate?: SortOrder
    departmentId?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    emergencyContact?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceListRelationFilter = {
    every?: AttendanceWhereInput
    some?: AttendanceWhereInput
    none?: AttendanceWhereInput
  }

  export type StudentClassListRelationFilter = {
    every?: StudentClassWhereInput
    some?: StudentClassWhereInput
    none?: StudentClassWhereInput
  }

  export type StudentParentListRelationFilter = {
    every?: StudentParentWhereInput
    some?: StudentParentWhereInput
    none?: StudentParentWhereInput
  }

  export type StudentPaymentListRelationFilter = {
    every?: StudentPaymentWhereInput
    some?: StudentPaymentWhereInput
    none?: StudentPaymentWhereInput
  }

  export type StudentSubjectListRelationFilter = {
    every?: StudentSubjectWhereInput
    some?: StudentSubjectWhereInput
    none?: StudentSubjectWhereInput
  }

  export type AttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentClassOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentParentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentSubjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    admissionDate?: SortOrder
    departmentId?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    religion?: SortOrder
    bloodGroup?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    classId?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    admissionDate?: SortOrder
    departmentId?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    religion?: SortOrder
    bloodGroup?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    classId?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    admissionDate?: SortOrder
    departmentId?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    religion?: SortOrder
    bloodGroup?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    classId?: SortOrder
  }

  export type ParentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    occupation?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    alternatePhone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    occupation?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    alternatePhone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    occupation?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    alternatePhone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicSessionListRelationFilter = {
    every?: AcademicSessionWhereInput
    some?: AcademicSessionWhereInput
    none?: AcademicSessionWhereInput
  }

  export type BillListRelationFilter = {
    every?: BillWhereInput
    some?: BillWhereInput
    none?: BillWhereInput
  }

  export type DepartmentListRelationFilter = {
    every?: DepartmentWhereInput
    some?: DepartmentWhereInput
    none?: DepartmentWhereInput
  }

  export type EventListRelationFilter = {
    every?: EventWhereInput
    some?: EventWhereInput
    none?: EventWhereInput
  }

  export type PaymentAccountListRelationFilter = {
    every?: PaymentAccountWhereInput
    some?: PaymentAccountWhereInput
    none?: PaymentAccountWhereInput
  }

  export type SchoolLevelListRelationFilter = {
    every?: SchoolLevelWhereInput
    some?: SchoolLevelWhereInput
    none?: SchoolLevelWhereInput
  }

  export type SubjectListRelationFilter = {
    every?: SubjectWhereInput
    some?: SubjectWhereInput
    none?: SubjectWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type ResultConfigurationListRelationFilter = {
    every?: ResultConfigurationWhereInput
    some?: ResultConfigurationWhereInput
    none?: ResultConfigurationWhereInput
  }

  export type AcademicSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolLevelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResultConfigurationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    logo?: SortOrder
    subdomain?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    shortName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    logo?: SortOrder
    subdomain?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    shortName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    logo?: SortOrder
    subdomain?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    shortName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolScalarRelationFilter = {
    is?: SchoolWhereInput
    isNot?: SchoolWhereInput
  }

  export type StudentListRelationFilter = {
    every?: StudentWhereInput
    some?: StudentWhereInput
    none?: StudentWhereInput
  }

  export type TeacherListRelationFilter = {
    every?: TeacherWhereInput
    some?: TeacherWhereInput
    none?: TeacherWhereInput
  }

  export type StudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeacherOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolLevelNullableScalarRelationFilter = {
    is?: SchoolLevelWhereInput | null
    isNot?: SchoolLevelWhereInput | null
  }

  export type ClassSubjectListRelationFilter = {
    every?: ClassSubjectWhereInput
    some?: ClassSubjectWhereInput
    none?: ClassSubjectWhereInput
  }

  export type ClassSubjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    section?: SortOrder
    schoolId?: SortOrder
    teacherId?: SortOrder
    levelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    section?: SortOrder
    schoolId?: SortOrder
    teacherId?: SortOrder
    levelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    section?: SortOrder
    schoolId?: SortOrder
    teacherId?: SortOrder
    levelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    schoolId?: SortOrder
    departmentId?: SortOrder
    levelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    schoolId?: SortOrder
    departmentId?: SortOrder
    levelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    schoolId?: SortOrder
    departmentId?: SortOrder
    levelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type AcademicSessionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isCurrent?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isCurrent?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicSessionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isCurrent?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumEnrollmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EnrollmentStatus | EnumEnrollmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnrollmentStatus[] | ListEnumEnrollmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnrollmentStatus[] | ListEnumEnrollmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnrollmentStatusFilter<$PrismaModel> | $Enums.EnrollmentStatus
  }

  export type ClassScalarRelationFilter = {
    is?: ClassWhereInput
    isNot?: ClassWhereInput
  }

  export type AcademicSessionScalarRelationFilter = {
    is?: AcademicSessionWhereInput
    isNot?: AcademicSessionWhereInput
  }

  export type StudentScalarRelationFilter = {
    is?: StudentWhereInput
    isNot?: StudentWhereInput
  }

  export type StudentClassStudentIdClassIdSessionIdCompoundUniqueInput = {
    studentId: string
    classId: string
    sessionId: string
  }

  export type StudentClassCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    sessionId?: SortOrder
    rollNumber?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentClassMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    sessionId?: SortOrder
    rollNumber?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentClassMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    sessionId?: SortOrder
    rollNumber?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEnrollmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnrollmentStatus | EnumEnrollmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnrollmentStatus[] | ListEnumEnrollmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnrollmentStatus[] | ListEnumEnrollmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnrollmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.EnrollmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnrollmentStatusFilter<$PrismaModel>
    _max?: NestedEnumEnrollmentStatusFilter<$PrismaModel>
  }

  export type ParentScalarRelationFilter = {
    is?: ParentWhereInput
    isNot?: ParentWhereInput
  }

  export type StudentParentStudentIdParentIdCompoundUniqueInput = {
    studentId: string
    parentId: string
  }

  export type StudentParentCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    parentId?: SortOrder
    relation?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentParentMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    parentId?: SortOrder
    relation?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentParentMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    parentId?: SortOrder
    relation?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubjectScalarRelationFilter = {
    is?: SubjectWhereInput
    isNot?: SubjectWhereInput
  }

  export type TeacherScalarRelationFilter = {
    is?: TeacherWhereInput
    isNot?: TeacherWhereInput
  }

  export type SubjectTeacherSubjectIdTeacherIdCompoundUniqueInput = {
    subjectId: string
    teacherId: string
  }

  export type SubjectTeacherCountOrderByAggregateInput = {
    id?: SortOrder
    subjectId?: SortOrder
    teacherId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubjectTeacherMaxOrderByAggregateInput = {
    id?: SortOrder
    subjectId?: SortOrder
    teacherId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubjectTeacherMinOrderByAggregateInput = {
    id?: SortOrder
    subjectId?: SortOrder
    teacherId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassSubjectClassIdSubjectIdCompoundUniqueInput = {
    classId: string
    subjectId: string
  }

  export type ClassSubjectCountOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassSubjectMaxOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassSubjectMinOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type AttendanceStudentIdDateSessionIdCompoundUniqueInput = {
    studentId: string
    date: Date | string
    sessionId: string
  }

  export type AttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    studentId?: SortOrder
    sessionId?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    studentId?: SortOrder
    sessionId?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    studentId?: SortOrder
    sessionId?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ComponentScoreListRelationFilter = {
    every?: ComponentScoreWhereInput
    some?: ComponentScoreWhereInput
    none?: ComponentScoreWhereInput
  }

  export type ResultPeriodScalarRelationFilter = {
    is?: ResultPeriodWhereInput
    isNot?: ResultPeriodWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ComponentScoreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResultStudentIdSubjectIdPeriodIdSessionIdCompoundUniqueInput = {
    studentId: string
    subjectId: string
    periodId: string
    sessionId: string
  }

  export type ResultCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    periodId?: SortOrder
    sessionId?: SortOrder
    total?: SortOrder
    grade?: SortOrder
    remark?: SortOrder
    cumulativeAverage?: SortOrder
    affectiveTraits?: SortOrder
    psychomotorSkills?: SortOrder
    customFields?: SortOrder
    teacherComment?: SortOrder
    adminComment?: SortOrder
    approvedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResultAvgOrderByAggregateInput = {
    total?: SortOrder
    cumulativeAverage?: SortOrder
  }

  export type ResultMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    periodId?: SortOrder
    sessionId?: SortOrder
    total?: SortOrder
    grade?: SortOrder
    remark?: SortOrder
    cumulativeAverage?: SortOrder
    teacherComment?: SortOrder
    adminComment?: SortOrder
    approvedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResultMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    periodId?: SortOrder
    sessionId?: SortOrder
    total?: SortOrder
    grade?: SortOrder
    remark?: SortOrder
    cumulativeAverage?: SortOrder
    teacherComment?: SortOrder
    adminComment?: SortOrder
    approvedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResultSumOrderByAggregateInput = {
    total?: SortOrder
    cumulativeAverage?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrder
    isPublic?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrder
    isPublic?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrder
    isPublic?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentSubjectStudentIdSubjectIdCompoundUniqueInput = {
    studentId: string
    subjectId: string
  }

  export type StudentSubjectCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentSubjectMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentSubjectMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAccountScalarRelationFilter = {
    is?: PaymentAccountWhereInput
    isNot?: PaymentAccountWhereInput
  }

  export type BillAssignmentListRelationFilter = {
    every?: BillAssignmentWhereInput
    some?: BillAssignmentWhereInput
    none?: BillAssignmentWhereInput
  }

  export type BillItemListRelationFilter = {
    every?: BillItemWhereInput
    some?: BillItemWhereInput
    none?: BillItemWhereInput
  }

  export type BillAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BillItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BillCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    schoolId?: SortOrder
    accountId?: SortOrder
  }

  export type BillAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BillMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    schoolId?: SortOrder
    accountId?: SortOrder
  }

  export type BillMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    schoolId?: SortOrder
    accountId?: SortOrder
  }

  export type BillSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BillScalarRelationFilter = {
    is?: BillWhereInput
    isNot?: BillWhereInput
  }

  export type BillItemCountOrderByAggregateInput = {
    id?: SortOrder
    billId?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillItemAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BillItemMaxOrderByAggregateInput = {
    id?: SortOrder
    billId?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillItemMinOrderByAggregateInput = {
    id?: SortOrder
    billId?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillItemSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentAccountCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    accountNo?: SortOrder
    bankName?: SortOrder
    branchCode?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    accountNo?: SortOrder
    bankName?: SortOrder
    branchCode?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAccountMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    accountNo?: SortOrder
    bankName?: SortOrder
    branchCode?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumBillAssignmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BillAssignmentType | EnumBillAssignmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BillAssignmentType[] | ListEnumBillAssignmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillAssignmentType[] | ListEnumBillAssignmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBillAssignmentTypeFilter<$PrismaModel> | $Enums.BillAssignmentType
  }

  export type EnumBillStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BillStatus | EnumBillStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BillStatus[] | ListEnumBillStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillStatus[] | ListEnumBillStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBillStatusFilter<$PrismaModel> | $Enums.BillStatus
  }

  export type BillAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    billId?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    billId?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    billId?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumBillAssignmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BillAssignmentType | EnumBillAssignmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BillAssignmentType[] | ListEnumBillAssignmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillAssignmentType[] | ListEnumBillAssignmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBillAssignmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.BillAssignmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBillAssignmentTypeFilter<$PrismaModel>
    _max?: NestedEnumBillAssignmentTypeFilter<$PrismaModel>
  }

  export type EnumBillStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BillStatus | EnumBillStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BillStatus[] | ListEnumBillStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillStatus[] | ListEnumBillStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBillStatusWithAggregatesFilter<$PrismaModel> | $Enums.BillStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBillStatusFilter<$PrismaModel>
    _max?: NestedEnumBillStatusFilter<$PrismaModel>
  }

  export type BillAssignmentScalarRelationFilter = {
    is?: BillAssignmentWhereInput
    isNot?: BillAssignmentWhereInput
  }

  export type StudentPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    billAssignmentId?: SortOrder
    studentId?: SortOrder
    amountPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentPaymentAvgOrderByAggregateInput = {
    amountPaid?: SortOrder
  }

  export type StudentPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    billAssignmentId?: SortOrder
    studentId?: SortOrder
    amountPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    billAssignmentId?: SortOrder
    studentId?: SortOrder
    amountPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentPaymentSumOrderByAggregateInput = {
    amountPaid?: SortOrder
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type StudentPaymentNullableScalarRelationFilter = {
    is?: StudentPaymentWhereInput | null
    isNot?: StudentPaymentWhereInput | null
  }

  export type PaymentRequestCountOrderByAggregateInput = {
    id?: SortOrder
    billId?: SortOrder
    billAssignmentId?: SortOrder
    studentPaymentId?: SortOrder
    studentId?: SortOrder
    amount?: SortOrder
    receiptUrl?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    processedById?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentRequestAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    billId?: SortOrder
    billAssignmentId?: SortOrder
    studentPaymentId?: SortOrder
    studentId?: SortOrder
    amount?: SortOrder
    receiptUrl?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    processedById?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentRequestMinOrderByAggregateInput = {
    id?: SortOrder
    billId?: SortOrder
    billAssignmentId?: SortOrder
    studentPaymentId?: SortOrder
    studentId?: SortOrder
    amount?: SortOrder
    receiptUrl?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    processedById?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentRequestSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type SchoolLevelSchoolIdNameCompoundUniqueInput = {
    schoolId: string
    name: string
  }

  export type SchoolLevelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolLevelAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type SchoolLevelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolLevelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolLevelSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type UserActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    page?: SortOrder
    action?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type UserActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    page?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
  }

  export type UserActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    page?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiRequestLogCountOrderByAggregateInput = {
    id?: SortOrder
    route?: SortOrder
    method?: SortOrder
    status?: SortOrder
    duration?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiRequestLogAvgOrderByAggregateInput = {
    status?: SortOrder
    duration?: SortOrder
  }

  export type ApiRequestLogMaxOrderByAggregateInput = {
    id?: SortOrder
    route?: SortOrder
    method?: SortOrder
    status?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiRequestLogMinOrderByAggregateInput = {
    id?: SortOrder
    route?: SortOrder
    method?: SortOrder
    status?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiRequestLogSumOrderByAggregateInput = {
    status?: SortOrder
    duration?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type ResultPeriodListRelationFilter = {
    every?: ResultPeriodWhereInput
    some?: ResultPeriodWhereInput
    none?: ResultPeriodWhereInput
  }

  export type AssessmentComponentListRelationFilter = {
    every?: AssessmentComponentWhereInput
    some?: AssessmentComponentWhereInput
    none?: AssessmentComponentWhereInput
  }

  export type GradingScaleListRelationFilter = {
    every?: GradingScaleWhereInput
    some?: GradingScaleWhereInput
    none?: GradingScaleWhereInput
  }

  export type ResultPeriodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssessmentComponentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GradingScaleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResultConfigurationSchoolIdSessionIdCompoundUniqueInput = {
    schoolId: string
    sessionId: string
  }

  export type ResultConfigurationCountOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    sessionId?: SortOrder
    cumulativeEnabled?: SortOrder
    cumulativeMethod?: SortOrder
    showCumulativePerTerm?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResultConfigurationMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    sessionId?: SortOrder
    cumulativeEnabled?: SortOrder
    cumulativeMethod?: SortOrder
    showCumulativePerTerm?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResultConfigurationMinOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    sessionId?: SortOrder
    cumulativeEnabled?: SortOrder
    cumulativeMethod?: SortOrder
    showCumulativePerTerm?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResultConfigurationScalarRelationFilter = {
    is?: ResultConfigurationWhereInput
    isNot?: ResultConfigurationWhereInput
  }

  export type ResultPeriodCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    weight?: SortOrder
    configurationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResultPeriodAvgOrderByAggregateInput = {
    weight?: SortOrder
  }

  export type ResultPeriodMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    weight?: SortOrder
    configurationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResultPeriodMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    weight?: SortOrder
    configurationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResultPeriodSumOrderByAggregateInput = {
    weight?: SortOrder
  }

  export type AssessmentComponentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
    maxScore?: SortOrder
    configurationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssessmentComponentAvgOrderByAggregateInput = {
    maxScore?: SortOrder
  }

  export type AssessmentComponentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
    maxScore?: SortOrder
    configurationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssessmentComponentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
    maxScore?: SortOrder
    configurationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssessmentComponentSumOrderByAggregateInput = {
    maxScore?: SortOrder
  }

  export type GradingScaleCountOrderByAggregateInput = {
    id?: SortOrder
    minScore?: SortOrder
    maxScore?: SortOrder
    grade?: SortOrder
    remark?: SortOrder
    configurationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GradingScaleAvgOrderByAggregateInput = {
    minScore?: SortOrder
    maxScore?: SortOrder
  }

  export type GradingScaleMaxOrderByAggregateInput = {
    id?: SortOrder
    minScore?: SortOrder
    maxScore?: SortOrder
    grade?: SortOrder
    remark?: SortOrder
    configurationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GradingScaleMinOrderByAggregateInput = {
    id?: SortOrder
    minScore?: SortOrder
    maxScore?: SortOrder
    grade?: SortOrder
    remark?: SortOrder
    configurationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GradingScaleSumOrderByAggregateInput = {
    minScore?: SortOrder
    maxScore?: SortOrder
  }

  export type AssessmentComponentScalarRelationFilter = {
    is?: AssessmentComponentWhereInput
    isNot?: AssessmentComponentWhereInput
  }

  export type ResultScalarRelationFilter = {
    is?: ResultWhereInput
    isNot?: ResultWhereInput
  }

  export type ComponentScoreCountOrderByAggregateInput = {
    id?: SortOrder
    score?: SortOrder
    componentId?: SortOrder
    resultId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComponentScoreAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type ComponentScoreMaxOrderByAggregateInput = {
    id?: SortOrder
    score?: SortOrder
    componentId?: SortOrder
    resultId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComponentScoreMinOrderByAggregateInput = {
    id?: SortOrder
    score?: SortOrder
    componentId?: SortOrder
    resultId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComponentScoreSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type AdminCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type ParentCreateNestedOneWithoutUserInput = {
    create?: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParentCreateOrConnectWithoutUserInput
    connect?: ParentWhereUniqueInput
  }

  export type PaymentRequestCreateNestedManyWithoutProcessedByInput = {
    create?: XOR<PaymentRequestCreateWithoutProcessedByInput, PaymentRequestUncheckedCreateWithoutProcessedByInput> | PaymentRequestCreateWithoutProcessedByInput[] | PaymentRequestUncheckedCreateWithoutProcessedByInput[]
    connectOrCreate?: PaymentRequestCreateOrConnectWithoutProcessedByInput | PaymentRequestCreateOrConnectWithoutProcessedByInput[]
    createMany?: PaymentRequestCreateManyProcessedByInputEnvelope
    connect?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
  }

  export type ResultCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<ResultCreateWithoutApprovedByInput, ResultUncheckedCreateWithoutApprovedByInput> | ResultCreateWithoutApprovedByInput[] | ResultUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: ResultCreateOrConnectWithoutApprovedByInput | ResultCreateOrConnectWithoutApprovedByInput[]
    createMany?: ResultCreateManyApprovedByInputEnvelope
    connect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type StudentCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    connect?: StudentWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutUserInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput
    connect?: TeacherWhereUniqueInput
  }

  export type SchoolCreateNestedOneWithoutUsersInput = {
    create?: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutUsersInput
    connect?: SchoolWhereUniqueInput
  }

  export type UserActivityLogCreateNestedManyWithoutUserInput = {
    create?: XOR<UserActivityLogCreateWithoutUserInput, UserActivityLogUncheckedCreateWithoutUserInput> | UserActivityLogCreateWithoutUserInput[] | UserActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserActivityLogCreateOrConnectWithoutUserInput | UserActivityLogCreateOrConnectWithoutUserInput[]
    createMany?: UserActivityLogCreateManyUserInputEnvelope
    connect?: UserActivityLogWhereUniqueInput | UserActivityLogWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type AdminUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type ParentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParentCreateOrConnectWithoutUserInput
    connect?: ParentWhereUniqueInput
  }

  export type PaymentRequestUncheckedCreateNestedManyWithoutProcessedByInput = {
    create?: XOR<PaymentRequestCreateWithoutProcessedByInput, PaymentRequestUncheckedCreateWithoutProcessedByInput> | PaymentRequestCreateWithoutProcessedByInput[] | PaymentRequestUncheckedCreateWithoutProcessedByInput[]
    connectOrCreate?: PaymentRequestCreateOrConnectWithoutProcessedByInput | PaymentRequestCreateOrConnectWithoutProcessedByInput[]
    createMany?: PaymentRequestCreateManyProcessedByInputEnvelope
    connect?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
  }

  export type ResultUncheckedCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<ResultCreateWithoutApprovedByInput, ResultUncheckedCreateWithoutApprovedByInput> | ResultCreateWithoutApprovedByInput[] | ResultUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: ResultCreateOrConnectWithoutApprovedByInput | ResultCreateOrConnectWithoutApprovedByInput[]
    createMany?: ResultCreateManyApprovedByInputEnvelope
    connect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    connect?: StudentWhereUniqueInput
  }

  export type TeacherUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput
    connect?: TeacherWhereUniqueInput
  }

  export type UserActivityLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserActivityLogCreateWithoutUserInput, UserActivityLogUncheckedCreateWithoutUserInput> | UserActivityLogCreateWithoutUserInput[] | UserActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserActivityLogCreateOrConnectWithoutUserInput | UserActivityLogCreateOrConnectWithoutUserInput[]
    createMany?: UserActivityLogCreateManyUserInputEnvelope
    connect?: UserActivityLogWhereUniqueInput | UserActivityLogWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type AdminUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type ParentUpdateOneWithoutUserNestedInput = {
    create?: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParentCreateOrConnectWithoutUserInput
    upsert?: ParentUpsertWithoutUserInput
    disconnect?: ParentWhereInput | boolean
    delete?: ParentWhereInput | boolean
    connect?: ParentWhereUniqueInput
    update?: XOR<XOR<ParentUpdateToOneWithWhereWithoutUserInput, ParentUpdateWithoutUserInput>, ParentUncheckedUpdateWithoutUserInput>
  }

  export type PaymentRequestUpdateManyWithoutProcessedByNestedInput = {
    create?: XOR<PaymentRequestCreateWithoutProcessedByInput, PaymentRequestUncheckedCreateWithoutProcessedByInput> | PaymentRequestCreateWithoutProcessedByInput[] | PaymentRequestUncheckedCreateWithoutProcessedByInput[]
    connectOrCreate?: PaymentRequestCreateOrConnectWithoutProcessedByInput | PaymentRequestCreateOrConnectWithoutProcessedByInput[]
    upsert?: PaymentRequestUpsertWithWhereUniqueWithoutProcessedByInput | PaymentRequestUpsertWithWhereUniqueWithoutProcessedByInput[]
    createMany?: PaymentRequestCreateManyProcessedByInputEnvelope
    set?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    disconnect?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    delete?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    connect?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    update?: PaymentRequestUpdateWithWhereUniqueWithoutProcessedByInput | PaymentRequestUpdateWithWhereUniqueWithoutProcessedByInput[]
    updateMany?: PaymentRequestUpdateManyWithWhereWithoutProcessedByInput | PaymentRequestUpdateManyWithWhereWithoutProcessedByInput[]
    deleteMany?: PaymentRequestScalarWhereInput | PaymentRequestScalarWhereInput[]
  }

  export type ResultUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<ResultCreateWithoutApprovedByInput, ResultUncheckedCreateWithoutApprovedByInput> | ResultCreateWithoutApprovedByInput[] | ResultUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: ResultCreateOrConnectWithoutApprovedByInput | ResultCreateOrConnectWithoutApprovedByInput[]
    upsert?: ResultUpsertWithWhereUniqueWithoutApprovedByInput | ResultUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: ResultCreateManyApprovedByInputEnvelope
    set?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    disconnect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    delete?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    connect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    update?: ResultUpdateWithWhereUniqueWithoutApprovedByInput | ResultUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: ResultUpdateManyWithWhereWithoutApprovedByInput | ResultUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: ResultScalarWhereInput | ResultScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type StudentUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    upsert?: StudentUpsertWithoutUserInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutUserInput, StudentUpdateWithoutUserInput>, StudentUncheckedUpdateWithoutUserInput>
  }

  export type TeacherUpdateOneWithoutUserNestedInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput
    upsert?: TeacherUpsertWithoutUserInput
    disconnect?: TeacherWhereInput | boolean
    delete?: TeacherWhereInput | boolean
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutUserInput, TeacherUpdateWithoutUserInput>, TeacherUncheckedUpdateWithoutUserInput>
  }

  export type SchoolUpdateOneWithoutUsersNestedInput = {
    create?: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutUsersInput
    upsert?: SchoolUpsertWithoutUsersInput
    disconnect?: SchoolWhereInput | boolean
    delete?: SchoolWhereInput | boolean
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutUsersInput, SchoolUpdateWithoutUsersInput>, SchoolUncheckedUpdateWithoutUsersInput>
  }

  export type UserActivityLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserActivityLogCreateWithoutUserInput, UserActivityLogUncheckedCreateWithoutUserInput> | UserActivityLogCreateWithoutUserInput[] | UserActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserActivityLogCreateOrConnectWithoutUserInput | UserActivityLogCreateOrConnectWithoutUserInput[]
    upsert?: UserActivityLogUpsertWithWhereUniqueWithoutUserInput | UserActivityLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserActivityLogCreateManyUserInputEnvelope
    set?: UserActivityLogWhereUniqueInput | UserActivityLogWhereUniqueInput[]
    disconnect?: UserActivityLogWhereUniqueInput | UserActivityLogWhereUniqueInput[]
    delete?: UserActivityLogWhereUniqueInput | UserActivityLogWhereUniqueInput[]
    connect?: UserActivityLogWhereUniqueInput | UserActivityLogWhereUniqueInput[]
    update?: UserActivityLogUpdateWithWhereUniqueWithoutUserInput | UserActivityLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserActivityLogUpdateManyWithWhereWithoutUserInput | UserActivityLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserActivityLogScalarWhereInput | UserActivityLogScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type AdminUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type ParentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParentCreateOrConnectWithoutUserInput
    upsert?: ParentUpsertWithoutUserInput
    disconnect?: ParentWhereInput | boolean
    delete?: ParentWhereInput | boolean
    connect?: ParentWhereUniqueInput
    update?: XOR<XOR<ParentUpdateToOneWithWhereWithoutUserInput, ParentUpdateWithoutUserInput>, ParentUncheckedUpdateWithoutUserInput>
  }

  export type PaymentRequestUncheckedUpdateManyWithoutProcessedByNestedInput = {
    create?: XOR<PaymentRequestCreateWithoutProcessedByInput, PaymentRequestUncheckedCreateWithoutProcessedByInput> | PaymentRequestCreateWithoutProcessedByInput[] | PaymentRequestUncheckedCreateWithoutProcessedByInput[]
    connectOrCreate?: PaymentRequestCreateOrConnectWithoutProcessedByInput | PaymentRequestCreateOrConnectWithoutProcessedByInput[]
    upsert?: PaymentRequestUpsertWithWhereUniqueWithoutProcessedByInput | PaymentRequestUpsertWithWhereUniqueWithoutProcessedByInput[]
    createMany?: PaymentRequestCreateManyProcessedByInputEnvelope
    set?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    disconnect?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    delete?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    connect?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    update?: PaymentRequestUpdateWithWhereUniqueWithoutProcessedByInput | PaymentRequestUpdateWithWhereUniqueWithoutProcessedByInput[]
    updateMany?: PaymentRequestUpdateManyWithWhereWithoutProcessedByInput | PaymentRequestUpdateManyWithWhereWithoutProcessedByInput[]
    deleteMany?: PaymentRequestScalarWhereInput | PaymentRequestScalarWhereInput[]
  }

  export type ResultUncheckedUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<ResultCreateWithoutApprovedByInput, ResultUncheckedCreateWithoutApprovedByInput> | ResultCreateWithoutApprovedByInput[] | ResultUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: ResultCreateOrConnectWithoutApprovedByInput | ResultCreateOrConnectWithoutApprovedByInput[]
    upsert?: ResultUpsertWithWhereUniqueWithoutApprovedByInput | ResultUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: ResultCreateManyApprovedByInputEnvelope
    set?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    disconnect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    delete?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    connect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    update?: ResultUpdateWithWhereUniqueWithoutApprovedByInput | ResultUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: ResultUpdateManyWithWhereWithoutApprovedByInput | ResultUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: ResultScalarWhereInput | ResultScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type StudentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    upsert?: StudentUpsertWithoutUserInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutUserInput, StudentUpdateWithoutUserInput>, StudentUncheckedUpdateWithoutUserInput>
  }

  export type TeacherUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput
    upsert?: TeacherUpsertWithoutUserInput
    disconnect?: TeacherWhereInput | boolean
    delete?: TeacherWhereInput | boolean
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutUserInput, TeacherUpdateWithoutUserInput>, TeacherUncheckedUpdateWithoutUserInput>
  }

  export type UserActivityLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserActivityLogCreateWithoutUserInput, UserActivityLogUncheckedCreateWithoutUserInput> | UserActivityLogCreateWithoutUserInput[] | UserActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserActivityLogCreateOrConnectWithoutUserInput | UserActivityLogCreateOrConnectWithoutUserInput[]
    upsert?: UserActivityLogUpsertWithWhereUniqueWithoutUserInput | UserActivityLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserActivityLogCreateManyUserInputEnvelope
    set?: UserActivityLogWhereUniqueInput | UserActivityLogWhereUniqueInput[]
    disconnect?: UserActivityLogWhereUniqueInput | UserActivityLogWhereUniqueInput[]
    delete?: UserActivityLogWhereUniqueInput | UserActivityLogWhereUniqueInput[]
    connect?: UserActivityLogWhereUniqueInput | UserActivityLogWhereUniqueInput[]
    update?: UserActivityLogUpdateWithWhereUniqueWithoutUserInput | UserActivityLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserActivityLogUpdateManyWithWhereWithoutUserInput | UserActivityLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserActivityLogScalarWhereInput | UserActivityLogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAdminInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAdminTypeFieldUpdateOperationsInput = {
    set?: $Enums.AdminType
  }

  export type UserUpdateOneRequiredWithoutAdminNestedInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    upsert?: UserUpsertWithoutAdminInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminInput, UserUpdateWithoutAdminInput>, UserUncheckedUpdateWithoutAdminInput>
  }

  export type ClassCreateNestedManyWithoutTeacherInput = {
    create?: XOR<ClassCreateWithoutTeacherInput, ClassUncheckedCreateWithoutTeacherInput> | ClassCreateWithoutTeacherInput[] | ClassUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutTeacherInput | ClassCreateOrConnectWithoutTeacherInput[]
    createMany?: ClassCreateManyTeacherInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type SubjectTeacherCreateNestedManyWithoutTeacherInput = {
    create?: XOR<SubjectTeacherCreateWithoutTeacherInput, SubjectTeacherUncheckedCreateWithoutTeacherInput> | SubjectTeacherCreateWithoutTeacherInput[] | SubjectTeacherUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: SubjectTeacherCreateOrConnectWithoutTeacherInput | SubjectTeacherCreateOrConnectWithoutTeacherInput[]
    createMany?: SubjectTeacherCreateManyTeacherInputEnvelope
    connect?: SubjectTeacherWhereUniqueInput | SubjectTeacherWhereUniqueInput[]
  }

  export type DepartmentCreateNestedOneWithoutTeachersInput = {
    create?: XOR<DepartmentCreateWithoutTeachersInput, DepartmentUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutTeachersInput
    connect?: DepartmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTeacherInput = {
    create?: XOR<UserCreateWithoutTeacherInput, UserUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeacherInput
    connect?: UserWhereUniqueInput
  }

  export type ClassUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<ClassCreateWithoutTeacherInput, ClassUncheckedCreateWithoutTeacherInput> | ClassCreateWithoutTeacherInput[] | ClassUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutTeacherInput | ClassCreateOrConnectWithoutTeacherInput[]
    createMany?: ClassCreateManyTeacherInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type SubjectTeacherUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<SubjectTeacherCreateWithoutTeacherInput, SubjectTeacherUncheckedCreateWithoutTeacherInput> | SubjectTeacherCreateWithoutTeacherInput[] | SubjectTeacherUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: SubjectTeacherCreateOrConnectWithoutTeacherInput | SubjectTeacherCreateOrConnectWithoutTeacherInput[]
    createMany?: SubjectTeacherCreateManyTeacherInputEnvelope
    connect?: SubjectTeacherWhereUniqueInput | SubjectTeacherWhereUniqueInput[]
  }

  export type ClassUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<ClassCreateWithoutTeacherInput, ClassUncheckedCreateWithoutTeacherInput> | ClassCreateWithoutTeacherInput[] | ClassUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutTeacherInput | ClassCreateOrConnectWithoutTeacherInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutTeacherInput | ClassUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: ClassCreateManyTeacherInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutTeacherInput | ClassUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutTeacherInput | ClassUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type SubjectTeacherUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<SubjectTeacherCreateWithoutTeacherInput, SubjectTeacherUncheckedCreateWithoutTeacherInput> | SubjectTeacherCreateWithoutTeacherInput[] | SubjectTeacherUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: SubjectTeacherCreateOrConnectWithoutTeacherInput | SubjectTeacherCreateOrConnectWithoutTeacherInput[]
    upsert?: SubjectTeacherUpsertWithWhereUniqueWithoutTeacherInput | SubjectTeacherUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: SubjectTeacherCreateManyTeacherInputEnvelope
    set?: SubjectTeacherWhereUniqueInput | SubjectTeacherWhereUniqueInput[]
    disconnect?: SubjectTeacherWhereUniqueInput | SubjectTeacherWhereUniqueInput[]
    delete?: SubjectTeacherWhereUniqueInput | SubjectTeacherWhereUniqueInput[]
    connect?: SubjectTeacherWhereUniqueInput | SubjectTeacherWhereUniqueInput[]
    update?: SubjectTeacherUpdateWithWhereUniqueWithoutTeacherInput | SubjectTeacherUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: SubjectTeacherUpdateManyWithWhereWithoutTeacherInput | SubjectTeacherUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: SubjectTeacherScalarWhereInput | SubjectTeacherScalarWhereInput[]
  }

  export type DepartmentUpdateOneWithoutTeachersNestedInput = {
    create?: XOR<DepartmentCreateWithoutTeachersInput, DepartmentUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutTeachersInput
    upsert?: DepartmentUpsertWithoutTeachersInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutTeachersInput, DepartmentUpdateWithoutTeachersInput>, DepartmentUncheckedUpdateWithoutTeachersInput>
  }

  export type UserUpdateOneRequiredWithoutTeacherNestedInput = {
    create?: XOR<UserCreateWithoutTeacherInput, UserUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeacherInput
    upsert?: UserUpsertWithoutTeacherInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeacherInput, UserUpdateWithoutTeacherInput>, UserUncheckedUpdateWithoutTeacherInput>
  }

  export type ClassUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<ClassCreateWithoutTeacherInput, ClassUncheckedCreateWithoutTeacherInput> | ClassCreateWithoutTeacherInput[] | ClassUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutTeacherInput | ClassCreateOrConnectWithoutTeacherInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutTeacherInput | ClassUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: ClassCreateManyTeacherInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutTeacherInput | ClassUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutTeacherInput | ClassUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type SubjectTeacherUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<SubjectTeacherCreateWithoutTeacherInput, SubjectTeacherUncheckedCreateWithoutTeacherInput> | SubjectTeacherCreateWithoutTeacherInput[] | SubjectTeacherUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: SubjectTeacherCreateOrConnectWithoutTeacherInput | SubjectTeacherCreateOrConnectWithoutTeacherInput[]
    upsert?: SubjectTeacherUpsertWithWhereUniqueWithoutTeacherInput | SubjectTeacherUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: SubjectTeacherCreateManyTeacherInputEnvelope
    set?: SubjectTeacherWhereUniqueInput | SubjectTeacherWhereUniqueInput[]
    disconnect?: SubjectTeacherWhereUniqueInput | SubjectTeacherWhereUniqueInput[]
    delete?: SubjectTeacherWhereUniqueInput | SubjectTeacherWhereUniqueInput[]
    connect?: SubjectTeacherWhereUniqueInput | SubjectTeacherWhereUniqueInput[]
    update?: SubjectTeacherUpdateWithWhereUniqueWithoutTeacherInput | SubjectTeacherUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: SubjectTeacherUpdateManyWithWhereWithoutTeacherInput | SubjectTeacherUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: SubjectTeacherScalarWhereInput | SubjectTeacherScalarWhereInput[]
  }

  export type AttendanceCreateNestedManyWithoutStudentInput = {
    create?: XOR<AttendanceCreateWithoutStudentInput, AttendanceUncheckedCreateWithoutStudentInput> | AttendanceCreateWithoutStudentInput[] | AttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutStudentInput | AttendanceCreateOrConnectWithoutStudentInput[]
    createMany?: AttendanceCreateManyStudentInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type PaymentRequestCreateNestedManyWithoutStudentInput = {
    create?: XOR<PaymentRequestCreateWithoutStudentInput, PaymentRequestUncheckedCreateWithoutStudentInput> | PaymentRequestCreateWithoutStudentInput[] | PaymentRequestUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: PaymentRequestCreateOrConnectWithoutStudentInput | PaymentRequestCreateOrConnectWithoutStudentInput[]
    createMany?: PaymentRequestCreateManyStudentInputEnvelope
    connect?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
  }

  export type ResultCreateNestedManyWithoutStudentInput = {
    create?: XOR<ResultCreateWithoutStudentInput, ResultUncheckedCreateWithoutStudentInput> | ResultCreateWithoutStudentInput[] | ResultUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ResultCreateOrConnectWithoutStudentInput | ResultCreateOrConnectWithoutStudentInput[]
    createMany?: ResultCreateManyStudentInputEnvelope
    connect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
  }

  export type DepartmentCreateNestedOneWithoutStudentsInput = {
    create?: XOR<DepartmentCreateWithoutStudentsInput, DepartmentUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutStudentsInput
    connect?: DepartmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStudentInput = {
    create?: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentInput
    connect?: UserWhereUniqueInput
  }

  export type StudentClassCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentClassCreateWithoutStudentInput, StudentClassUncheckedCreateWithoutStudentInput> | StudentClassCreateWithoutStudentInput[] | StudentClassUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentClassCreateOrConnectWithoutStudentInput | StudentClassCreateOrConnectWithoutStudentInput[]
    createMany?: StudentClassCreateManyStudentInputEnvelope
    connect?: StudentClassWhereUniqueInput | StudentClassWhereUniqueInput[]
  }

  export type StudentParentCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentParentCreateWithoutStudentInput, StudentParentUncheckedCreateWithoutStudentInput> | StudentParentCreateWithoutStudentInput[] | StudentParentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentParentCreateOrConnectWithoutStudentInput | StudentParentCreateOrConnectWithoutStudentInput[]
    createMany?: StudentParentCreateManyStudentInputEnvelope
    connect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
  }

  export type StudentPaymentCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentPaymentCreateWithoutStudentInput, StudentPaymentUncheckedCreateWithoutStudentInput> | StudentPaymentCreateWithoutStudentInput[] | StudentPaymentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentPaymentCreateOrConnectWithoutStudentInput | StudentPaymentCreateOrConnectWithoutStudentInput[]
    createMany?: StudentPaymentCreateManyStudentInputEnvelope
    connect?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
  }

  export type StudentSubjectCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentSubjectCreateWithoutStudentInput, StudentSubjectUncheckedCreateWithoutStudentInput> | StudentSubjectCreateWithoutStudentInput[] | StudentSubjectUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSubjectCreateOrConnectWithoutStudentInput | StudentSubjectCreateOrConnectWithoutStudentInput[]
    createMany?: StudentSubjectCreateManyStudentInputEnvelope
    connect?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<AttendanceCreateWithoutStudentInput, AttendanceUncheckedCreateWithoutStudentInput> | AttendanceCreateWithoutStudentInput[] | AttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutStudentInput | AttendanceCreateOrConnectWithoutStudentInput[]
    createMany?: AttendanceCreateManyStudentInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type PaymentRequestUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<PaymentRequestCreateWithoutStudentInput, PaymentRequestUncheckedCreateWithoutStudentInput> | PaymentRequestCreateWithoutStudentInput[] | PaymentRequestUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: PaymentRequestCreateOrConnectWithoutStudentInput | PaymentRequestCreateOrConnectWithoutStudentInput[]
    createMany?: PaymentRequestCreateManyStudentInputEnvelope
    connect?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
  }

  export type ResultUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<ResultCreateWithoutStudentInput, ResultUncheckedCreateWithoutStudentInput> | ResultCreateWithoutStudentInput[] | ResultUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ResultCreateOrConnectWithoutStudentInput | ResultCreateOrConnectWithoutStudentInput[]
    createMany?: ResultCreateManyStudentInputEnvelope
    connect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
  }

  export type StudentClassUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentClassCreateWithoutStudentInput, StudentClassUncheckedCreateWithoutStudentInput> | StudentClassCreateWithoutStudentInput[] | StudentClassUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentClassCreateOrConnectWithoutStudentInput | StudentClassCreateOrConnectWithoutStudentInput[]
    createMany?: StudentClassCreateManyStudentInputEnvelope
    connect?: StudentClassWhereUniqueInput | StudentClassWhereUniqueInput[]
  }

  export type StudentParentUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentParentCreateWithoutStudentInput, StudentParentUncheckedCreateWithoutStudentInput> | StudentParentCreateWithoutStudentInput[] | StudentParentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentParentCreateOrConnectWithoutStudentInput | StudentParentCreateOrConnectWithoutStudentInput[]
    createMany?: StudentParentCreateManyStudentInputEnvelope
    connect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
  }

  export type StudentPaymentUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentPaymentCreateWithoutStudentInput, StudentPaymentUncheckedCreateWithoutStudentInput> | StudentPaymentCreateWithoutStudentInput[] | StudentPaymentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentPaymentCreateOrConnectWithoutStudentInput | StudentPaymentCreateOrConnectWithoutStudentInput[]
    createMany?: StudentPaymentCreateManyStudentInputEnvelope
    connect?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
  }

  export type StudentSubjectUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentSubjectCreateWithoutStudentInput, StudentSubjectUncheckedCreateWithoutStudentInput> | StudentSubjectCreateWithoutStudentInput[] | StudentSubjectUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSubjectCreateOrConnectWithoutStudentInput | StudentSubjectCreateOrConnectWithoutStudentInput[]
    createMany?: StudentSubjectCreateManyStudentInputEnvelope
    connect?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
  }

  export type AttendanceUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AttendanceCreateWithoutStudentInput, AttendanceUncheckedCreateWithoutStudentInput> | AttendanceCreateWithoutStudentInput[] | AttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutStudentInput | AttendanceCreateOrConnectWithoutStudentInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutStudentInput | AttendanceUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AttendanceCreateManyStudentInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutStudentInput | AttendanceUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutStudentInput | AttendanceUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type PaymentRequestUpdateManyWithoutStudentNestedInput = {
    create?: XOR<PaymentRequestCreateWithoutStudentInput, PaymentRequestUncheckedCreateWithoutStudentInput> | PaymentRequestCreateWithoutStudentInput[] | PaymentRequestUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: PaymentRequestCreateOrConnectWithoutStudentInput | PaymentRequestCreateOrConnectWithoutStudentInput[]
    upsert?: PaymentRequestUpsertWithWhereUniqueWithoutStudentInput | PaymentRequestUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: PaymentRequestCreateManyStudentInputEnvelope
    set?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    disconnect?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    delete?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    connect?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    update?: PaymentRequestUpdateWithWhereUniqueWithoutStudentInput | PaymentRequestUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: PaymentRequestUpdateManyWithWhereWithoutStudentInput | PaymentRequestUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: PaymentRequestScalarWhereInput | PaymentRequestScalarWhereInput[]
  }

  export type ResultUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ResultCreateWithoutStudentInput, ResultUncheckedCreateWithoutStudentInput> | ResultCreateWithoutStudentInput[] | ResultUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ResultCreateOrConnectWithoutStudentInput | ResultCreateOrConnectWithoutStudentInput[]
    upsert?: ResultUpsertWithWhereUniqueWithoutStudentInput | ResultUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ResultCreateManyStudentInputEnvelope
    set?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    disconnect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    delete?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    connect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    update?: ResultUpdateWithWhereUniqueWithoutStudentInput | ResultUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ResultUpdateManyWithWhereWithoutStudentInput | ResultUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ResultScalarWhereInput | ResultScalarWhereInput[]
  }

  export type DepartmentUpdateOneWithoutStudentsNestedInput = {
    create?: XOR<DepartmentCreateWithoutStudentsInput, DepartmentUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutStudentsInput
    upsert?: DepartmentUpsertWithoutStudentsInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutStudentsInput, DepartmentUpdateWithoutStudentsInput>, DepartmentUncheckedUpdateWithoutStudentsInput>
  }

  export type UserUpdateOneRequiredWithoutStudentNestedInput = {
    create?: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentInput
    upsert?: UserUpsertWithoutStudentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStudentInput, UserUpdateWithoutStudentInput>, UserUncheckedUpdateWithoutStudentInput>
  }

  export type StudentClassUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentClassCreateWithoutStudentInput, StudentClassUncheckedCreateWithoutStudentInput> | StudentClassCreateWithoutStudentInput[] | StudentClassUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentClassCreateOrConnectWithoutStudentInput | StudentClassCreateOrConnectWithoutStudentInput[]
    upsert?: StudentClassUpsertWithWhereUniqueWithoutStudentInput | StudentClassUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentClassCreateManyStudentInputEnvelope
    set?: StudentClassWhereUniqueInput | StudentClassWhereUniqueInput[]
    disconnect?: StudentClassWhereUniqueInput | StudentClassWhereUniqueInput[]
    delete?: StudentClassWhereUniqueInput | StudentClassWhereUniqueInput[]
    connect?: StudentClassWhereUniqueInput | StudentClassWhereUniqueInput[]
    update?: StudentClassUpdateWithWhereUniqueWithoutStudentInput | StudentClassUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentClassUpdateManyWithWhereWithoutStudentInput | StudentClassUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentClassScalarWhereInput | StudentClassScalarWhereInput[]
  }

  export type StudentParentUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentParentCreateWithoutStudentInput, StudentParentUncheckedCreateWithoutStudentInput> | StudentParentCreateWithoutStudentInput[] | StudentParentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentParentCreateOrConnectWithoutStudentInput | StudentParentCreateOrConnectWithoutStudentInput[]
    upsert?: StudentParentUpsertWithWhereUniqueWithoutStudentInput | StudentParentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentParentCreateManyStudentInputEnvelope
    set?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    disconnect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    delete?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    connect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    update?: StudentParentUpdateWithWhereUniqueWithoutStudentInput | StudentParentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentParentUpdateManyWithWhereWithoutStudentInput | StudentParentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentParentScalarWhereInput | StudentParentScalarWhereInput[]
  }

  export type StudentPaymentUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentPaymentCreateWithoutStudentInput, StudentPaymentUncheckedCreateWithoutStudentInput> | StudentPaymentCreateWithoutStudentInput[] | StudentPaymentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentPaymentCreateOrConnectWithoutStudentInput | StudentPaymentCreateOrConnectWithoutStudentInput[]
    upsert?: StudentPaymentUpsertWithWhereUniqueWithoutStudentInput | StudentPaymentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentPaymentCreateManyStudentInputEnvelope
    set?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    disconnect?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    delete?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    connect?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    update?: StudentPaymentUpdateWithWhereUniqueWithoutStudentInput | StudentPaymentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentPaymentUpdateManyWithWhereWithoutStudentInput | StudentPaymentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentPaymentScalarWhereInput | StudentPaymentScalarWhereInput[]
  }

  export type StudentSubjectUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentSubjectCreateWithoutStudentInput, StudentSubjectUncheckedCreateWithoutStudentInput> | StudentSubjectCreateWithoutStudentInput[] | StudentSubjectUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSubjectCreateOrConnectWithoutStudentInput | StudentSubjectCreateOrConnectWithoutStudentInput[]
    upsert?: StudentSubjectUpsertWithWhereUniqueWithoutStudentInput | StudentSubjectUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentSubjectCreateManyStudentInputEnvelope
    set?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    disconnect?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    delete?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    connect?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    update?: StudentSubjectUpdateWithWhereUniqueWithoutStudentInput | StudentSubjectUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentSubjectUpdateManyWithWhereWithoutStudentInput | StudentSubjectUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentSubjectScalarWhereInput | StudentSubjectScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AttendanceCreateWithoutStudentInput, AttendanceUncheckedCreateWithoutStudentInput> | AttendanceCreateWithoutStudentInput[] | AttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutStudentInput | AttendanceCreateOrConnectWithoutStudentInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutStudentInput | AttendanceUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AttendanceCreateManyStudentInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutStudentInput | AttendanceUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutStudentInput | AttendanceUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type PaymentRequestUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<PaymentRequestCreateWithoutStudentInput, PaymentRequestUncheckedCreateWithoutStudentInput> | PaymentRequestCreateWithoutStudentInput[] | PaymentRequestUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: PaymentRequestCreateOrConnectWithoutStudentInput | PaymentRequestCreateOrConnectWithoutStudentInput[]
    upsert?: PaymentRequestUpsertWithWhereUniqueWithoutStudentInput | PaymentRequestUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: PaymentRequestCreateManyStudentInputEnvelope
    set?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    disconnect?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    delete?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    connect?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    update?: PaymentRequestUpdateWithWhereUniqueWithoutStudentInput | PaymentRequestUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: PaymentRequestUpdateManyWithWhereWithoutStudentInput | PaymentRequestUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: PaymentRequestScalarWhereInput | PaymentRequestScalarWhereInput[]
  }

  export type ResultUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ResultCreateWithoutStudentInput, ResultUncheckedCreateWithoutStudentInput> | ResultCreateWithoutStudentInput[] | ResultUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ResultCreateOrConnectWithoutStudentInput | ResultCreateOrConnectWithoutStudentInput[]
    upsert?: ResultUpsertWithWhereUniqueWithoutStudentInput | ResultUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ResultCreateManyStudentInputEnvelope
    set?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    disconnect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    delete?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    connect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    update?: ResultUpdateWithWhereUniqueWithoutStudentInput | ResultUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ResultUpdateManyWithWhereWithoutStudentInput | ResultUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ResultScalarWhereInput | ResultScalarWhereInput[]
  }

  export type StudentClassUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentClassCreateWithoutStudentInput, StudentClassUncheckedCreateWithoutStudentInput> | StudentClassCreateWithoutStudentInput[] | StudentClassUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentClassCreateOrConnectWithoutStudentInput | StudentClassCreateOrConnectWithoutStudentInput[]
    upsert?: StudentClassUpsertWithWhereUniqueWithoutStudentInput | StudentClassUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentClassCreateManyStudentInputEnvelope
    set?: StudentClassWhereUniqueInput | StudentClassWhereUniqueInput[]
    disconnect?: StudentClassWhereUniqueInput | StudentClassWhereUniqueInput[]
    delete?: StudentClassWhereUniqueInput | StudentClassWhereUniqueInput[]
    connect?: StudentClassWhereUniqueInput | StudentClassWhereUniqueInput[]
    update?: StudentClassUpdateWithWhereUniqueWithoutStudentInput | StudentClassUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentClassUpdateManyWithWhereWithoutStudentInput | StudentClassUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentClassScalarWhereInput | StudentClassScalarWhereInput[]
  }

  export type StudentParentUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentParentCreateWithoutStudentInput, StudentParentUncheckedCreateWithoutStudentInput> | StudentParentCreateWithoutStudentInput[] | StudentParentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentParentCreateOrConnectWithoutStudentInput | StudentParentCreateOrConnectWithoutStudentInput[]
    upsert?: StudentParentUpsertWithWhereUniqueWithoutStudentInput | StudentParentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentParentCreateManyStudentInputEnvelope
    set?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    disconnect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    delete?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    connect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    update?: StudentParentUpdateWithWhereUniqueWithoutStudentInput | StudentParentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentParentUpdateManyWithWhereWithoutStudentInput | StudentParentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentParentScalarWhereInput | StudentParentScalarWhereInput[]
  }

  export type StudentPaymentUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentPaymentCreateWithoutStudentInput, StudentPaymentUncheckedCreateWithoutStudentInput> | StudentPaymentCreateWithoutStudentInput[] | StudentPaymentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentPaymentCreateOrConnectWithoutStudentInput | StudentPaymentCreateOrConnectWithoutStudentInput[]
    upsert?: StudentPaymentUpsertWithWhereUniqueWithoutStudentInput | StudentPaymentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentPaymentCreateManyStudentInputEnvelope
    set?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    disconnect?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    delete?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    connect?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    update?: StudentPaymentUpdateWithWhereUniqueWithoutStudentInput | StudentPaymentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentPaymentUpdateManyWithWhereWithoutStudentInput | StudentPaymentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentPaymentScalarWhereInput | StudentPaymentScalarWhereInput[]
  }

  export type StudentSubjectUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentSubjectCreateWithoutStudentInput, StudentSubjectUncheckedCreateWithoutStudentInput> | StudentSubjectCreateWithoutStudentInput[] | StudentSubjectUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSubjectCreateOrConnectWithoutStudentInput | StudentSubjectCreateOrConnectWithoutStudentInput[]
    upsert?: StudentSubjectUpsertWithWhereUniqueWithoutStudentInput | StudentSubjectUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentSubjectCreateManyStudentInputEnvelope
    set?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    disconnect?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    delete?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    connect?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    update?: StudentSubjectUpdateWithWhereUniqueWithoutStudentInput | StudentSubjectUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentSubjectUpdateManyWithWhereWithoutStudentInput | StudentSubjectUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentSubjectScalarWhereInput | StudentSubjectScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutParentInput = {
    create?: XOR<UserCreateWithoutParentInput, UserUncheckedCreateWithoutParentInput>
    connectOrCreate?: UserCreateOrConnectWithoutParentInput
    connect?: UserWhereUniqueInput
  }

  export type StudentParentCreateNestedManyWithoutParentInput = {
    create?: XOR<StudentParentCreateWithoutParentInput, StudentParentUncheckedCreateWithoutParentInput> | StudentParentCreateWithoutParentInput[] | StudentParentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: StudentParentCreateOrConnectWithoutParentInput | StudentParentCreateOrConnectWithoutParentInput[]
    createMany?: StudentParentCreateManyParentInputEnvelope
    connect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
  }

  export type StudentParentUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<StudentParentCreateWithoutParentInput, StudentParentUncheckedCreateWithoutParentInput> | StudentParentCreateWithoutParentInput[] | StudentParentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: StudentParentCreateOrConnectWithoutParentInput | StudentParentCreateOrConnectWithoutParentInput[]
    createMany?: StudentParentCreateManyParentInputEnvelope
    connect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutParentNestedInput = {
    create?: XOR<UserCreateWithoutParentInput, UserUncheckedCreateWithoutParentInput>
    connectOrCreate?: UserCreateOrConnectWithoutParentInput
    upsert?: UserUpsertWithoutParentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutParentInput, UserUpdateWithoutParentInput>, UserUncheckedUpdateWithoutParentInput>
  }

  export type StudentParentUpdateManyWithoutParentNestedInput = {
    create?: XOR<StudentParentCreateWithoutParentInput, StudentParentUncheckedCreateWithoutParentInput> | StudentParentCreateWithoutParentInput[] | StudentParentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: StudentParentCreateOrConnectWithoutParentInput | StudentParentCreateOrConnectWithoutParentInput[]
    upsert?: StudentParentUpsertWithWhereUniqueWithoutParentInput | StudentParentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: StudentParentCreateManyParentInputEnvelope
    set?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    disconnect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    delete?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    connect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    update?: StudentParentUpdateWithWhereUniqueWithoutParentInput | StudentParentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: StudentParentUpdateManyWithWhereWithoutParentInput | StudentParentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: StudentParentScalarWhereInput | StudentParentScalarWhereInput[]
  }

  export type StudentParentUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<StudentParentCreateWithoutParentInput, StudentParentUncheckedCreateWithoutParentInput> | StudentParentCreateWithoutParentInput[] | StudentParentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: StudentParentCreateOrConnectWithoutParentInput | StudentParentCreateOrConnectWithoutParentInput[]
    upsert?: StudentParentUpsertWithWhereUniqueWithoutParentInput | StudentParentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: StudentParentCreateManyParentInputEnvelope
    set?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    disconnect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    delete?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    connect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    update?: StudentParentUpdateWithWhereUniqueWithoutParentInput | StudentParentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: StudentParentUpdateManyWithWhereWithoutParentInput | StudentParentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: StudentParentScalarWhereInput | StudentParentScalarWhereInput[]
  }

  export type AcademicSessionCreateNestedManyWithoutSchoolInput = {
    create?: XOR<AcademicSessionCreateWithoutSchoolInput, AcademicSessionUncheckedCreateWithoutSchoolInput> | AcademicSessionCreateWithoutSchoolInput[] | AcademicSessionUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: AcademicSessionCreateOrConnectWithoutSchoolInput | AcademicSessionCreateOrConnectWithoutSchoolInput[]
    createMany?: AcademicSessionCreateManySchoolInputEnvelope
    connect?: AcademicSessionWhereUniqueInput | AcademicSessionWhereUniqueInput[]
  }

  export type BillCreateNestedManyWithoutSchoolInput = {
    create?: XOR<BillCreateWithoutSchoolInput, BillUncheckedCreateWithoutSchoolInput> | BillCreateWithoutSchoolInput[] | BillUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: BillCreateOrConnectWithoutSchoolInput | BillCreateOrConnectWithoutSchoolInput[]
    createMany?: BillCreateManySchoolInputEnvelope
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
  }

  export type ClassCreateNestedManyWithoutSchoolInput = {
    create?: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput> | ClassCreateWithoutSchoolInput[] | ClassUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSchoolInput | ClassCreateOrConnectWithoutSchoolInput[]
    createMany?: ClassCreateManySchoolInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type DepartmentCreateNestedManyWithoutSchoolInput = {
    create?: XOR<DepartmentCreateWithoutSchoolInput, DepartmentUncheckedCreateWithoutSchoolInput> | DepartmentCreateWithoutSchoolInput[] | DepartmentUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutSchoolInput | DepartmentCreateOrConnectWithoutSchoolInput[]
    createMany?: DepartmentCreateManySchoolInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutSchoolInput = {
    create?: XOR<EventCreateWithoutSchoolInput, EventUncheckedCreateWithoutSchoolInput> | EventCreateWithoutSchoolInput[] | EventUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: EventCreateOrConnectWithoutSchoolInput | EventCreateOrConnectWithoutSchoolInput[]
    createMany?: EventCreateManySchoolInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type PaymentAccountCreateNestedManyWithoutSchoolInput = {
    create?: XOR<PaymentAccountCreateWithoutSchoolInput, PaymentAccountUncheckedCreateWithoutSchoolInput> | PaymentAccountCreateWithoutSchoolInput[] | PaymentAccountUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: PaymentAccountCreateOrConnectWithoutSchoolInput | PaymentAccountCreateOrConnectWithoutSchoolInput[]
    createMany?: PaymentAccountCreateManySchoolInputEnvelope
    connect?: PaymentAccountWhereUniqueInput | PaymentAccountWhereUniqueInput[]
  }

  export type SchoolLevelCreateNestedManyWithoutSchoolInput = {
    create?: XOR<SchoolLevelCreateWithoutSchoolInput, SchoolLevelUncheckedCreateWithoutSchoolInput> | SchoolLevelCreateWithoutSchoolInput[] | SchoolLevelUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SchoolLevelCreateOrConnectWithoutSchoolInput | SchoolLevelCreateOrConnectWithoutSchoolInput[]
    createMany?: SchoolLevelCreateManySchoolInputEnvelope
    connect?: SchoolLevelWhereUniqueInput | SchoolLevelWhereUniqueInput[]
  }

  export type SubjectCreateNestedManyWithoutSchoolInput = {
    create?: XOR<SubjectCreateWithoutSchoolInput, SubjectUncheckedCreateWithoutSchoolInput> | SubjectCreateWithoutSchoolInput[] | SubjectUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutSchoolInput | SubjectCreateOrConnectWithoutSchoolInput[]
    createMany?: SubjectCreateManySchoolInputEnvelope
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutSchoolInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    createMany?: UserCreateManySchoolInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ResultConfigurationCreateNestedManyWithoutSchoolInput = {
    create?: XOR<ResultConfigurationCreateWithoutSchoolInput, ResultConfigurationUncheckedCreateWithoutSchoolInput> | ResultConfigurationCreateWithoutSchoolInput[] | ResultConfigurationUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ResultConfigurationCreateOrConnectWithoutSchoolInput | ResultConfigurationCreateOrConnectWithoutSchoolInput[]
    createMany?: ResultConfigurationCreateManySchoolInputEnvelope
    connect?: ResultConfigurationWhereUniqueInput | ResultConfigurationWhereUniqueInput[]
  }

  export type AcademicSessionUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<AcademicSessionCreateWithoutSchoolInput, AcademicSessionUncheckedCreateWithoutSchoolInput> | AcademicSessionCreateWithoutSchoolInput[] | AcademicSessionUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: AcademicSessionCreateOrConnectWithoutSchoolInput | AcademicSessionCreateOrConnectWithoutSchoolInput[]
    createMany?: AcademicSessionCreateManySchoolInputEnvelope
    connect?: AcademicSessionWhereUniqueInput | AcademicSessionWhereUniqueInput[]
  }

  export type BillUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<BillCreateWithoutSchoolInput, BillUncheckedCreateWithoutSchoolInput> | BillCreateWithoutSchoolInput[] | BillUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: BillCreateOrConnectWithoutSchoolInput | BillCreateOrConnectWithoutSchoolInput[]
    createMany?: BillCreateManySchoolInputEnvelope
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
  }

  export type ClassUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput> | ClassCreateWithoutSchoolInput[] | ClassUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSchoolInput | ClassCreateOrConnectWithoutSchoolInput[]
    createMany?: ClassCreateManySchoolInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type DepartmentUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<DepartmentCreateWithoutSchoolInput, DepartmentUncheckedCreateWithoutSchoolInput> | DepartmentCreateWithoutSchoolInput[] | DepartmentUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutSchoolInput | DepartmentCreateOrConnectWithoutSchoolInput[]
    createMany?: DepartmentCreateManySchoolInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<EventCreateWithoutSchoolInput, EventUncheckedCreateWithoutSchoolInput> | EventCreateWithoutSchoolInput[] | EventUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: EventCreateOrConnectWithoutSchoolInput | EventCreateOrConnectWithoutSchoolInput[]
    createMany?: EventCreateManySchoolInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type PaymentAccountUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<PaymentAccountCreateWithoutSchoolInput, PaymentAccountUncheckedCreateWithoutSchoolInput> | PaymentAccountCreateWithoutSchoolInput[] | PaymentAccountUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: PaymentAccountCreateOrConnectWithoutSchoolInput | PaymentAccountCreateOrConnectWithoutSchoolInput[]
    createMany?: PaymentAccountCreateManySchoolInputEnvelope
    connect?: PaymentAccountWhereUniqueInput | PaymentAccountWhereUniqueInput[]
  }

  export type SchoolLevelUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<SchoolLevelCreateWithoutSchoolInput, SchoolLevelUncheckedCreateWithoutSchoolInput> | SchoolLevelCreateWithoutSchoolInput[] | SchoolLevelUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SchoolLevelCreateOrConnectWithoutSchoolInput | SchoolLevelCreateOrConnectWithoutSchoolInput[]
    createMany?: SchoolLevelCreateManySchoolInputEnvelope
    connect?: SchoolLevelWhereUniqueInput | SchoolLevelWhereUniqueInput[]
  }

  export type SubjectUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<SubjectCreateWithoutSchoolInput, SubjectUncheckedCreateWithoutSchoolInput> | SubjectCreateWithoutSchoolInput[] | SubjectUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutSchoolInput | SubjectCreateOrConnectWithoutSchoolInput[]
    createMany?: SubjectCreateManySchoolInputEnvelope
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    createMany?: UserCreateManySchoolInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ResultConfigurationUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<ResultConfigurationCreateWithoutSchoolInput, ResultConfigurationUncheckedCreateWithoutSchoolInput> | ResultConfigurationCreateWithoutSchoolInput[] | ResultConfigurationUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ResultConfigurationCreateOrConnectWithoutSchoolInput | ResultConfigurationCreateOrConnectWithoutSchoolInput[]
    createMany?: ResultConfigurationCreateManySchoolInputEnvelope
    connect?: ResultConfigurationWhereUniqueInput | ResultConfigurationWhereUniqueInput[]
  }

  export type AcademicSessionUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<AcademicSessionCreateWithoutSchoolInput, AcademicSessionUncheckedCreateWithoutSchoolInput> | AcademicSessionCreateWithoutSchoolInput[] | AcademicSessionUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: AcademicSessionCreateOrConnectWithoutSchoolInput | AcademicSessionCreateOrConnectWithoutSchoolInput[]
    upsert?: AcademicSessionUpsertWithWhereUniqueWithoutSchoolInput | AcademicSessionUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: AcademicSessionCreateManySchoolInputEnvelope
    set?: AcademicSessionWhereUniqueInput | AcademicSessionWhereUniqueInput[]
    disconnect?: AcademicSessionWhereUniqueInput | AcademicSessionWhereUniqueInput[]
    delete?: AcademicSessionWhereUniqueInput | AcademicSessionWhereUniqueInput[]
    connect?: AcademicSessionWhereUniqueInput | AcademicSessionWhereUniqueInput[]
    update?: AcademicSessionUpdateWithWhereUniqueWithoutSchoolInput | AcademicSessionUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: AcademicSessionUpdateManyWithWhereWithoutSchoolInput | AcademicSessionUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: AcademicSessionScalarWhereInput | AcademicSessionScalarWhereInput[]
  }

  export type BillUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<BillCreateWithoutSchoolInput, BillUncheckedCreateWithoutSchoolInput> | BillCreateWithoutSchoolInput[] | BillUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: BillCreateOrConnectWithoutSchoolInput | BillCreateOrConnectWithoutSchoolInput[]
    upsert?: BillUpsertWithWhereUniqueWithoutSchoolInput | BillUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: BillCreateManySchoolInputEnvelope
    set?: BillWhereUniqueInput | BillWhereUniqueInput[]
    disconnect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    delete?: BillWhereUniqueInput | BillWhereUniqueInput[]
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    update?: BillUpdateWithWhereUniqueWithoutSchoolInput | BillUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: BillUpdateManyWithWhereWithoutSchoolInput | BillUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: BillScalarWhereInput | BillScalarWhereInput[]
  }

  export type ClassUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput> | ClassCreateWithoutSchoolInput[] | ClassUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSchoolInput | ClassCreateOrConnectWithoutSchoolInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutSchoolInput | ClassUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: ClassCreateManySchoolInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutSchoolInput | ClassUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutSchoolInput | ClassUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type DepartmentUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<DepartmentCreateWithoutSchoolInput, DepartmentUncheckedCreateWithoutSchoolInput> | DepartmentCreateWithoutSchoolInput[] | DepartmentUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutSchoolInput | DepartmentCreateOrConnectWithoutSchoolInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutSchoolInput | DepartmentUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: DepartmentCreateManySchoolInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutSchoolInput | DepartmentUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutSchoolInput | DepartmentUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type EventUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<EventCreateWithoutSchoolInput, EventUncheckedCreateWithoutSchoolInput> | EventCreateWithoutSchoolInput[] | EventUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: EventCreateOrConnectWithoutSchoolInput | EventCreateOrConnectWithoutSchoolInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutSchoolInput | EventUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: EventCreateManySchoolInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutSchoolInput | EventUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: EventUpdateManyWithWhereWithoutSchoolInput | EventUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type PaymentAccountUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<PaymentAccountCreateWithoutSchoolInput, PaymentAccountUncheckedCreateWithoutSchoolInput> | PaymentAccountCreateWithoutSchoolInput[] | PaymentAccountUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: PaymentAccountCreateOrConnectWithoutSchoolInput | PaymentAccountCreateOrConnectWithoutSchoolInput[]
    upsert?: PaymentAccountUpsertWithWhereUniqueWithoutSchoolInput | PaymentAccountUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: PaymentAccountCreateManySchoolInputEnvelope
    set?: PaymentAccountWhereUniqueInput | PaymentAccountWhereUniqueInput[]
    disconnect?: PaymentAccountWhereUniqueInput | PaymentAccountWhereUniqueInput[]
    delete?: PaymentAccountWhereUniqueInput | PaymentAccountWhereUniqueInput[]
    connect?: PaymentAccountWhereUniqueInput | PaymentAccountWhereUniqueInput[]
    update?: PaymentAccountUpdateWithWhereUniqueWithoutSchoolInput | PaymentAccountUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: PaymentAccountUpdateManyWithWhereWithoutSchoolInput | PaymentAccountUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: PaymentAccountScalarWhereInput | PaymentAccountScalarWhereInput[]
  }

  export type SchoolLevelUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<SchoolLevelCreateWithoutSchoolInput, SchoolLevelUncheckedCreateWithoutSchoolInput> | SchoolLevelCreateWithoutSchoolInput[] | SchoolLevelUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SchoolLevelCreateOrConnectWithoutSchoolInput | SchoolLevelCreateOrConnectWithoutSchoolInput[]
    upsert?: SchoolLevelUpsertWithWhereUniqueWithoutSchoolInput | SchoolLevelUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: SchoolLevelCreateManySchoolInputEnvelope
    set?: SchoolLevelWhereUniqueInput | SchoolLevelWhereUniqueInput[]
    disconnect?: SchoolLevelWhereUniqueInput | SchoolLevelWhereUniqueInput[]
    delete?: SchoolLevelWhereUniqueInput | SchoolLevelWhereUniqueInput[]
    connect?: SchoolLevelWhereUniqueInput | SchoolLevelWhereUniqueInput[]
    update?: SchoolLevelUpdateWithWhereUniqueWithoutSchoolInput | SchoolLevelUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: SchoolLevelUpdateManyWithWhereWithoutSchoolInput | SchoolLevelUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: SchoolLevelScalarWhereInput | SchoolLevelScalarWhereInput[]
  }

  export type SubjectUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<SubjectCreateWithoutSchoolInput, SubjectUncheckedCreateWithoutSchoolInput> | SubjectCreateWithoutSchoolInput[] | SubjectUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutSchoolInput | SubjectCreateOrConnectWithoutSchoolInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutSchoolInput | SubjectUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: SubjectCreateManySchoolInputEnvelope
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutSchoolInput | SubjectUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutSchoolInput | SubjectUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type UserUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSchoolInput | UserUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: UserCreateManySchoolInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSchoolInput | UserUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSchoolInput | UserUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ResultConfigurationUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<ResultConfigurationCreateWithoutSchoolInput, ResultConfigurationUncheckedCreateWithoutSchoolInput> | ResultConfigurationCreateWithoutSchoolInput[] | ResultConfigurationUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ResultConfigurationCreateOrConnectWithoutSchoolInput | ResultConfigurationCreateOrConnectWithoutSchoolInput[]
    upsert?: ResultConfigurationUpsertWithWhereUniqueWithoutSchoolInput | ResultConfigurationUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: ResultConfigurationCreateManySchoolInputEnvelope
    set?: ResultConfigurationWhereUniqueInput | ResultConfigurationWhereUniqueInput[]
    disconnect?: ResultConfigurationWhereUniqueInput | ResultConfigurationWhereUniqueInput[]
    delete?: ResultConfigurationWhereUniqueInput | ResultConfigurationWhereUniqueInput[]
    connect?: ResultConfigurationWhereUniqueInput | ResultConfigurationWhereUniqueInput[]
    update?: ResultConfigurationUpdateWithWhereUniqueWithoutSchoolInput | ResultConfigurationUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: ResultConfigurationUpdateManyWithWhereWithoutSchoolInput | ResultConfigurationUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: ResultConfigurationScalarWhereInput | ResultConfigurationScalarWhereInput[]
  }

  export type AcademicSessionUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<AcademicSessionCreateWithoutSchoolInput, AcademicSessionUncheckedCreateWithoutSchoolInput> | AcademicSessionCreateWithoutSchoolInput[] | AcademicSessionUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: AcademicSessionCreateOrConnectWithoutSchoolInput | AcademicSessionCreateOrConnectWithoutSchoolInput[]
    upsert?: AcademicSessionUpsertWithWhereUniqueWithoutSchoolInput | AcademicSessionUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: AcademicSessionCreateManySchoolInputEnvelope
    set?: AcademicSessionWhereUniqueInput | AcademicSessionWhereUniqueInput[]
    disconnect?: AcademicSessionWhereUniqueInput | AcademicSessionWhereUniqueInput[]
    delete?: AcademicSessionWhereUniqueInput | AcademicSessionWhereUniqueInput[]
    connect?: AcademicSessionWhereUniqueInput | AcademicSessionWhereUniqueInput[]
    update?: AcademicSessionUpdateWithWhereUniqueWithoutSchoolInput | AcademicSessionUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: AcademicSessionUpdateManyWithWhereWithoutSchoolInput | AcademicSessionUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: AcademicSessionScalarWhereInput | AcademicSessionScalarWhereInput[]
  }

  export type BillUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<BillCreateWithoutSchoolInput, BillUncheckedCreateWithoutSchoolInput> | BillCreateWithoutSchoolInput[] | BillUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: BillCreateOrConnectWithoutSchoolInput | BillCreateOrConnectWithoutSchoolInput[]
    upsert?: BillUpsertWithWhereUniqueWithoutSchoolInput | BillUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: BillCreateManySchoolInputEnvelope
    set?: BillWhereUniqueInput | BillWhereUniqueInput[]
    disconnect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    delete?: BillWhereUniqueInput | BillWhereUniqueInput[]
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    update?: BillUpdateWithWhereUniqueWithoutSchoolInput | BillUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: BillUpdateManyWithWhereWithoutSchoolInput | BillUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: BillScalarWhereInput | BillScalarWhereInput[]
  }

  export type ClassUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput> | ClassCreateWithoutSchoolInput[] | ClassUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSchoolInput | ClassCreateOrConnectWithoutSchoolInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutSchoolInput | ClassUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: ClassCreateManySchoolInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutSchoolInput | ClassUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutSchoolInput | ClassUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type DepartmentUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<DepartmentCreateWithoutSchoolInput, DepartmentUncheckedCreateWithoutSchoolInput> | DepartmentCreateWithoutSchoolInput[] | DepartmentUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutSchoolInput | DepartmentCreateOrConnectWithoutSchoolInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutSchoolInput | DepartmentUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: DepartmentCreateManySchoolInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutSchoolInput | DepartmentUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutSchoolInput | DepartmentUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<EventCreateWithoutSchoolInput, EventUncheckedCreateWithoutSchoolInput> | EventCreateWithoutSchoolInput[] | EventUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: EventCreateOrConnectWithoutSchoolInput | EventCreateOrConnectWithoutSchoolInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutSchoolInput | EventUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: EventCreateManySchoolInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutSchoolInput | EventUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: EventUpdateManyWithWhereWithoutSchoolInput | EventUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type PaymentAccountUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<PaymentAccountCreateWithoutSchoolInput, PaymentAccountUncheckedCreateWithoutSchoolInput> | PaymentAccountCreateWithoutSchoolInput[] | PaymentAccountUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: PaymentAccountCreateOrConnectWithoutSchoolInput | PaymentAccountCreateOrConnectWithoutSchoolInput[]
    upsert?: PaymentAccountUpsertWithWhereUniqueWithoutSchoolInput | PaymentAccountUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: PaymentAccountCreateManySchoolInputEnvelope
    set?: PaymentAccountWhereUniqueInput | PaymentAccountWhereUniqueInput[]
    disconnect?: PaymentAccountWhereUniqueInput | PaymentAccountWhereUniqueInput[]
    delete?: PaymentAccountWhereUniqueInput | PaymentAccountWhereUniqueInput[]
    connect?: PaymentAccountWhereUniqueInput | PaymentAccountWhereUniqueInput[]
    update?: PaymentAccountUpdateWithWhereUniqueWithoutSchoolInput | PaymentAccountUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: PaymentAccountUpdateManyWithWhereWithoutSchoolInput | PaymentAccountUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: PaymentAccountScalarWhereInput | PaymentAccountScalarWhereInput[]
  }

  export type SchoolLevelUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<SchoolLevelCreateWithoutSchoolInput, SchoolLevelUncheckedCreateWithoutSchoolInput> | SchoolLevelCreateWithoutSchoolInput[] | SchoolLevelUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SchoolLevelCreateOrConnectWithoutSchoolInput | SchoolLevelCreateOrConnectWithoutSchoolInput[]
    upsert?: SchoolLevelUpsertWithWhereUniqueWithoutSchoolInput | SchoolLevelUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: SchoolLevelCreateManySchoolInputEnvelope
    set?: SchoolLevelWhereUniqueInput | SchoolLevelWhereUniqueInput[]
    disconnect?: SchoolLevelWhereUniqueInput | SchoolLevelWhereUniqueInput[]
    delete?: SchoolLevelWhereUniqueInput | SchoolLevelWhereUniqueInput[]
    connect?: SchoolLevelWhereUniqueInput | SchoolLevelWhereUniqueInput[]
    update?: SchoolLevelUpdateWithWhereUniqueWithoutSchoolInput | SchoolLevelUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: SchoolLevelUpdateManyWithWhereWithoutSchoolInput | SchoolLevelUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: SchoolLevelScalarWhereInput | SchoolLevelScalarWhereInput[]
  }

  export type SubjectUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<SubjectCreateWithoutSchoolInput, SubjectUncheckedCreateWithoutSchoolInput> | SubjectCreateWithoutSchoolInput[] | SubjectUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutSchoolInput | SubjectCreateOrConnectWithoutSchoolInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutSchoolInput | SubjectUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: SubjectCreateManySchoolInputEnvelope
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutSchoolInput | SubjectUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutSchoolInput | SubjectUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSchoolInput | UserUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: UserCreateManySchoolInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSchoolInput | UserUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSchoolInput | UserUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ResultConfigurationUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<ResultConfigurationCreateWithoutSchoolInput, ResultConfigurationUncheckedCreateWithoutSchoolInput> | ResultConfigurationCreateWithoutSchoolInput[] | ResultConfigurationUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ResultConfigurationCreateOrConnectWithoutSchoolInput | ResultConfigurationCreateOrConnectWithoutSchoolInput[]
    upsert?: ResultConfigurationUpsertWithWhereUniqueWithoutSchoolInput | ResultConfigurationUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: ResultConfigurationCreateManySchoolInputEnvelope
    set?: ResultConfigurationWhereUniqueInput | ResultConfigurationWhereUniqueInput[]
    disconnect?: ResultConfigurationWhereUniqueInput | ResultConfigurationWhereUniqueInput[]
    delete?: ResultConfigurationWhereUniqueInput | ResultConfigurationWhereUniqueInput[]
    connect?: ResultConfigurationWhereUniqueInput | ResultConfigurationWhereUniqueInput[]
    update?: ResultConfigurationUpdateWithWhereUniqueWithoutSchoolInput | ResultConfigurationUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: ResultConfigurationUpdateManyWithWhereWithoutSchoolInput | ResultConfigurationUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: ResultConfigurationScalarWhereInput | ResultConfigurationScalarWhereInput[]
  }

  export type SchoolCreateNestedOneWithoutDepartmentsInput = {
    create?: XOR<SchoolCreateWithoutDepartmentsInput, SchoolUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutDepartmentsInput
    connect?: SchoolWhereUniqueInput
  }

  export type StudentCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<StudentCreateWithoutDepartmentInput, StudentUncheckedCreateWithoutDepartmentInput> | StudentCreateWithoutDepartmentInput[] | StudentUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutDepartmentInput | StudentCreateOrConnectWithoutDepartmentInput[]
    createMany?: StudentCreateManyDepartmentInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type SubjectCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<SubjectCreateWithoutDepartmentInput, SubjectUncheckedCreateWithoutDepartmentInput> | SubjectCreateWithoutDepartmentInput[] | SubjectUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutDepartmentInput | SubjectCreateOrConnectWithoutDepartmentInput[]
    createMany?: SubjectCreateManyDepartmentInputEnvelope
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type TeacherCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<TeacherCreateWithoutDepartmentInput, TeacherUncheckedCreateWithoutDepartmentInput> | TeacherCreateWithoutDepartmentInput[] | TeacherUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: TeacherCreateOrConnectWithoutDepartmentInput | TeacherCreateOrConnectWithoutDepartmentInput[]
    createMany?: TeacherCreateManyDepartmentInputEnvelope
    connect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<StudentCreateWithoutDepartmentInput, StudentUncheckedCreateWithoutDepartmentInput> | StudentCreateWithoutDepartmentInput[] | StudentUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutDepartmentInput | StudentCreateOrConnectWithoutDepartmentInput[]
    createMany?: StudentCreateManyDepartmentInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type SubjectUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<SubjectCreateWithoutDepartmentInput, SubjectUncheckedCreateWithoutDepartmentInput> | SubjectCreateWithoutDepartmentInput[] | SubjectUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutDepartmentInput | SubjectCreateOrConnectWithoutDepartmentInput[]
    createMany?: SubjectCreateManyDepartmentInputEnvelope
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type TeacherUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<TeacherCreateWithoutDepartmentInput, TeacherUncheckedCreateWithoutDepartmentInput> | TeacherCreateWithoutDepartmentInput[] | TeacherUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: TeacherCreateOrConnectWithoutDepartmentInput | TeacherCreateOrConnectWithoutDepartmentInput[]
    createMany?: TeacherCreateManyDepartmentInputEnvelope
    connect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
  }

  export type SchoolUpdateOneRequiredWithoutDepartmentsNestedInput = {
    create?: XOR<SchoolCreateWithoutDepartmentsInput, SchoolUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutDepartmentsInput
    upsert?: SchoolUpsertWithoutDepartmentsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutDepartmentsInput, SchoolUpdateWithoutDepartmentsInput>, SchoolUncheckedUpdateWithoutDepartmentsInput>
  }

  export type StudentUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<StudentCreateWithoutDepartmentInput, StudentUncheckedCreateWithoutDepartmentInput> | StudentCreateWithoutDepartmentInput[] | StudentUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutDepartmentInput | StudentCreateOrConnectWithoutDepartmentInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutDepartmentInput | StudentUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: StudentCreateManyDepartmentInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutDepartmentInput | StudentUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutDepartmentInput | StudentUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type SubjectUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<SubjectCreateWithoutDepartmentInput, SubjectUncheckedCreateWithoutDepartmentInput> | SubjectCreateWithoutDepartmentInput[] | SubjectUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutDepartmentInput | SubjectCreateOrConnectWithoutDepartmentInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutDepartmentInput | SubjectUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: SubjectCreateManyDepartmentInputEnvelope
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutDepartmentInput | SubjectUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutDepartmentInput | SubjectUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type TeacherUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<TeacherCreateWithoutDepartmentInput, TeacherUncheckedCreateWithoutDepartmentInput> | TeacherCreateWithoutDepartmentInput[] | TeacherUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: TeacherCreateOrConnectWithoutDepartmentInput | TeacherCreateOrConnectWithoutDepartmentInput[]
    upsert?: TeacherUpsertWithWhereUniqueWithoutDepartmentInput | TeacherUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: TeacherCreateManyDepartmentInputEnvelope
    set?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    disconnect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    delete?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    connect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    update?: TeacherUpdateWithWhereUniqueWithoutDepartmentInput | TeacherUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: TeacherUpdateManyWithWhereWithoutDepartmentInput | TeacherUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: TeacherScalarWhereInput | TeacherScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<StudentCreateWithoutDepartmentInput, StudentUncheckedCreateWithoutDepartmentInput> | StudentCreateWithoutDepartmentInput[] | StudentUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutDepartmentInput | StudentCreateOrConnectWithoutDepartmentInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutDepartmentInput | StudentUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: StudentCreateManyDepartmentInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutDepartmentInput | StudentUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutDepartmentInput | StudentUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type SubjectUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<SubjectCreateWithoutDepartmentInput, SubjectUncheckedCreateWithoutDepartmentInput> | SubjectCreateWithoutDepartmentInput[] | SubjectUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutDepartmentInput | SubjectCreateOrConnectWithoutDepartmentInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutDepartmentInput | SubjectUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: SubjectCreateManyDepartmentInputEnvelope
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutDepartmentInput | SubjectUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutDepartmentInput | SubjectUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type TeacherUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<TeacherCreateWithoutDepartmentInput, TeacherUncheckedCreateWithoutDepartmentInput> | TeacherCreateWithoutDepartmentInput[] | TeacherUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: TeacherCreateOrConnectWithoutDepartmentInput | TeacherCreateOrConnectWithoutDepartmentInput[]
    upsert?: TeacherUpsertWithWhereUniqueWithoutDepartmentInput | TeacherUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: TeacherCreateManyDepartmentInputEnvelope
    set?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    disconnect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    delete?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    connect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    update?: TeacherUpdateWithWhereUniqueWithoutDepartmentInput | TeacherUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: TeacherUpdateManyWithWhereWithoutDepartmentInput | TeacherUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: TeacherScalarWhereInput | TeacherScalarWhereInput[]
  }

  export type SchoolLevelCreateNestedOneWithoutClassesInput = {
    create?: XOR<SchoolLevelCreateWithoutClassesInput, SchoolLevelUncheckedCreateWithoutClassesInput>
    connectOrCreate?: SchoolLevelCreateOrConnectWithoutClassesInput
    connect?: SchoolLevelWhereUniqueInput
  }

  export type SchoolCreateNestedOneWithoutClassesInput = {
    create?: XOR<SchoolCreateWithoutClassesInput, SchoolUncheckedCreateWithoutClassesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutClassesInput
    connect?: SchoolWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutClassesInput = {
    create?: XOR<TeacherCreateWithoutClassesInput, TeacherUncheckedCreateWithoutClassesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutClassesInput
    connect?: TeacherWhereUniqueInput
  }

  export type ClassSubjectCreateNestedManyWithoutClassInput = {
    create?: XOR<ClassSubjectCreateWithoutClassInput, ClassSubjectUncheckedCreateWithoutClassInput> | ClassSubjectCreateWithoutClassInput[] | ClassSubjectUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassSubjectCreateOrConnectWithoutClassInput | ClassSubjectCreateOrConnectWithoutClassInput[]
    createMany?: ClassSubjectCreateManyClassInputEnvelope
    connect?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
  }

  export type StudentClassCreateNestedManyWithoutClassInput = {
    create?: XOR<StudentClassCreateWithoutClassInput, StudentClassUncheckedCreateWithoutClassInput> | StudentClassCreateWithoutClassInput[] | StudentClassUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentClassCreateOrConnectWithoutClassInput | StudentClassCreateOrConnectWithoutClassInput[]
    createMany?: StudentClassCreateManyClassInputEnvelope
    connect?: StudentClassWhereUniqueInput | StudentClassWhereUniqueInput[]
  }

  export type ClassSubjectUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<ClassSubjectCreateWithoutClassInput, ClassSubjectUncheckedCreateWithoutClassInput> | ClassSubjectCreateWithoutClassInput[] | ClassSubjectUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassSubjectCreateOrConnectWithoutClassInput | ClassSubjectCreateOrConnectWithoutClassInput[]
    createMany?: ClassSubjectCreateManyClassInputEnvelope
    connect?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
  }

  export type StudentClassUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<StudentClassCreateWithoutClassInput, StudentClassUncheckedCreateWithoutClassInput> | StudentClassCreateWithoutClassInput[] | StudentClassUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentClassCreateOrConnectWithoutClassInput | StudentClassCreateOrConnectWithoutClassInput[]
    createMany?: StudentClassCreateManyClassInputEnvelope
    connect?: StudentClassWhereUniqueInput | StudentClassWhereUniqueInput[]
  }

  export type SchoolLevelUpdateOneWithoutClassesNestedInput = {
    create?: XOR<SchoolLevelCreateWithoutClassesInput, SchoolLevelUncheckedCreateWithoutClassesInput>
    connectOrCreate?: SchoolLevelCreateOrConnectWithoutClassesInput
    upsert?: SchoolLevelUpsertWithoutClassesInput
    disconnect?: SchoolLevelWhereInput | boolean
    delete?: SchoolLevelWhereInput | boolean
    connect?: SchoolLevelWhereUniqueInput
    update?: XOR<XOR<SchoolLevelUpdateToOneWithWhereWithoutClassesInput, SchoolLevelUpdateWithoutClassesInput>, SchoolLevelUncheckedUpdateWithoutClassesInput>
  }

  export type SchoolUpdateOneRequiredWithoutClassesNestedInput = {
    create?: XOR<SchoolCreateWithoutClassesInput, SchoolUncheckedCreateWithoutClassesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutClassesInput
    upsert?: SchoolUpsertWithoutClassesInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutClassesInput, SchoolUpdateWithoutClassesInput>, SchoolUncheckedUpdateWithoutClassesInput>
  }

  export type TeacherUpdateOneWithoutClassesNestedInput = {
    create?: XOR<TeacherCreateWithoutClassesInput, TeacherUncheckedCreateWithoutClassesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutClassesInput
    upsert?: TeacherUpsertWithoutClassesInput
    disconnect?: TeacherWhereInput | boolean
    delete?: TeacherWhereInput | boolean
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutClassesInput, TeacherUpdateWithoutClassesInput>, TeacherUncheckedUpdateWithoutClassesInput>
  }

  export type ClassSubjectUpdateManyWithoutClassNestedInput = {
    create?: XOR<ClassSubjectCreateWithoutClassInput, ClassSubjectUncheckedCreateWithoutClassInput> | ClassSubjectCreateWithoutClassInput[] | ClassSubjectUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassSubjectCreateOrConnectWithoutClassInput | ClassSubjectCreateOrConnectWithoutClassInput[]
    upsert?: ClassSubjectUpsertWithWhereUniqueWithoutClassInput | ClassSubjectUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ClassSubjectCreateManyClassInputEnvelope
    set?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    disconnect?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    delete?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    connect?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    update?: ClassSubjectUpdateWithWhereUniqueWithoutClassInput | ClassSubjectUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ClassSubjectUpdateManyWithWhereWithoutClassInput | ClassSubjectUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ClassSubjectScalarWhereInput | ClassSubjectScalarWhereInput[]
  }

  export type StudentClassUpdateManyWithoutClassNestedInput = {
    create?: XOR<StudentClassCreateWithoutClassInput, StudentClassUncheckedCreateWithoutClassInput> | StudentClassCreateWithoutClassInput[] | StudentClassUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentClassCreateOrConnectWithoutClassInput | StudentClassCreateOrConnectWithoutClassInput[]
    upsert?: StudentClassUpsertWithWhereUniqueWithoutClassInput | StudentClassUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: StudentClassCreateManyClassInputEnvelope
    set?: StudentClassWhereUniqueInput | StudentClassWhereUniqueInput[]
    disconnect?: StudentClassWhereUniqueInput | StudentClassWhereUniqueInput[]
    delete?: StudentClassWhereUniqueInput | StudentClassWhereUniqueInput[]
    connect?: StudentClassWhereUniqueInput | StudentClassWhereUniqueInput[]
    update?: StudentClassUpdateWithWhereUniqueWithoutClassInput | StudentClassUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: StudentClassUpdateManyWithWhereWithoutClassInput | StudentClassUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: StudentClassScalarWhereInput | StudentClassScalarWhereInput[]
  }

  export type ClassSubjectUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<ClassSubjectCreateWithoutClassInput, ClassSubjectUncheckedCreateWithoutClassInput> | ClassSubjectCreateWithoutClassInput[] | ClassSubjectUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassSubjectCreateOrConnectWithoutClassInput | ClassSubjectCreateOrConnectWithoutClassInput[]
    upsert?: ClassSubjectUpsertWithWhereUniqueWithoutClassInput | ClassSubjectUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ClassSubjectCreateManyClassInputEnvelope
    set?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    disconnect?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    delete?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    connect?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    update?: ClassSubjectUpdateWithWhereUniqueWithoutClassInput | ClassSubjectUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ClassSubjectUpdateManyWithWhereWithoutClassInput | ClassSubjectUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ClassSubjectScalarWhereInput | ClassSubjectScalarWhereInput[]
  }

  export type StudentClassUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<StudentClassCreateWithoutClassInput, StudentClassUncheckedCreateWithoutClassInput> | StudentClassCreateWithoutClassInput[] | StudentClassUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentClassCreateOrConnectWithoutClassInput | StudentClassCreateOrConnectWithoutClassInput[]
    upsert?: StudentClassUpsertWithWhereUniqueWithoutClassInput | StudentClassUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: StudentClassCreateManyClassInputEnvelope
    set?: StudentClassWhereUniqueInput | StudentClassWhereUniqueInput[]
    disconnect?: StudentClassWhereUniqueInput | StudentClassWhereUniqueInput[]
    delete?: StudentClassWhereUniqueInput | StudentClassWhereUniqueInput[]
    connect?: StudentClassWhereUniqueInput | StudentClassWhereUniqueInput[]
    update?: StudentClassUpdateWithWhereUniqueWithoutClassInput | StudentClassUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: StudentClassUpdateManyWithWhereWithoutClassInput | StudentClassUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: StudentClassScalarWhereInput | StudentClassScalarWhereInput[]
  }

  export type ClassSubjectCreateNestedManyWithoutSubjectInput = {
    create?: XOR<ClassSubjectCreateWithoutSubjectInput, ClassSubjectUncheckedCreateWithoutSubjectInput> | ClassSubjectCreateWithoutSubjectInput[] | ClassSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ClassSubjectCreateOrConnectWithoutSubjectInput | ClassSubjectCreateOrConnectWithoutSubjectInput[]
    createMany?: ClassSubjectCreateManySubjectInputEnvelope
    connect?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
  }

  export type ResultCreateNestedManyWithoutSubjectInput = {
    create?: XOR<ResultCreateWithoutSubjectInput, ResultUncheckedCreateWithoutSubjectInput> | ResultCreateWithoutSubjectInput[] | ResultUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ResultCreateOrConnectWithoutSubjectInput | ResultCreateOrConnectWithoutSubjectInput[]
    createMany?: ResultCreateManySubjectInputEnvelope
    connect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
  }

  export type StudentSubjectCreateNestedManyWithoutSubjectInput = {
    create?: XOR<StudentSubjectCreateWithoutSubjectInput, StudentSubjectUncheckedCreateWithoutSubjectInput> | StudentSubjectCreateWithoutSubjectInput[] | StudentSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: StudentSubjectCreateOrConnectWithoutSubjectInput | StudentSubjectCreateOrConnectWithoutSubjectInput[]
    createMany?: StudentSubjectCreateManySubjectInputEnvelope
    connect?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
  }

  export type DepartmentCreateNestedOneWithoutSubjectsInput = {
    create?: XOR<DepartmentCreateWithoutSubjectsInput, DepartmentUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutSubjectsInput
    connect?: DepartmentWhereUniqueInput
  }

  export type SchoolLevelCreateNestedOneWithoutSubjectsInput = {
    create?: XOR<SchoolLevelCreateWithoutSubjectsInput, SchoolLevelUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: SchoolLevelCreateOrConnectWithoutSubjectsInput
    connect?: SchoolLevelWhereUniqueInput
  }

  export type SchoolCreateNestedOneWithoutSubjectsInput = {
    create?: XOR<SchoolCreateWithoutSubjectsInput, SchoolUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutSubjectsInput
    connect?: SchoolWhereUniqueInput
  }

  export type SubjectTeacherCreateNestedManyWithoutSubjectInput = {
    create?: XOR<SubjectTeacherCreateWithoutSubjectInput, SubjectTeacherUncheckedCreateWithoutSubjectInput> | SubjectTeacherCreateWithoutSubjectInput[] | SubjectTeacherUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: SubjectTeacherCreateOrConnectWithoutSubjectInput | SubjectTeacherCreateOrConnectWithoutSubjectInput[]
    createMany?: SubjectTeacherCreateManySubjectInputEnvelope
    connect?: SubjectTeacherWhereUniqueInput | SubjectTeacherWhereUniqueInput[]
  }

  export type ClassSubjectUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<ClassSubjectCreateWithoutSubjectInput, ClassSubjectUncheckedCreateWithoutSubjectInput> | ClassSubjectCreateWithoutSubjectInput[] | ClassSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ClassSubjectCreateOrConnectWithoutSubjectInput | ClassSubjectCreateOrConnectWithoutSubjectInput[]
    createMany?: ClassSubjectCreateManySubjectInputEnvelope
    connect?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
  }

  export type ResultUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<ResultCreateWithoutSubjectInput, ResultUncheckedCreateWithoutSubjectInput> | ResultCreateWithoutSubjectInput[] | ResultUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ResultCreateOrConnectWithoutSubjectInput | ResultCreateOrConnectWithoutSubjectInput[]
    createMany?: ResultCreateManySubjectInputEnvelope
    connect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
  }

  export type StudentSubjectUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<StudentSubjectCreateWithoutSubjectInput, StudentSubjectUncheckedCreateWithoutSubjectInput> | StudentSubjectCreateWithoutSubjectInput[] | StudentSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: StudentSubjectCreateOrConnectWithoutSubjectInput | StudentSubjectCreateOrConnectWithoutSubjectInput[]
    createMany?: StudentSubjectCreateManySubjectInputEnvelope
    connect?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
  }

  export type SubjectTeacherUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<SubjectTeacherCreateWithoutSubjectInput, SubjectTeacherUncheckedCreateWithoutSubjectInput> | SubjectTeacherCreateWithoutSubjectInput[] | SubjectTeacherUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: SubjectTeacherCreateOrConnectWithoutSubjectInput | SubjectTeacherCreateOrConnectWithoutSubjectInput[]
    createMany?: SubjectTeacherCreateManySubjectInputEnvelope
    connect?: SubjectTeacherWhereUniqueInput | SubjectTeacherWhereUniqueInput[]
  }

  export type ClassSubjectUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<ClassSubjectCreateWithoutSubjectInput, ClassSubjectUncheckedCreateWithoutSubjectInput> | ClassSubjectCreateWithoutSubjectInput[] | ClassSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ClassSubjectCreateOrConnectWithoutSubjectInput | ClassSubjectCreateOrConnectWithoutSubjectInput[]
    upsert?: ClassSubjectUpsertWithWhereUniqueWithoutSubjectInput | ClassSubjectUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: ClassSubjectCreateManySubjectInputEnvelope
    set?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    disconnect?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    delete?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    connect?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    update?: ClassSubjectUpdateWithWhereUniqueWithoutSubjectInput | ClassSubjectUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: ClassSubjectUpdateManyWithWhereWithoutSubjectInput | ClassSubjectUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: ClassSubjectScalarWhereInput | ClassSubjectScalarWhereInput[]
  }

  export type ResultUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<ResultCreateWithoutSubjectInput, ResultUncheckedCreateWithoutSubjectInput> | ResultCreateWithoutSubjectInput[] | ResultUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ResultCreateOrConnectWithoutSubjectInput | ResultCreateOrConnectWithoutSubjectInput[]
    upsert?: ResultUpsertWithWhereUniqueWithoutSubjectInput | ResultUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: ResultCreateManySubjectInputEnvelope
    set?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    disconnect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    delete?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    connect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    update?: ResultUpdateWithWhereUniqueWithoutSubjectInput | ResultUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: ResultUpdateManyWithWhereWithoutSubjectInput | ResultUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: ResultScalarWhereInput | ResultScalarWhereInput[]
  }

  export type StudentSubjectUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<StudentSubjectCreateWithoutSubjectInput, StudentSubjectUncheckedCreateWithoutSubjectInput> | StudentSubjectCreateWithoutSubjectInput[] | StudentSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: StudentSubjectCreateOrConnectWithoutSubjectInput | StudentSubjectCreateOrConnectWithoutSubjectInput[]
    upsert?: StudentSubjectUpsertWithWhereUniqueWithoutSubjectInput | StudentSubjectUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: StudentSubjectCreateManySubjectInputEnvelope
    set?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    disconnect?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    delete?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    connect?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    update?: StudentSubjectUpdateWithWhereUniqueWithoutSubjectInput | StudentSubjectUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: StudentSubjectUpdateManyWithWhereWithoutSubjectInput | StudentSubjectUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: StudentSubjectScalarWhereInput | StudentSubjectScalarWhereInput[]
  }

  export type DepartmentUpdateOneWithoutSubjectsNestedInput = {
    create?: XOR<DepartmentCreateWithoutSubjectsInput, DepartmentUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutSubjectsInput
    upsert?: DepartmentUpsertWithoutSubjectsInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutSubjectsInput, DepartmentUpdateWithoutSubjectsInput>, DepartmentUncheckedUpdateWithoutSubjectsInput>
  }

  export type SchoolLevelUpdateOneWithoutSubjectsNestedInput = {
    create?: XOR<SchoolLevelCreateWithoutSubjectsInput, SchoolLevelUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: SchoolLevelCreateOrConnectWithoutSubjectsInput
    upsert?: SchoolLevelUpsertWithoutSubjectsInput
    disconnect?: SchoolLevelWhereInput | boolean
    delete?: SchoolLevelWhereInput | boolean
    connect?: SchoolLevelWhereUniqueInput
    update?: XOR<XOR<SchoolLevelUpdateToOneWithWhereWithoutSubjectsInput, SchoolLevelUpdateWithoutSubjectsInput>, SchoolLevelUncheckedUpdateWithoutSubjectsInput>
  }

  export type SchoolUpdateOneRequiredWithoutSubjectsNestedInput = {
    create?: XOR<SchoolCreateWithoutSubjectsInput, SchoolUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutSubjectsInput
    upsert?: SchoolUpsertWithoutSubjectsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutSubjectsInput, SchoolUpdateWithoutSubjectsInput>, SchoolUncheckedUpdateWithoutSubjectsInput>
  }

  export type SubjectTeacherUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<SubjectTeacherCreateWithoutSubjectInput, SubjectTeacherUncheckedCreateWithoutSubjectInput> | SubjectTeacherCreateWithoutSubjectInput[] | SubjectTeacherUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: SubjectTeacherCreateOrConnectWithoutSubjectInput | SubjectTeacherCreateOrConnectWithoutSubjectInput[]
    upsert?: SubjectTeacherUpsertWithWhereUniqueWithoutSubjectInput | SubjectTeacherUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: SubjectTeacherCreateManySubjectInputEnvelope
    set?: SubjectTeacherWhereUniqueInput | SubjectTeacherWhereUniqueInput[]
    disconnect?: SubjectTeacherWhereUniqueInput | SubjectTeacherWhereUniqueInput[]
    delete?: SubjectTeacherWhereUniqueInput | SubjectTeacherWhereUniqueInput[]
    connect?: SubjectTeacherWhereUniqueInput | SubjectTeacherWhereUniqueInput[]
    update?: SubjectTeacherUpdateWithWhereUniqueWithoutSubjectInput | SubjectTeacherUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: SubjectTeacherUpdateManyWithWhereWithoutSubjectInput | SubjectTeacherUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: SubjectTeacherScalarWhereInput | SubjectTeacherScalarWhereInput[]
  }

  export type ClassSubjectUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<ClassSubjectCreateWithoutSubjectInput, ClassSubjectUncheckedCreateWithoutSubjectInput> | ClassSubjectCreateWithoutSubjectInput[] | ClassSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ClassSubjectCreateOrConnectWithoutSubjectInput | ClassSubjectCreateOrConnectWithoutSubjectInput[]
    upsert?: ClassSubjectUpsertWithWhereUniqueWithoutSubjectInput | ClassSubjectUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: ClassSubjectCreateManySubjectInputEnvelope
    set?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    disconnect?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    delete?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    connect?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    update?: ClassSubjectUpdateWithWhereUniqueWithoutSubjectInput | ClassSubjectUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: ClassSubjectUpdateManyWithWhereWithoutSubjectInput | ClassSubjectUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: ClassSubjectScalarWhereInput | ClassSubjectScalarWhereInput[]
  }

  export type ResultUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<ResultCreateWithoutSubjectInput, ResultUncheckedCreateWithoutSubjectInput> | ResultCreateWithoutSubjectInput[] | ResultUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ResultCreateOrConnectWithoutSubjectInput | ResultCreateOrConnectWithoutSubjectInput[]
    upsert?: ResultUpsertWithWhereUniqueWithoutSubjectInput | ResultUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: ResultCreateManySubjectInputEnvelope
    set?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    disconnect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    delete?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    connect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    update?: ResultUpdateWithWhereUniqueWithoutSubjectInput | ResultUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: ResultUpdateManyWithWhereWithoutSubjectInput | ResultUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: ResultScalarWhereInput | ResultScalarWhereInput[]
  }

  export type StudentSubjectUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<StudentSubjectCreateWithoutSubjectInput, StudentSubjectUncheckedCreateWithoutSubjectInput> | StudentSubjectCreateWithoutSubjectInput[] | StudentSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: StudentSubjectCreateOrConnectWithoutSubjectInput | StudentSubjectCreateOrConnectWithoutSubjectInput[]
    upsert?: StudentSubjectUpsertWithWhereUniqueWithoutSubjectInput | StudentSubjectUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: StudentSubjectCreateManySubjectInputEnvelope
    set?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    disconnect?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    delete?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    connect?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    update?: StudentSubjectUpdateWithWhereUniqueWithoutSubjectInput | StudentSubjectUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: StudentSubjectUpdateManyWithWhereWithoutSubjectInput | StudentSubjectUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: StudentSubjectScalarWhereInput | StudentSubjectScalarWhereInput[]
  }

  export type SubjectTeacherUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<SubjectTeacherCreateWithoutSubjectInput, SubjectTeacherUncheckedCreateWithoutSubjectInput> | SubjectTeacherCreateWithoutSubjectInput[] | SubjectTeacherUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: SubjectTeacherCreateOrConnectWithoutSubjectInput | SubjectTeacherCreateOrConnectWithoutSubjectInput[]
    upsert?: SubjectTeacherUpsertWithWhereUniqueWithoutSubjectInput | SubjectTeacherUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: SubjectTeacherCreateManySubjectInputEnvelope
    set?: SubjectTeacherWhereUniqueInput | SubjectTeacherWhereUniqueInput[]
    disconnect?: SubjectTeacherWhereUniqueInput | SubjectTeacherWhereUniqueInput[]
    delete?: SubjectTeacherWhereUniqueInput | SubjectTeacherWhereUniqueInput[]
    connect?: SubjectTeacherWhereUniqueInput | SubjectTeacherWhereUniqueInput[]
    update?: SubjectTeacherUpdateWithWhereUniqueWithoutSubjectInput | SubjectTeacherUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: SubjectTeacherUpdateManyWithWhereWithoutSubjectInput | SubjectTeacherUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: SubjectTeacherScalarWhereInput | SubjectTeacherScalarWhereInput[]
  }

  export type SchoolCreateNestedOneWithoutSessionsInput = {
    create?: XOR<SchoolCreateWithoutSessionsInput, SchoolUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutSessionsInput
    connect?: SchoolWhereUniqueInput
  }

  export type AttendanceCreateNestedManyWithoutSessionInput = {
    create?: XOR<AttendanceCreateWithoutSessionInput, AttendanceUncheckedCreateWithoutSessionInput> | AttendanceCreateWithoutSessionInput[] | AttendanceUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutSessionInput | AttendanceCreateOrConnectWithoutSessionInput[]
    createMany?: AttendanceCreateManySessionInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type ResultCreateNestedManyWithoutSessionInput = {
    create?: XOR<ResultCreateWithoutSessionInput, ResultUncheckedCreateWithoutSessionInput> | ResultCreateWithoutSessionInput[] | ResultUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ResultCreateOrConnectWithoutSessionInput | ResultCreateOrConnectWithoutSessionInput[]
    createMany?: ResultCreateManySessionInputEnvelope
    connect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
  }

  export type StudentClassCreateNestedManyWithoutSessionInput = {
    create?: XOR<StudentClassCreateWithoutSessionInput, StudentClassUncheckedCreateWithoutSessionInput> | StudentClassCreateWithoutSessionInput[] | StudentClassUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: StudentClassCreateOrConnectWithoutSessionInput | StudentClassCreateOrConnectWithoutSessionInput[]
    createMany?: StudentClassCreateManySessionInputEnvelope
    connect?: StudentClassWhereUniqueInput | StudentClassWhereUniqueInput[]
  }

  export type ResultConfigurationCreateNestedManyWithoutSessionInput = {
    create?: XOR<ResultConfigurationCreateWithoutSessionInput, ResultConfigurationUncheckedCreateWithoutSessionInput> | ResultConfigurationCreateWithoutSessionInput[] | ResultConfigurationUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ResultConfigurationCreateOrConnectWithoutSessionInput | ResultConfigurationCreateOrConnectWithoutSessionInput[]
    createMany?: ResultConfigurationCreateManySessionInputEnvelope
    connect?: ResultConfigurationWhereUniqueInput | ResultConfigurationWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<AttendanceCreateWithoutSessionInput, AttendanceUncheckedCreateWithoutSessionInput> | AttendanceCreateWithoutSessionInput[] | AttendanceUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutSessionInput | AttendanceCreateOrConnectWithoutSessionInput[]
    createMany?: AttendanceCreateManySessionInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type ResultUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<ResultCreateWithoutSessionInput, ResultUncheckedCreateWithoutSessionInput> | ResultCreateWithoutSessionInput[] | ResultUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ResultCreateOrConnectWithoutSessionInput | ResultCreateOrConnectWithoutSessionInput[]
    createMany?: ResultCreateManySessionInputEnvelope
    connect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
  }

  export type StudentClassUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<StudentClassCreateWithoutSessionInput, StudentClassUncheckedCreateWithoutSessionInput> | StudentClassCreateWithoutSessionInput[] | StudentClassUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: StudentClassCreateOrConnectWithoutSessionInput | StudentClassCreateOrConnectWithoutSessionInput[]
    createMany?: StudentClassCreateManySessionInputEnvelope
    connect?: StudentClassWhereUniqueInput | StudentClassWhereUniqueInput[]
  }

  export type ResultConfigurationUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<ResultConfigurationCreateWithoutSessionInput, ResultConfigurationUncheckedCreateWithoutSessionInput> | ResultConfigurationCreateWithoutSessionInput[] | ResultConfigurationUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ResultConfigurationCreateOrConnectWithoutSessionInput | ResultConfigurationCreateOrConnectWithoutSessionInput[]
    createMany?: ResultConfigurationCreateManySessionInputEnvelope
    connect?: ResultConfigurationWhereUniqueInput | ResultConfigurationWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type SchoolUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<SchoolCreateWithoutSessionsInput, SchoolUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutSessionsInput
    upsert?: SchoolUpsertWithoutSessionsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutSessionsInput, SchoolUpdateWithoutSessionsInput>, SchoolUncheckedUpdateWithoutSessionsInput>
  }

  export type AttendanceUpdateManyWithoutSessionNestedInput = {
    create?: XOR<AttendanceCreateWithoutSessionInput, AttendanceUncheckedCreateWithoutSessionInput> | AttendanceCreateWithoutSessionInput[] | AttendanceUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutSessionInput | AttendanceCreateOrConnectWithoutSessionInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutSessionInput | AttendanceUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: AttendanceCreateManySessionInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutSessionInput | AttendanceUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutSessionInput | AttendanceUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type ResultUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ResultCreateWithoutSessionInput, ResultUncheckedCreateWithoutSessionInput> | ResultCreateWithoutSessionInput[] | ResultUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ResultCreateOrConnectWithoutSessionInput | ResultCreateOrConnectWithoutSessionInput[]
    upsert?: ResultUpsertWithWhereUniqueWithoutSessionInput | ResultUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ResultCreateManySessionInputEnvelope
    set?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    disconnect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    delete?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    connect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    update?: ResultUpdateWithWhereUniqueWithoutSessionInput | ResultUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ResultUpdateManyWithWhereWithoutSessionInput | ResultUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ResultScalarWhereInput | ResultScalarWhereInput[]
  }

  export type StudentClassUpdateManyWithoutSessionNestedInput = {
    create?: XOR<StudentClassCreateWithoutSessionInput, StudentClassUncheckedCreateWithoutSessionInput> | StudentClassCreateWithoutSessionInput[] | StudentClassUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: StudentClassCreateOrConnectWithoutSessionInput | StudentClassCreateOrConnectWithoutSessionInput[]
    upsert?: StudentClassUpsertWithWhereUniqueWithoutSessionInput | StudentClassUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: StudentClassCreateManySessionInputEnvelope
    set?: StudentClassWhereUniqueInput | StudentClassWhereUniqueInput[]
    disconnect?: StudentClassWhereUniqueInput | StudentClassWhereUniqueInput[]
    delete?: StudentClassWhereUniqueInput | StudentClassWhereUniqueInput[]
    connect?: StudentClassWhereUniqueInput | StudentClassWhereUniqueInput[]
    update?: StudentClassUpdateWithWhereUniqueWithoutSessionInput | StudentClassUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: StudentClassUpdateManyWithWhereWithoutSessionInput | StudentClassUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: StudentClassScalarWhereInput | StudentClassScalarWhereInput[]
  }

  export type ResultConfigurationUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ResultConfigurationCreateWithoutSessionInput, ResultConfigurationUncheckedCreateWithoutSessionInput> | ResultConfigurationCreateWithoutSessionInput[] | ResultConfigurationUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ResultConfigurationCreateOrConnectWithoutSessionInput | ResultConfigurationCreateOrConnectWithoutSessionInput[]
    upsert?: ResultConfigurationUpsertWithWhereUniqueWithoutSessionInput | ResultConfigurationUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ResultConfigurationCreateManySessionInputEnvelope
    set?: ResultConfigurationWhereUniqueInput | ResultConfigurationWhereUniqueInput[]
    disconnect?: ResultConfigurationWhereUniqueInput | ResultConfigurationWhereUniqueInput[]
    delete?: ResultConfigurationWhereUniqueInput | ResultConfigurationWhereUniqueInput[]
    connect?: ResultConfigurationWhereUniqueInput | ResultConfigurationWhereUniqueInput[]
    update?: ResultConfigurationUpdateWithWhereUniqueWithoutSessionInput | ResultConfigurationUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ResultConfigurationUpdateManyWithWhereWithoutSessionInput | ResultConfigurationUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ResultConfigurationScalarWhereInput | ResultConfigurationScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<AttendanceCreateWithoutSessionInput, AttendanceUncheckedCreateWithoutSessionInput> | AttendanceCreateWithoutSessionInput[] | AttendanceUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutSessionInput | AttendanceCreateOrConnectWithoutSessionInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutSessionInput | AttendanceUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: AttendanceCreateManySessionInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutSessionInput | AttendanceUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutSessionInput | AttendanceUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type ResultUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ResultCreateWithoutSessionInput, ResultUncheckedCreateWithoutSessionInput> | ResultCreateWithoutSessionInput[] | ResultUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ResultCreateOrConnectWithoutSessionInput | ResultCreateOrConnectWithoutSessionInput[]
    upsert?: ResultUpsertWithWhereUniqueWithoutSessionInput | ResultUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ResultCreateManySessionInputEnvelope
    set?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    disconnect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    delete?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    connect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    update?: ResultUpdateWithWhereUniqueWithoutSessionInput | ResultUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ResultUpdateManyWithWhereWithoutSessionInput | ResultUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ResultScalarWhereInput | ResultScalarWhereInput[]
  }

  export type StudentClassUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<StudentClassCreateWithoutSessionInput, StudentClassUncheckedCreateWithoutSessionInput> | StudentClassCreateWithoutSessionInput[] | StudentClassUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: StudentClassCreateOrConnectWithoutSessionInput | StudentClassCreateOrConnectWithoutSessionInput[]
    upsert?: StudentClassUpsertWithWhereUniqueWithoutSessionInput | StudentClassUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: StudentClassCreateManySessionInputEnvelope
    set?: StudentClassWhereUniqueInput | StudentClassWhereUniqueInput[]
    disconnect?: StudentClassWhereUniqueInput | StudentClassWhereUniqueInput[]
    delete?: StudentClassWhereUniqueInput | StudentClassWhereUniqueInput[]
    connect?: StudentClassWhereUniqueInput | StudentClassWhereUniqueInput[]
    update?: StudentClassUpdateWithWhereUniqueWithoutSessionInput | StudentClassUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: StudentClassUpdateManyWithWhereWithoutSessionInput | StudentClassUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: StudentClassScalarWhereInput | StudentClassScalarWhereInput[]
  }

  export type ResultConfigurationUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ResultConfigurationCreateWithoutSessionInput, ResultConfigurationUncheckedCreateWithoutSessionInput> | ResultConfigurationCreateWithoutSessionInput[] | ResultConfigurationUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ResultConfigurationCreateOrConnectWithoutSessionInput | ResultConfigurationCreateOrConnectWithoutSessionInput[]
    upsert?: ResultConfigurationUpsertWithWhereUniqueWithoutSessionInput | ResultConfigurationUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ResultConfigurationCreateManySessionInputEnvelope
    set?: ResultConfigurationWhereUniqueInput | ResultConfigurationWhereUniqueInput[]
    disconnect?: ResultConfigurationWhereUniqueInput | ResultConfigurationWhereUniqueInput[]
    delete?: ResultConfigurationWhereUniqueInput | ResultConfigurationWhereUniqueInput[]
    connect?: ResultConfigurationWhereUniqueInput | ResultConfigurationWhereUniqueInput[]
    update?: ResultConfigurationUpdateWithWhereUniqueWithoutSessionInput | ResultConfigurationUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ResultConfigurationUpdateManyWithWhereWithoutSessionInput | ResultConfigurationUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ResultConfigurationScalarWhereInput | ResultConfigurationScalarWhereInput[]
  }

  export type ClassCreateNestedOneWithoutStudentsInput = {
    create?: XOR<ClassCreateWithoutStudentsInput, ClassUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutStudentsInput
    connect?: ClassWhereUniqueInput
  }

  export type AcademicSessionCreateNestedOneWithoutStudentClassesInput = {
    create?: XOR<AcademicSessionCreateWithoutStudentClassesInput, AcademicSessionUncheckedCreateWithoutStudentClassesInput>
    connectOrCreate?: AcademicSessionCreateOrConnectWithoutStudentClassesInput
    connect?: AcademicSessionWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutClassesInput = {
    create?: XOR<StudentCreateWithoutClassesInput, StudentUncheckedCreateWithoutClassesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutClassesInput
    connect?: StudentWhereUniqueInput
  }

  export type EnumEnrollmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.EnrollmentStatus
  }

  export type ClassUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<ClassCreateWithoutStudentsInput, ClassUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutStudentsInput
    upsert?: ClassUpsertWithoutStudentsInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutStudentsInput, ClassUpdateWithoutStudentsInput>, ClassUncheckedUpdateWithoutStudentsInput>
  }

  export type AcademicSessionUpdateOneRequiredWithoutStudentClassesNestedInput = {
    create?: XOR<AcademicSessionCreateWithoutStudentClassesInput, AcademicSessionUncheckedCreateWithoutStudentClassesInput>
    connectOrCreate?: AcademicSessionCreateOrConnectWithoutStudentClassesInput
    upsert?: AcademicSessionUpsertWithoutStudentClassesInput
    connect?: AcademicSessionWhereUniqueInput
    update?: XOR<XOR<AcademicSessionUpdateToOneWithWhereWithoutStudentClassesInput, AcademicSessionUpdateWithoutStudentClassesInput>, AcademicSessionUncheckedUpdateWithoutStudentClassesInput>
  }

  export type StudentUpdateOneRequiredWithoutClassesNestedInput = {
    create?: XOR<StudentCreateWithoutClassesInput, StudentUncheckedCreateWithoutClassesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutClassesInput
    upsert?: StudentUpsertWithoutClassesInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutClassesInput, StudentUpdateWithoutClassesInput>, StudentUncheckedUpdateWithoutClassesInput>
  }

  export type ParentCreateNestedOneWithoutChildrenInput = {
    create?: XOR<ParentCreateWithoutChildrenInput, ParentUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ParentCreateOrConnectWithoutChildrenInput
    connect?: ParentWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutParentsInput = {
    create?: XOR<StudentCreateWithoutParentsInput, StudentUncheckedCreateWithoutParentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutParentsInput
    connect?: StudentWhereUniqueInput
  }

  export type ParentUpdateOneRequiredWithoutChildrenNestedInput = {
    create?: XOR<ParentCreateWithoutChildrenInput, ParentUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ParentCreateOrConnectWithoutChildrenInput
    upsert?: ParentUpsertWithoutChildrenInput
    connect?: ParentWhereUniqueInput
    update?: XOR<XOR<ParentUpdateToOneWithWhereWithoutChildrenInput, ParentUpdateWithoutChildrenInput>, ParentUncheckedUpdateWithoutChildrenInput>
  }

  export type StudentUpdateOneRequiredWithoutParentsNestedInput = {
    create?: XOR<StudentCreateWithoutParentsInput, StudentUncheckedCreateWithoutParentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutParentsInput
    upsert?: StudentUpsertWithoutParentsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutParentsInput, StudentUpdateWithoutParentsInput>, StudentUncheckedUpdateWithoutParentsInput>
  }

  export type SubjectCreateNestedOneWithoutTeachersInput = {
    create?: XOR<SubjectCreateWithoutTeachersInput, SubjectUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutTeachersInput
    connect?: SubjectWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutSubjectsInput = {
    create?: XOR<TeacherCreateWithoutSubjectsInput, TeacherUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutSubjectsInput
    connect?: TeacherWhereUniqueInput
  }

  export type SubjectUpdateOneRequiredWithoutTeachersNestedInput = {
    create?: XOR<SubjectCreateWithoutTeachersInput, SubjectUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutTeachersInput
    upsert?: SubjectUpsertWithoutTeachersInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutTeachersInput, SubjectUpdateWithoutTeachersInput>, SubjectUncheckedUpdateWithoutTeachersInput>
  }

  export type TeacherUpdateOneRequiredWithoutSubjectsNestedInput = {
    create?: XOR<TeacherCreateWithoutSubjectsInput, TeacherUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutSubjectsInput
    upsert?: TeacherUpsertWithoutSubjectsInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutSubjectsInput, TeacherUpdateWithoutSubjectsInput>, TeacherUncheckedUpdateWithoutSubjectsInput>
  }

  export type ClassCreateNestedOneWithoutSubjectsInput = {
    create?: XOR<ClassCreateWithoutSubjectsInput, ClassUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutSubjectsInput
    connect?: ClassWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutClassesInput = {
    create?: XOR<SubjectCreateWithoutClassesInput, SubjectUncheckedCreateWithoutClassesInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutClassesInput
    connect?: SubjectWhereUniqueInput
  }

  export type ClassUpdateOneRequiredWithoutSubjectsNestedInput = {
    create?: XOR<ClassCreateWithoutSubjectsInput, ClassUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutSubjectsInput
    upsert?: ClassUpsertWithoutSubjectsInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutSubjectsInput, ClassUpdateWithoutSubjectsInput>, ClassUncheckedUpdateWithoutSubjectsInput>
  }

  export type SubjectUpdateOneRequiredWithoutClassesNestedInput = {
    create?: XOR<SubjectCreateWithoutClassesInput, SubjectUncheckedCreateWithoutClassesInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutClassesInput
    upsert?: SubjectUpsertWithoutClassesInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutClassesInput, SubjectUpdateWithoutClassesInput>, SubjectUncheckedUpdateWithoutClassesInput>
  }

  export type AcademicSessionCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<AcademicSessionCreateWithoutAttendanceInput, AcademicSessionUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: AcademicSessionCreateOrConnectWithoutAttendanceInput
    connect?: AcademicSessionWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<StudentCreateWithoutAttendanceInput, StudentUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAttendanceInput
    connect?: StudentWhereUniqueInput
  }

  export type EnumAttendanceStatusFieldUpdateOperationsInput = {
    set?: $Enums.AttendanceStatus
  }

  export type AcademicSessionUpdateOneRequiredWithoutAttendanceNestedInput = {
    create?: XOR<AcademicSessionCreateWithoutAttendanceInput, AcademicSessionUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: AcademicSessionCreateOrConnectWithoutAttendanceInput
    upsert?: AcademicSessionUpsertWithoutAttendanceInput
    connect?: AcademicSessionWhereUniqueInput
    update?: XOR<XOR<AcademicSessionUpdateToOneWithWhereWithoutAttendanceInput, AcademicSessionUpdateWithoutAttendanceInput>, AcademicSessionUncheckedUpdateWithoutAttendanceInput>
  }

  export type StudentUpdateOneRequiredWithoutAttendanceNestedInput = {
    create?: XOR<StudentCreateWithoutAttendanceInput, StudentUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAttendanceInput
    upsert?: StudentUpsertWithoutAttendanceInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutAttendanceInput, StudentUpdateWithoutAttendanceInput>, StudentUncheckedUpdateWithoutAttendanceInput>
  }

  export type ComponentScoreCreateNestedManyWithoutResultInput = {
    create?: XOR<ComponentScoreCreateWithoutResultInput, ComponentScoreUncheckedCreateWithoutResultInput> | ComponentScoreCreateWithoutResultInput[] | ComponentScoreUncheckedCreateWithoutResultInput[]
    connectOrCreate?: ComponentScoreCreateOrConnectWithoutResultInput | ComponentScoreCreateOrConnectWithoutResultInput[]
    createMany?: ComponentScoreCreateManyResultInputEnvelope
    connect?: ComponentScoreWhereUniqueInput | ComponentScoreWhereUniqueInput[]
  }

  export type StudentCreateNestedOneWithoutResultsInput = {
    create?: XOR<StudentCreateWithoutResultsInput, StudentUncheckedCreateWithoutResultsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutResultsInput
    connect?: StudentWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutResultsInput = {
    create?: XOR<SubjectCreateWithoutResultsInput, SubjectUncheckedCreateWithoutResultsInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutResultsInput
    connect?: SubjectWhereUniqueInput
  }

  export type ResultPeriodCreateNestedOneWithoutResultsInput = {
    create?: XOR<ResultPeriodCreateWithoutResultsInput, ResultPeriodUncheckedCreateWithoutResultsInput>
    connectOrCreate?: ResultPeriodCreateOrConnectWithoutResultsInput
    connect?: ResultPeriodWhereUniqueInput
  }

  export type AcademicSessionCreateNestedOneWithoutResultsInput = {
    create?: XOR<AcademicSessionCreateWithoutResultsInput, AcademicSessionUncheckedCreateWithoutResultsInput>
    connectOrCreate?: AcademicSessionCreateOrConnectWithoutResultsInput
    connect?: AcademicSessionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovedResultsInput = {
    create?: XOR<UserCreateWithoutApprovedResultsInput, UserUncheckedCreateWithoutApprovedResultsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedResultsInput
    connect?: UserWhereUniqueInput
  }

  export type ComponentScoreUncheckedCreateNestedManyWithoutResultInput = {
    create?: XOR<ComponentScoreCreateWithoutResultInput, ComponentScoreUncheckedCreateWithoutResultInput> | ComponentScoreCreateWithoutResultInput[] | ComponentScoreUncheckedCreateWithoutResultInput[]
    connectOrCreate?: ComponentScoreCreateOrConnectWithoutResultInput | ComponentScoreCreateOrConnectWithoutResultInput[]
    createMany?: ComponentScoreCreateManyResultInputEnvelope
    connect?: ComponentScoreWhereUniqueInput | ComponentScoreWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ComponentScoreUpdateManyWithoutResultNestedInput = {
    create?: XOR<ComponentScoreCreateWithoutResultInput, ComponentScoreUncheckedCreateWithoutResultInput> | ComponentScoreCreateWithoutResultInput[] | ComponentScoreUncheckedCreateWithoutResultInput[]
    connectOrCreate?: ComponentScoreCreateOrConnectWithoutResultInput | ComponentScoreCreateOrConnectWithoutResultInput[]
    upsert?: ComponentScoreUpsertWithWhereUniqueWithoutResultInput | ComponentScoreUpsertWithWhereUniqueWithoutResultInput[]
    createMany?: ComponentScoreCreateManyResultInputEnvelope
    set?: ComponentScoreWhereUniqueInput | ComponentScoreWhereUniqueInput[]
    disconnect?: ComponentScoreWhereUniqueInput | ComponentScoreWhereUniqueInput[]
    delete?: ComponentScoreWhereUniqueInput | ComponentScoreWhereUniqueInput[]
    connect?: ComponentScoreWhereUniqueInput | ComponentScoreWhereUniqueInput[]
    update?: ComponentScoreUpdateWithWhereUniqueWithoutResultInput | ComponentScoreUpdateWithWhereUniqueWithoutResultInput[]
    updateMany?: ComponentScoreUpdateManyWithWhereWithoutResultInput | ComponentScoreUpdateManyWithWhereWithoutResultInput[]
    deleteMany?: ComponentScoreScalarWhereInput | ComponentScoreScalarWhereInput[]
  }

  export type StudentUpdateOneRequiredWithoutResultsNestedInput = {
    create?: XOR<StudentCreateWithoutResultsInput, StudentUncheckedCreateWithoutResultsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutResultsInput
    upsert?: StudentUpsertWithoutResultsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutResultsInput, StudentUpdateWithoutResultsInput>, StudentUncheckedUpdateWithoutResultsInput>
  }

  export type SubjectUpdateOneRequiredWithoutResultsNestedInput = {
    create?: XOR<SubjectCreateWithoutResultsInput, SubjectUncheckedCreateWithoutResultsInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutResultsInput
    upsert?: SubjectUpsertWithoutResultsInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutResultsInput, SubjectUpdateWithoutResultsInput>, SubjectUncheckedUpdateWithoutResultsInput>
  }

  export type ResultPeriodUpdateOneRequiredWithoutResultsNestedInput = {
    create?: XOR<ResultPeriodCreateWithoutResultsInput, ResultPeriodUncheckedCreateWithoutResultsInput>
    connectOrCreate?: ResultPeriodCreateOrConnectWithoutResultsInput
    upsert?: ResultPeriodUpsertWithoutResultsInput
    connect?: ResultPeriodWhereUniqueInput
    update?: XOR<XOR<ResultPeriodUpdateToOneWithWhereWithoutResultsInput, ResultPeriodUpdateWithoutResultsInput>, ResultPeriodUncheckedUpdateWithoutResultsInput>
  }

  export type AcademicSessionUpdateOneRequiredWithoutResultsNestedInput = {
    create?: XOR<AcademicSessionCreateWithoutResultsInput, AcademicSessionUncheckedCreateWithoutResultsInput>
    connectOrCreate?: AcademicSessionCreateOrConnectWithoutResultsInput
    upsert?: AcademicSessionUpsertWithoutResultsInput
    connect?: AcademicSessionWhereUniqueInput
    update?: XOR<XOR<AcademicSessionUpdateToOneWithWhereWithoutResultsInput, AcademicSessionUpdateWithoutResultsInput>, AcademicSessionUncheckedUpdateWithoutResultsInput>
  }

  export type UserUpdateOneWithoutApprovedResultsNestedInput = {
    create?: XOR<UserCreateWithoutApprovedResultsInput, UserUncheckedCreateWithoutApprovedResultsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedResultsInput
    upsert?: UserUpsertWithoutApprovedResultsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovedResultsInput, UserUpdateWithoutApprovedResultsInput>, UserUncheckedUpdateWithoutApprovedResultsInput>
  }

  export type ComponentScoreUncheckedUpdateManyWithoutResultNestedInput = {
    create?: XOR<ComponentScoreCreateWithoutResultInput, ComponentScoreUncheckedCreateWithoutResultInput> | ComponentScoreCreateWithoutResultInput[] | ComponentScoreUncheckedCreateWithoutResultInput[]
    connectOrCreate?: ComponentScoreCreateOrConnectWithoutResultInput | ComponentScoreCreateOrConnectWithoutResultInput[]
    upsert?: ComponentScoreUpsertWithWhereUniqueWithoutResultInput | ComponentScoreUpsertWithWhereUniqueWithoutResultInput[]
    createMany?: ComponentScoreCreateManyResultInputEnvelope
    set?: ComponentScoreWhereUniqueInput | ComponentScoreWhereUniqueInput[]
    disconnect?: ComponentScoreWhereUniqueInput | ComponentScoreWhereUniqueInput[]
    delete?: ComponentScoreWhereUniqueInput | ComponentScoreWhereUniqueInput[]
    connect?: ComponentScoreWhereUniqueInput | ComponentScoreWhereUniqueInput[]
    update?: ComponentScoreUpdateWithWhereUniqueWithoutResultInput | ComponentScoreUpdateWithWhereUniqueWithoutResultInput[]
    updateMany?: ComponentScoreUpdateManyWithWhereWithoutResultInput | ComponentScoreUpdateManyWithWhereWithoutResultInput[]
    deleteMany?: ComponentScoreScalarWhereInput | ComponentScoreScalarWhereInput[]
  }

  export type SchoolCreateNestedOneWithoutEventsInput = {
    create?: XOR<SchoolCreateWithoutEventsInput, SchoolUncheckedCreateWithoutEventsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutEventsInput
    connect?: SchoolWhereUniqueInput
  }

  export type SchoolUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<SchoolCreateWithoutEventsInput, SchoolUncheckedCreateWithoutEventsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutEventsInput
    upsert?: SchoolUpsertWithoutEventsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutEventsInput, SchoolUpdateWithoutEventsInput>, SchoolUncheckedUpdateWithoutEventsInput>
  }

  export type StudentCreateNestedOneWithoutSubjectsInput = {
    create?: XOR<StudentCreateWithoutSubjectsInput, StudentUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutSubjectsInput
    connect?: StudentWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutStudentsInput = {
    create?: XOR<SubjectCreateWithoutStudentsInput, SubjectUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutStudentsInput
    connect?: SubjectWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutSubjectsNestedInput = {
    create?: XOR<StudentCreateWithoutSubjectsInput, StudentUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutSubjectsInput
    upsert?: StudentUpsertWithoutSubjectsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutSubjectsInput, StudentUpdateWithoutSubjectsInput>, StudentUncheckedUpdateWithoutSubjectsInput>
  }

  export type SubjectUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<SubjectCreateWithoutStudentsInput, SubjectUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutStudentsInput
    upsert?: SubjectUpsertWithoutStudentsInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutStudentsInput, SubjectUpdateWithoutStudentsInput>, SubjectUncheckedUpdateWithoutStudentsInput>
  }

  export type PaymentAccountCreateNestedOneWithoutBillsInput = {
    create?: XOR<PaymentAccountCreateWithoutBillsInput, PaymentAccountUncheckedCreateWithoutBillsInput>
    connectOrCreate?: PaymentAccountCreateOrConnectWithoutBillsInput
    connect?: PaymentAccountWhereUniqueInput
  }

  export type SchoolCreateNestedOneWithoutBillsInput = {
    create?: XOR<SchoolCreateWithoutBillsInput, SchoolUncheckedCreateWithoutBillsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutBillsInput
    connect?: SchoolWhereUniqueInput
  }

  export type BillAssignmentCreateNestedManyWithoutBillInput = {
    create?: XOR<BillAssignmentCreateWithoutBillInput, BillAssignmentUncheckedCreateWithoutBillInput> | BillAssignmentCreateWithoutBillInput[] | BillAssignmentUncheckedCreateWithoutBillInput[]
    connectOrCreate?: BillAssignmentCreateOrConnectWithoutBillInput | BillAssignmentCreateOrConnectWithoutBillInput[]
    createMany?: BillAssignmentCreateManyBillInputEnvelope
    connect?: BillAssignmentWhereUniqueInput | BillAssignmentWhereUniqueInput[]
  }

  export type BillItemCreateNestedManyWithoutBillInput = {
    create?: XOR<BillItemCreateWithoutBillInput, BillItemUncheckedCreateWithoutBillInput> | BillItemCreateWithoutBillInput[] | BillItemUncheckedCreateWithoutBillInput[]
    connectOrCreate?: BillItemCreateOrConnectWithoutBillInput | BillItemCreateOrConnectWithoutBillInput[]
    createMany?: BillItemCreateManyBillInputEnvelope
    connect?: BillItemWhereUniqueInput | BillItemWhereUniqueInput[]
  }

  export type PaymentRequestCreateNestedManyWithoutBillInput = {
    create?: XOR<PaymentRequestCreateWithoutBillInput, PaymentRequestUncheckedCreateWithoutBillInput> | PaymentRequestCreateWithoutBillInput[] | PaymentRequestUncheckedCreateWithoutBillInput[]
    connectOrCreate?: PaymentRequestCreateOrConnectWithoutBillInput | PaymentRequestCreateOrConnectWithoutBillInput[]
    createMany?: PaymentRequestCreateManyBillInputEnvelope
    connect?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
  }

  export type BillAssignmentUncheckedCreateNestedManyWithoutBillInput = {
    create?: XOR<BillAssignmentCreateWithoutBillInput, BillAssignmentUncheckedCreateWithoutBillInput> | BillAssignmentCreateWithoutBillInput[] | BillAssignmentUncheckedCreateWithoutBillInput[]
    connectOrCreate?: BillAssignmentCreateOrConnectWithoutBillInput | BillAssignmentCreateOrConnectWithoutBillInput[]
    createMany?: BillAssignmentCreateManyBillInputEnvelope
    connect?: BillAssignmentWhereUniqueInput | BillAssignmentWhereUniqueInput[]
  }

  export type BillItemUncheckedCreateNestedManyWithoutBillInput = {
    create?: XOR<BillItemCreateWithoutBillInput, BillItemUncheckedCreateWithoutBillInput> | BillItemCreateWithoutBillInput[] | BillItemUncheckedCreateWithoutBillInput[]
    connectOrCreate?: BillItemCreateOrConnectWithoutBillInput | BillItemCreateOrConnectWithoutBillInput[]
    createMany?: BillItemCreateManyBillInputEnvelope
    connect?: BillItemWhereUniqueInput | BillItemWhereUniqueInput[]
  }

  export type PaymentRequestUncheckedCreateNestedManyWithoutBillInput = {
    create?: XOR<PaymentRequestCreateWithoutBillInput, PaymentRequestUncheckedCreateWithoutBillInput> | PaymentRequestCreateWithoutBillInput[] | PaymentRequestUncheckedCreateWithoutBillInput[]
    connectOrCreate?: PaymentRequestCreateOrConnectWithoutBillInput | PaymentRequestCreateOrConnectWithoutBillInput[]
    createMany?: PaymentRequestCreateManyBillInputEnvelope
    connect?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
  }

  export type PaymentAccountUpdateOneRequiredWithoutBillsNestedInput = {
    create?: XOR<PaymentAccountCreateWithoutBillsInput, PaymentAccountUncheckedCreateWithoutBillsInput>
    connectOrCreate?: PaymentAccountCreateOrConnectWithoutBillsInput
    upsert?: PaymentAccountUpsertWithoutBillsInput
    connect?: PaymentAccountWhereUniqueInput
    update?: XOR<XOR<PaymentAccountUpdateToOneWithWhereWithoutBillsInput, PaymentAccountUpdateWithoutBillsInput>, PaymentAccountUncheckedUpdateWithoutBillsInput>
  }

  export type SchoolUpdateOneRequiredWithoutBillsNestedInput = {
    create?: XOR<SchoolCreateWithoutBillsInput, SchoolUncheckedCreateWithoutBillsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutBillsInput
    upsert?: SchoolUpsertWithoutBillsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutBillsInput, SchoolUpdateWithoutBillsInput>, SchoolUncheckedUpdateWithoutBillsInput>
  }

  export type BillAssignmentUpdateManyWithoutBillNestedInput = {
    create?: XOR<BillAssignmentCreateWithoutBillInput, BillAssignmentUncheckedCreateWithoutBillInput> | BillAssignmentCreateWithoutBillInput[] | BillAssignmentUncheckedCreateWithoutBillInput[]
    connectOrCreate?: BillAssignmentCreateOrConnectWithoutBillInput | BillAssignmentCreateOrConnectWithoutBillInput[]
    upsert?: BillAssignmentUpsertWithWhereUniqueWithoutBillInput | BillAssignmentUpsertWithWhereUniqueWithoutBillInput[]
    createMany?: BillAssignmentCreateManyBillInputEnvelope
    set?: BillAssignmentWhereUniqueInput | BillAssignmentWhereUniqueInput[]
    disconnect?: BillAssignmentWhereUniqueInput | BillAssignmentWhereUniqueInput[]
    delete?: BillAssignmentWhereUniqueInput | BillAssignmentWhereUniqueInput[]
    connect?: BillAssignmentWhereUniqueInput | BillAssignmentWhereUniqueInput[]
    update?: BillAssignmentUpdateWithWhereUniqueWithoutBillInput | BillAssignmentUpdateWithWhereUniqueWithoutBillInput[]
    updateMany?: BillAssignmentUpdateManyWithWhereWithoutBillInput | BillAssignmentUpdateManyWithWhereWithoutBillInput[]
    deleteMany?: BillAssignmentScalarWhereInput | BillAssignmentScalarWhereInput[]
  }

  export type BillItemUpdateManyWithoutBillNestedInput = {
    create?: XOR<BillItemCreateWithoutBillInput, BillItemUncheckedCreateWithoutBillInput> | BillItemCreateWithoutBillInput[] | BillItemUncheckedCreateWithoutBillInput[]
    connectOrCreate?: BillItemCreateOrConnectWithoutBillInput | BillItemCreateOrConnectWithoutBillInput[]
    upsert?: BillItemUpsertWithWhereUniqueWithoutBillInput | BillItemUpsertWithWhereUniqueWithoutBillInput[]
    createMany?: BillItemCreateManyBillInputEnvelope
    set?: BillItemWhereUniqueInput | BillItemWhereUniqueInput[]
    disconnect?: BillItemWhereUniqueInput | BillItemWhereUniqueInput[]
    delete?: BillItemWhereUniqueInput | BillItemWhereUniqueInput[]
    connect?: BillItemWhereUniqueInput | BillItemWhereUniqueInput[]
    update?: BillItemUpdateWithWhereUniqueWithoutBillInput | BillItemUpdateWithWhereUniqueWithoutBillInput[]
    updateMany?: BillItemUpdateManyWithWhereWithoutBillInput | BillItemUpdateManyWithWhereWithoutBillInput[]
    deleteMany?: BillItemScalarWhereInput | BillItemScalarWhereInput[]
  }

  export type PaymentRequestUpdateManyWithoutBillNestedInput = {
    create?: XOR<PaymentRequestCreateWithoutBillInput, PaymentRequestUncheckedCreateWithoutBillInput> | PaymentRequestCreateWithoutBillInput[] | PaymentRequestUncheckedCreateWithoutBillInput[]
    connectOrCreate?: PaymentRequestCreateOrConnectWithoutBillInput | PaymentRequestCreateOrConnectWithoutBillInput[]
    upsert?: PaymentRequestUpsertWithWhereUniqueWithoutBillInput | PaymentRequestUpsertWithWhereUniqueWithoutBillInput[]
    createMany?: PaymentRequestCreateManyBillInputEnvelope
    set?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    disconnect?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    delete?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    connect?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    update?: PaymentRequestUpdateWithWhereUniqueWithoutBillInput | PaymentRequestUpdateWithWhereUniqueWithoutBillInput[]
    updateMany?: PaymentRequestUpdateManyWithWhereWithoutBillInput | PaymentRequestUpdateManyWithWhereWithoutBillInput[]
    deleteMany?: PaymentRequestScalarWhereInput | PaymentRequestScalarWhereInput[]
  }

  export type BillAssignmentUncheckedUpdateManyWithoutBillNestedInput = {
    create?: XOR<BillAssignmentCreateWithoutBillInput, BillAssignmentUncheckedCreateWithoutBillInput> | BillAssignmentCreateWithoutBillInput[] | BillAssignmentUncheckedCreateWithoutBillInput[]
    connectOrCreate?: BillAssignmentCreateOrConnectWithoutBillInput | BillAssignmentCreateOrConnectWithoutBillInput[]
    upsert?: BillAssignmentUpsertWithWhereUniqueWithoutBillInput | BillAssignmentUpsertWithWhereUniqueWithoutBillInput[]
    createMany?: BillAssignmentCreateManyBillInputEnvelope
    set?: BillAssignmentWhereUniqueInput | BillAssignmentWhereUniqueInput[]
    disconnect?: BillAssignmentWhereUniqueInput | BillAssignmentWhereUniqueInput[]
    delete?: BillAssignmentWhereUniqueInput | BillAssignmentWhereUniqueInput[]
    connect?: BillAssignmentWhereUniqueInput | BillAssignmentWhereUniqueInput[]
    update?: BillAssignmentUpdateWithWhereUniqueWithoutBillInput | BillAssignmentUpdateWithWhereUniqueWithoutBillInput[]
    updateMany?: BillAssignmentUpdateManyWithWhereWithoutBillInput | BillAssignmentUpdateManyWithWhereWithoutBillInput[]
    deleteMany?: BillAssignmentScalarWhereInput | BillAssignmentScalarWhereInput[]
  }

  export type BillItemUncheckedUpdateManyWithoutBillNestedInput = {
    create?: XOR<BillItemCreateWithoutBillInput, BillItemUncheckedCreateWithoutBillInput> | BillItemCreateWithoutBillInput[] | BillItemUncheckedCreateWithoutBillInput[]
    connectOrCreate?: BillItemCreateOrConnectWithoutBillInput | BillItemCreateOrConnectWithoutBillInput[]
    upsert?: BillItemUpsertWithWhereUniqueWithoutBillInput | BillItemUpsertWithWhereUniqueWithoutBillInput[]
    createMany?: BillItemCreateManyBillInputEnvelope
    set?: BillItemWhereUniqueInput | BillItemWhereUniqueInput[]
    disconnect?: BillItemWhereUniqueInput | BillItemWhereUniqueInput[]
    delete?: BillItemWhereUniqueInput | BillItemWhereUniqueInput[]
    connect?: BillItemWhereUniqueInput | BillItemWhereUniqueInput[]
    update?: BillItemUpdateWithWhereUniqueWithoutBillInput | BillItemUpdateWithWhereUniqueWithoutBillInput[]
    updateMany?: BillItemUpdateManyWithWhereWithoutBillInput | BillItemUpdateManyWithWhereWithoutBillInput[]
    deleteMany?: BillItemScalarWhereInput | BillItemScalarWhereInput[]
  }

  export type PaymentRequestUncheckedUpdateManyWithoutBillNestedInput = {
    create?: XOR<PaymentRequestCreateWithoutBillInput, PaymentRequestUncheckedCreateWithoutBillInput> | PaymentRequestCreateWithoutBillInput[] | PaymentRequestUncheckedCreateWithoutBillInput[]
    connectOrCreate?: PaymentRequestCreateOrConnectWithoutBillInput | PaymentRequestCreateOrConnectWithoutBillInput[]
    upsert?: PaymentRequestUpsertWithWhereUniqueWithoutBillInput | PaymentRequestUpsertWithWhereUniqueWithoutBillInput[]
    createMany?: PaymentRequestCreateManyBillInputEnvelope
    set?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    disconnect?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    delete?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    connect?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    update?: PaymentRequestUpdateWithWhereUniqueWithoutBillInput | PaymentRequestUpdateWithWhereUniqueWithoutBillInput[]
    updateMany?: PaymentRequestUpdateManyWithWhereWithoutBillInput | PaymentRequestUpdateManyWithWhereWithoutBillInput[]
    deleteMany?: PaymentRequestScalarWhereInput | PaymentRequestScalarWhereInput[]
  }

  export type BillCreateNestedOneWithoutItemsInput = {
    create?: XOR<BillCreateWithoutItemsInput, BillUncheckedCreateWithoutItemsInput>
    connectOrCreate?: BillCreateOrConnectWithoutItemsInput
    connect?: BillWhereUniqueInput
  }

  export type BillUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<BillCreateWithoutItemsInput, BillUncheckedCreateWithoutItemsInput>
    connectOrCreate?: BillCreateOrConnectWithoutItemsInput
    upsert?: BillUpsertWithoutItemsInput
    connect?: BillWhereUniqueInput
    update?: XOR<XOR<BillUpdateToOneWithWhereWithoutItemsInput, BillUpdateWithoutItemsInput>, BillUncheckedUpdateWithoutItemsInput>
  }

  export type BillCreateNestedManyWithoutAccountInput = {
    create?: XOR<BillCreateWithoutAccountInput, BillUncheckedCreateWithoutAccountInput> | BillCreateWithoutAccountInput[] | BillUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: BillCreateOrConnectWithoutAccountInput | BillCreateOrConnectWithoutAccountInput[]
    createMany?: BillCreateManyAccountInputEnvelope
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
  }

  export type SchoolCreateNestedOneWithoutPaymentAccountsInput = {
    create?: XOR<SchoolCreateWithoutPaymentAccountsInput, SchoolUncheckedCreateWithoutPaymentAccountsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutPaymentAccountsInput
    connect?: SchoolWhereUniqueInput
  }

  export type BillUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<BillCreateWithoutAccountInput, BillUncheckedCreateWithoutAccountInput> | BillCreateWithoutAccountInput[] | BillUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: BillCreateOrConnectWithoutAccountInput | BillCreateOrConnectWithoutAccountInput[]
    createMany?: BillCreateManyAccountInputEnvelope
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
  }

  export type BillUpdateManyWithoutAccountNestedInput = {
    create?: XOR<BillCreateWithoutAccountInput, BillUncheckedCreateWithoutAccountInput> | BillCreateWithoutAccountInput[] | BillUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: BillCreateOrConnectWithoutAccountInput | BillCreateOrConnectWithoutAccountInput[]
    upsert?: BillUpsertWithWhereUniqueWithoutAccountInput | BillUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: BillCreateManyAccountInputEnvelope
    set?: BillWhereUniqueInput | BillWhereUniqueInput[]
    disconnect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    delete?: BillWhereUniqueInput | BillWhereUniqueInput[]
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    update?: BillUpdateWithWhereUniqueWithoutAccountInput | BillUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: BillUpdateManyWithWhereWithoutAccountInput | BillUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: BillScalarWhereInput | BillScalarWhereInput[]
  }

  export type SchoolUpdateOneRequiredWithoutPaymentAccountsNestedInput = {
    create?: XOR<SchoolCreateWithoutPaymentAccountsInput, SchoolUncheckedCreateWithoutPaymentAccountsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutPaymentAccountsInput
    upsert?: SchoolUpsertWithoutPaymentAccountsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutPaymentAccountsInput, SchoolUpdateWithoutPaymentAccountsInput>, SchoolUncheckedUpdateWithoutPaymentAccountsInput>
  }

  export type BillUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<BillCreateWithoutAccountInput, BillUncheckedCreateWithoutAccountInput> | BillCreateWithoutAccountInput[] | BillUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: BillCreateOrConnectWithoutAccountInput | BillCreateOrConnectWithoutAccountInput[]
    upsert?: BillUpsertWithWhereUniqueWithoutAccountInput | BillUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: BillCreateManyAccountInputEnvelope
    set?: BillWhereUniqueInput | BillWhereUniqueInput[]
    disconnect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    delete?: BillWhereUniqueInput | BillWhereUniqueInput[]
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    update?: BillUpdateWithWhereUniqueWithoutAccountInput | BillUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: BillUpdateManyWithWhereWithoutAccountInput | BillUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: BillScalarWhereInput | BillScalarWhereInput[]
  }

  export type BillCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<BillCreateWithoutAssignmentsInput, BillUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: BillCreateOrConnectWithoutAssignmentsInput
    connect?: BillWhereUniqueInput
  }

  export type PaymentRequestCreateNestedManyWithoutBillAssignmentInput = {
    create?: XOR<PaymentRequestCreateWithoutBillAssignmentInput, PaymentRequestUncheckedCreateWithoutBillAssignmentInput> | PaymentRequestCreateWithoutBillAssignmentInput[] | PaymentRequestUncheckedCreateWithoutBillAssignmentInput[]
    connectOrCreate?: PaymentRequestCreateOrConnectWithoutBillAssignmentInput | PaymentRequestCreateOrConnectWithoutBillAssignmentInput[]
    createMany?: PaymentRequestCreateManyBillAssignmentInputEnvelope
    connect?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
  }

  export type StudentPaymentCreateNestedManyWithoutBillAssignmentInput = {
    create?: XOR<StudentPaymentCreateWithoutBillAssignmentInput, StudentPaymentUncheckedCreateWithoutBillAssignmentInput> | StudentPaymentCreateWithoutBillAssignmentInput[] | StudentPaymentUncheckedCreateWithoutBillAssignmentInput[]
    connectOrCreate?: StudentPaymentCreateOrConnectWithoutBillAssignmentInput | StudentPaymentCreateOrConnectWithoutBillAssignmentInput[]
    createMany?: StudentPaymentCreateManyBillAssignmentInputEnvelope
    connect?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
  }

  export type PaymentRequestUncheckedCreateNestedManyWithoutBillAssignmentInput = {
    create?: XOR<PaymentRequestCreateWithoutBillAssignmentInput, PaymentRequestUncheckedCreateWithoutBillAssignmentInput> | PaymentRequestCreateWithoutBillAssignmentInput[] | PaymentRequestUncheckedCreateWithoutBillAssignmentInput[]
    connectOrCreate?: PaymentRequestCreateOrConnectWithoutBillAssignmentInput | PaymentRequestCreateOrConnectWithoutBillAssignmentInput[]
    createMany?: PaymentRequestCreateManyBillAssignmentInputEnvelope
    connect?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
  }

  export type StudentPaymentUncheckedCreateNestedManyWithoutBillAssignmentInput = {
    create?: XOR<StudentPaymentCreateWithoutBillAssignmentInput, StudentPaymentUncheckedCreateWithoutBillAssignmentInput> | StudentPaymentCreateWithoutBillAssignmentInput[] | StudentPaymentUncheckedCreateWithoutBillAssignmentInput[]
    connectOrCreate?: StudentPaymentCreateOrConnectWithoutBillAssignmentInput | StudentPaymentCreateOrConnectWithoutBillAssignmentInput[]
    createMany?: StudentPaymentCreateManyBillAssignmentInputEnvelope
    connect?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
  }

  export type EnumBillAssignmentTypeFieldUpdateOperationsInput = {
    set?: $Enums.BillAssignmentType
  }

  export type EnumBillStatusFieldUpdateOperationsInput = {
    set?: $Enums.BillStatus
  }

  export type BillUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<BillCreateWithoutAssignmentsInput, BillUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: BillCreateOrConnectWithoutAssignmentsInput
    upsert?: BillUpsertWithoutAssignmentsInput
    connect?: BillWhereUniqueInput
    update?: XOR<XOR<BillUpdateToOneWithWhereWithoutAssignmentsInput, BillUpdateWithoutAssignmentsInput>, BillUncheckedUpdateWithoutAssignmentsInput>
  }

  export type PaymentRequestUpdateManyWithoutBillAssignmentNestedInput = {
    create?: XOR<PaymentRequestCreateWithoutBillAssignmentInput, PaymentRequestUncheckedCreateWithoutBillAssignmentInput> | PaymentRequestCreateWithoutBillAssignmentInput[] | PaymentRequestUncheckedCreateWithoutBillAssignmentInput[]
    connectOrCreate?: PaymentRequestCreateOrConnectWithoutBillAssignmentInput | PaymentRequestCreateOrConnectWithoutBillAssignmentInput[]
    upsert?: PaymentRequestUpsertWithWhereUniqueWithoutBillAssignmentInput | PaymentRequestUpsertWithWhereUniqueWithoutBillAssignmentInput[]
    createMany?: PaymentRequestCreateManyBillAssignmentInputEnvelope
    set?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    disconnect?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    delete?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    connect?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    update?: PaymentRequestUpdateWithWhereUniqueWithoutBillAssignmentInput | PaymentRequestUpdateWithWhereUniqueWithoutBillAssignmentInput[]
    updateMany?: PaymentRequestUpdateManyWithWhereWithoutBillAssignmentInput | PaymentRequestUpdateManyWithWhereWithoutBillAssignmentInput[]
    deleteMany?: PaymentRequestScalarWhereInput | PaymentRequestScalarWhereInput[]
  }

  export type StudentPaymentUpdateManyWithoutBillAssignmentNestedInput = {
    create?: XOR<StudentPaymentCreateWithoutBillAssignmentInput, StudentPaymentUncheckedCreateWithoutBillAssignmentInput> | StudentPaymentCreateWithoutBillAssignmentInput[] | StudentPaymentUncheckedCreateWithoutBillAssignmentInput[]
    connectOrCreate?: StudentPaymentCreateOrConnectWithoutBillAssignmentInput | StudentPaymentCreateOrConnectWithoutBillAssignmentInput[]
    upsert?: StudentPaymentUpsertWithWhereUniqueWithoutBillAssignmentInput | StudentPaymentUpsertWithWhereUniqueWithoutBillAssignmentInput[]
    createMany?: StudentPaymentCreateManyBillAssignmentInputEnvelope
    set?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    disconnect?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    delete?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    connect?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    update?: StudentPaymentUpdateWithWhereUniqueWithoutBillAssignmentInput | StudentPaymentUpdateWithWhereUniqueWithoutBillAssignmentInput[]
    updateMany?: StudentPaymentUpdateManyWithWhereWithoutBillAssignmentInput | StudentPaymentUpdateManyWithWhereWithoutBillAssignmentInput[]
    deleteMany?: StudentPaymentScalarWhereInput | StudentPaymentScalarWhereInput[]
  }

  export type PaymentRequestUncheckedUpdateManyWithoutBillAssignmentNestedInput = {
    create?: XOR<PaymentRequestCreateWithoutBillAssignmentInput, PaymentRequestUncheckedCreateWithoutBillAssignmentInput> | PaymentRequestCreateWithoutBillAssignmentInput[] | PaymentRequestUncheckedCreateWithoutBillAssignmentInput[]
    connectOrCreate?: PaymentRequestCreateOrConnectWithoutBillAssignmentInput | PaymentRequestCreateOrConnectWithoutBillAssignmentInput[]
    upsert?: PaymentRequestUpsertWithWhereUniqueWithoutBillAssignmentInput | PaymentRequestUpsertWithWhereUniqueWithoutBillAssignmentInput[]
    createMany?: PaymentRequestCreateManyBillAssignmentInputEnvelope
    set?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    disconnect?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    delete?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    connect?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    update?: PaymentRequestUpdateWithWhereUniqueWithoutBillAssignmentInput | PaymentRequestUpdateWithWhereUniqueWithoutBillAssignmentInput[]
    updateMany?: PaymentRequestUpdateManyWithWhereWithoutBillAssignmentInput | PaymentRequestUpdateManyWithWhereWithoutBillAssignmentInput[]
    deleteMany?: PaymentRequestScalarWhereInput | PaymentRequestScalarWhereInput[]
  }

  export type StudentPaymentUncheckedUpdateManyWithoutBillAssignmentNestedInput = {
    create?: XOR<StudentPaymentCreateWithoutBillAssignmentInput, StudentPaymentUncheckedCreateWithoutBillAssignmentInput> | StudentPaymentCreateWithoutBillAssignmentInput[] | StudentPaymentUncheckedCreateWithoutBillAssignmentInput[]
    connectOrCreate?: StudentPaymentCreateOrConnectWithoutBillAssignmentInput | StudentPaymentCreateOrConnectWithoutBillAssignmentInput[]
    upsert?: StudentPaymentUpsertWithWhereUniqueWithoutBillAssignmentInput | StudentPaymentUpsertWithWhereUniqueWithoutBillAssignmentInput[]
    createMany?: StudentPaymentCreateManyBillAssignmentInputEnvelope
    set?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    disconnect?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    delete?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    connect?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    update?: StudentPaymentUpdateWithWhereUniqueWithoutBillAssignmentInput | StudentPaymentUpdateWithWhereUniqueWithoutBillAssignmentInput[]
    updateMany?: StudentPaymentUpdateManyWithWhereWithoutBillAssignmentInput | StudentPaymentUpdateManyWithWhereWithoutBillAssignmentInput[]
    deleteMany?: StudentPaymentScalarWhereInput | StudentPaymentScalarWhereInput[]
  }

  export type PaymentRequestCreateNestedManyWithoutStudentPaymentInput = {
    create?: XOR<PaymentRequestCreateWithoutStudentPaymentInput, PaymentRequestUncheckedCreateWithoutStudentPaymentInput> | PaymentRequestCreateWithoutStudentPaymentInput[] | PaymentRequestUncheckedCreateWithoutStudentPaymentInput[]
    connectOrCreate?: PaymentRequestCreateOrConnectWithoutStudentPaymentInput | PaymentRequestCreateOrConnectWithoutStudentPaymentInput[]
    createMany?: PaymentRequestCreateManyStudentPaymentInputEnvelope
    connect?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
  }

  export type BillAssignmentCreateNestedOneWithoutStudentPaymentsInput = {
    create?: XOR<BillAssignmentCreateWithoutStudentPaymentsInput, BillAssignmentUncheckedCreateWithoutStudentPaymentsInput>
    connectOrCreate?: BillAssignmentCreateOrConnectWithoutStudentPaymentsInput
    connect?: BillAssignmentWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<StudentCreateWithoutPaymentsInput, StudentUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutPaymentsInput
    connect?: StudentWhereUniqueInput
  }

  export type PaymentRequestUncheckedCreateNestedManyWithoutStudentPaymentInput = {
    create?: XOR<PaymentRequestCreateWithoutStudentPaymentInput, PaymentRequestUncheckedCreateWithoutStudentPaymentInput> | PaymentRequestCreateWithoutStudentPaymentInput[] | PaymentRequestUncheckedCreateWithoutStudentPaymentInput[]
    connectOrCreate?: PaymentRequestCreateOrConnectWithoutStudentPaymentInput | PaymentRequestCreateOrConnectWithoutStudentPaymentInput[]
    createMany?: PaymentRequestCreateManyStudentPaymentInputEnvelope
    connect?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
  }

  export type PaymentRequestUpdateManyWithoutStudentPaymentNestedInput = {
    create?: XOR<PaymentRequestCreateWithoutStudentPaymentInput, PaymentRequestUncheckedCreateWithoutStudentPaymentInput> | PaymentRequestCreateWithoutStudentPaymentInput[] | PaymentRequestUncheckedCreateWithoutStudentPaymentInput[]
    connectOrCreate?: PaymentRequestCreateOrConnectWithoutStudentPaymentInput | PaymentRequestCreateOrConnectWithoutStudentPaymentInput[]
    upsert?: PaymentRequestUpsertWithWhereUniqueWithoutStudentPaymentInput | PaymentRequestUpsertWithWhereUniqueWithoutStudentPaymentInput[]
    createMany?: PaymentRequestCreateManyStudentPaymentInputEnvelope
    set?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    disconnect?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    delete?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    connect?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    update?: PaymentRequestUpdateWithWhereUniqueWithoutStudentPaymentInput | PaymentRequestUpdateWithWhereUniqueWithoutStudentPaymentInput[]
    updateMany?: PaymentRequestUpdateManyWithWhereWithoutStudentPaymentInput | PaymentRequestUpdateManyWithWhereWithoutStudentPaymentInput[]
    deleteMany?: PaymentRequestScalarWhereInput | PaymentRequestScalarWhereInput[]
  }

  export type BillAssignmentUpdateOneRequiredWithoutStudentPaymentsNestedInput = {
    create?: XOR<BillAssignmentCreateWithoutStudentPaymentsInput, BillAssignmentUncheckedCreateWithoutStudentPaymentsInput>
    connectOrCreate?: BillAssignmentCreateOrConnectWithoutStudentPaymentsInput
    upsert?: BillAssignmentUpsertWithoutStudentPaymentsInput
    connect?: BillAssignmentWhereUniqueInput
    update?: XOR<XOR<BillAssignmentUpdateToOneWithWhereWithoutStudentPaymentsInput, BillAssignmentUpdateWithoutStudentPaymentsInput>, BillAssignmentUncheckedUpdateWithoutStudentPaymentsInput>
  }

  export type StudentUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<StudentCreateWithoutPaymentsInput, StudentUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutPaymentsInput
    upsert?: StudentUpsertWithoutPaymentsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutPaymentsInput, StudentUpdateWithoutPaymentsInput>, StudentUncheckedUpdateWithoutPaymentsInput>
  }

  export type PaymentRequestUncheckedUpdateManyWithoutStudentPaymentNestedInput = {
    create?: XOR<PaymentRequestCreateWithoutStudentPaymentInput, PaymentRequestUncheckedCreateWithoutStudentPaymentInput> | PaymentRequestCreateWithoutStudentPaymentInput[] | PaymentRequestUncheckedCreateWithoutStudentPaymentInput[]
    connectOrCreate?: PaymentRequestCreateOrConnectWithoutStudentPaymentInput | PaymentRequestCreateOrConnectWithoutStudentPaymentInput[]
    upsert?: PaymentRequestUpsertWithWhereUniqueWithoutStudentPaymentInput | PaymentRequestUpsertWithWhereUniqueWithoutStudentPaymentInput[]
    createMany?: PaymentRequestCreateManyStudentPaymentInputEnvelope
    set?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    disconnect?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    delete?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    connect?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    update?: PaymentRequestUpdateWithWhereUniqueWithoutStudentPaymentInput | PaymentRequestUpdateWithWhereUniqueWithoutStudentPaymentInput[]
    updateMany?: PaymentRequestUpdateManyWithWhereWithoutStudentPaymentInput | PaymentRequestUpdateManyWithWhereWithoutStudentPaymentInput[]
    deleteMany?: PaymentRequestScalarWhereInput | PaymentRequestScalarWhereInput[]
  }

  export type BillAssignmentCreateNestedOneWithoutPaymentRequestsInput = {
    create?: XOR<BillAssignmentCreateWithoutPaymentRequestsInput, BillAssignmentUncheckedCreateWithoutPaymentRequestsInput>
    connectOrCreate?: BillAssignmentCreateOrConnectWithoutPaymentRequestsInput
    connect?: BillAssignmentWhereUniqueInput
  }

  export type BillCreateNestedOneWithoutPaymentRequestsInput = {
    create?: XOR<BillCreateWithoutPaymentRequestsInput, BillUncheckedCreateWithoutPaymentRequestsInput>
    connectOrCreate?: BillCreateOrConnectWithoutPaymentRequestsInput
    connect?: BillWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProcessedPaymentsInput = {
    create?: XOR<UserCreateWithoutProcessedPaymentsInput, UserUncheckedCreateWithoutProcessedPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProcessedPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutPaymentRequestsInput = {
    create?: XOR<StudentCreateWithoutPaymentRequestsInput, StudentUncheckedCreateWithoutPaymentRequestsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutPaymentRequestsInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentPaymentCreateNestedOneWithoutPaymentRequestsInput = {
    create?: XOR<StudentPaymentCreateWithoutPaymentRequestsInput, StudentPaymentUncheckedCreateWithoutPaymentRequestsInput>
    connectOrCreate?: StudentPaymentCreateOrConnectWithoutPaymentRequestsInput
    connect?: StudentPaymentWhereUniqueInput
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type BillAssignmentUpdateOneRequiredWithoutPaymentRequestsNestedInput = {
    create?: XOR<BillAssignmentCreateWithoutPaymentRequestsInput, BillAssignmentUncheckedCreateWithoutPaymentRequestsInput>
    connectOrCreate?: BillAssignmentCreateOrConnectWithoutPaymentRequestsInput
    upsert?: BillAssignmentUpsertWithoutPaymentRequestsInput
    connect?: BillAssignmentWhereUniqueInput
    update?: XOR<XOR<BillAssignmentUpdateToOneWithWhereWithoutPaymentRequestsInput, BillAssignmentUpdateWithoutPaymentRequestsInput>, BillAssignmentUncheckedUpdateWithoutPaymentRequestsInput>
  }

  export type BillUpdateOneRequiredWithoutPaymentRequestsNestedInput = {
    create?: XOR<BillCreateWithoutPaymentRequestsInput, BillUncheckedCreateWithoutPaymentRequestsInput>
    connectOrCreate?: BillCreateOrConnectWithoutPaymentRequestsInput
    upsert?: BillUpsertWithoutPaymentRequestsInput
    connect?: BillWhereUniqueInput
    update?: XOR<XOR<BillUpdateToOneWithWhereWithoutPaymentRequestsInput, BillUpdateWithoutPaymentRequestsInput>, BillUncheckedUpdateWithoutPaymentRequestsInput>
  }

  export type UserUpdateOneWithoutProcessedPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutProcessedPaymentsInput, UserUncheckedCreateWithoutProcessedPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProcessedPaymentsInput
    upsert?: UserUpsertWithoutProcessedPaymentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProcessedPaymentsInput, UserUpdateWithoutProcessedPaymentsInput>, UserUncheckedUpdateWithoutProcessedPaymentsInput>
  }

  export type StudentUpdateOneRequiredWithoutPaymentRequestsNestedInput = {
    create?: XOR<StudentCreateWithoutPaymentRequestsInput, StudentUncheckedCreateWithoutPaymentRequestsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutPaymentRequestsInput
    upsert?: StudentUpsertWithoutPaymentRequestsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutPaymentRequestsInput, StudentUpdateWithoutPaymentRequestsInput>, StudentUncheckedUpdateWithoutPaymentRequestsInput>
  }

  export type StudentPaymentUpdateOneWithoutPaymentRequestsNestedInput = {
    create?: XOR<StudentPaymentCreateWithoutPaymentRequestsInput, StudentPaymentUncheckedCreateWithoutPaymentRequestsInput>
    connectOrCreate?: StudentPaymentCreateOrConnectWithoutPaymentRequestsInput
    upsert?: StudentPaymentUpsertWithoutPaymentRequestsInput
    disconnect?: StudentPaymentWhereInput | boolean
    delete?: StudentPaymentWhereInput | boolean
    connect?: StudentPaymentWhereUniqueInput
    update?: XOR<XOR<StudentPaymentUpdateToOneWithWhereWithoutPaymentRequestsInput, StudentPaymentUpdateWithoutPaymentRequestsInput>, StudentPaymentUncheckedUpdateWithoutPaymentRequestsInput>
  }

  export type ClassCreateNestedManyWithoutLevelInput = {
    create?: XOR<ClassCreateWithoutLevelInput, ClassUncheckedCreateWithoutLevelInput> | ClassCreateWithoutLevelInput[] | ClassUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutLevelInput | ClassCreateOrConnectWithoutLevelInput[]
    createMany?: ClassCreateManyLevelInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type SchoolCreateNestedOneWithoutLevelsInput = {
    create?: XOR<SchoolCreateWithoutLevelsInput, SchoolUncheckedCreateWithoutLevelsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutLevelsInput
    connect?: SchoolWhereUniqueInput
  }

  export type SubjectCreateNestedManyWithoutLevelInput = {
    create?: XOR<SubjectCreateWithoutLevelInput, SubjectUncheckedCreateWithoutLevelInput> | SubjectCreateWithoutLevelInput[] | SubjectUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutLevelInput | SubjectCreateOrConnectWithoutLevelInput[]
    createMany?: SubjectCreateManyLevelInputEnvelope
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type ClassUncheckedCreateNestedManyWithoutLevelInput = {
    create?: XOR<ClassCreateWithoutLevelInput, ClassUncheckedCreateWithoutLevelInput> | ClassCreateWithoutLevelInput[] | ClassUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutLevelInput | ClassCreateOrConnectWithoutLevelInput[]
    createMany?: ClassCreateManyLevelInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type SubjectUncheckedCreateNestedManyWithoutLevelInput = {
    create?: XOR<SubjectCreateWithoutLevelInput, SubjectUncheckedCreateWithoutLevelInput> | SubjectCreateWithoutLevelInput[] | SubjectUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutLevelInput | SubjectCreateOrConnectWithoutLevelInput[]
    createMany?: SubjectCreateManyLevelInputEnvelope
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ClassUpdateManyWithoutLevelNestedInput = {
    create?: XOR<ClassCreateWithoutLevelInput, ClassUncheckedCreateWithoutLevelInput> | ClassCreateWithoutLevelInput[] | ClassUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutLevelInput | ClassCreateOrConnectWithoutLevelInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutLevelInput | ClassUpsertWithWhereUniqueWithoutLevelInput[]
    createMany?: ClassCreateManyLevelInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutLevelInput | ClassUpdateWithWhereUniqueWithoutLevelInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutLevelInput | ClassUpdateManyWithWhereWithoutLevelInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type SchoolUpdateOneRequiredWithoutLevelsNestedInput = {
    create?: XOR<SchoolCreateWithoutLevelsInput, SchoolUncheckedCreateWithoutLevelsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutLevelsInput
    upsert?: SchoolUpsertWithoutLevelsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutLevelsInput, SchoolUpdateWithoutLevelsInput>, SchoolUncheckedUpdateWithoutLevelsInput>
  }

  export type SubjectUpdateManyWithoutLevelNestedInput = {
    create?: XOR<SubjectCreateWithoutLevelInput, SubjectUncheckedCreateWithoutLevelInput> | SubjectCreateWithoutLevelInput[] | SubjectUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutLevelInput | SubjectCreateOrConnectWithoutLevelInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutLevelInput | SubjectUpsertWithWhereUniqueWithoutLevelInput[]
    createMany?: SubjectCreateManyLevelInputEnvelope
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutLevelInput | SubjectUpdateWithWhereUniqueWithoutLevelInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutLevelInput | SubjectUpdateManyWithWhereWithoutLevelInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type ClassUncheckedUpdateManyWithoutLevelNestedInput = {
    create?: XOR<ClassCreateWithoutLevelInput, ClassUncheckedCreateWithoutLevelInput> | ClassCreateWithoutLevelInput[] | ClassUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutLevelInput | ClassCreateOrConnectWithoutLevelInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutLevelInput | ClassUpsertWithWhereUniqueWithoutLevelInput[]
    createMany?: ClassCreateManyLevelInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutLevelInput | ClassUpdateWithWhereUniqueWithoutLevelInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutLevelInput | ClassUpdateManyWithWhereWithoutLevelInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type SubjectUncheckedUpdateManyWithoutLevelNestedInput = {
    create?: XOR<SubjectCreateWithoutLevelInput, SubjectUncheckedCreateWithoutLevelInput> | SubjectCreateWithoutLevelInput[] | SubjectUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutLevelInput | SubjectCreateOrConnectWithoutLevelInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutLevelInput | SubjectUpsertWithWhereUniqueWithoutLevelInput[]
    createMany?: SubjectCreateManyLevelInputEnvelope
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutLevelInput | SubjectUpdateWithWhereUniqueWithoutLevelInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutLevelInput | SubjectUpdateManyWithWhereWithoutLevelInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutActivityLogsInput = {
    create?: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutActivityLogsNestedInput = {
    create?: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogsInput
    upsert?: UserUpsertWithoutActivityLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivityLogsInput, UserUpdateWithoutActivityLogsInput>, UserUncheckedUpdateWithoutActivityLogsInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type ResultPeriodCreateNestedManyWithoutConfigurationInput = {
    create?: XOR<ResultPeriodCreateWithoutConfigurationInput, ResultPeriodUncheckedCreateWithoutConfigurationInput> | ResultPeriodCreateWithoutConfigurationInput[] | ResultPeriodUncheckedCreateWithoutConfigurationInput[]
    connectOrCreate?: ResultPeriodCreateOrConnectWithoutConfigurationInput | ResultPeriodCreateOrConnectWithoutConfigurationInput[]
    createMany?: ResultPeriodCreateManyConfigurationInputEnvelope
    connect?: ResultPeriodWhereUniqueInput | ResultPeriodWhereUniqueInput[]
  }

  export type AssessmentComponentCreateNestedManyWithoutConfigurationInput = {
    create?: XOR<AssessmentComponentCreateWithoutConfigurationInput, AssessmentComponentUncheckedCreateWithoutConfigurationInput> | AssessmentComponentCreateWithoutConfigurationInput[] | AssessmentComponentUncheckedCreateWithoutConfigurationInput[]
    connectOrCreate?: AssessmentComponentCreateOrConnectWithoutConfigurationInput | AssessmentComponentCreateOrConnectWithoutConfigurationInput[]
    createMany?: AssessmentComponentCreateManyConfigurationInputEnvelope
    connect?: AssessmentComponentWhereUniqueInput | AssessmentComponentWhereUniqueInput[]
  }

  export type GradingScaleCreateNestedManyWithoutConfigurationInput = {
    create?: XOR<GradingScaleCreateWithoutConfigurationInput, GradingScaleUncheckedCreateWithoutConfigurationInput> | GradingScaleCreateWithoutConfigurationInput[] | GradingScaleUncheckedCreateWithoutConfigurationInput[]
    connectOrCreate?: GradingScaleCreateOrConnectWithoutConfigurationInput | GradingScaleCreateOrConnectWithoutConfigurationInput[]
    createMany?: GradingScaleCreateManyConfigurationInputEnvelope
    connect?: GradingScaleWhereUniqueInput | GradingScaleWhereUniqueInput[]
  }

  export type SchoolCreateNestedOneWithoutResultConfigsInput = {
    create?: XOR<SchoolCreateWithoutResultConfigsInput, SchoolUncheckedCreateWithoutResultConfigsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutResultConfigsInput
    connect?: SchoolWhereUniqueInput
  }

  export type AcademicSessionCreateNestedOneWithoutResultConfigurationsInput = {
    create?: XOR<AcademicSessionCreateWithoutResultConfigurationsInput, AcademicSessionUncheckedCreateWithoutResultConfigurationsInput>
    connectOrCreate?: AcademicSessionCreateOrConnectWithoutResultConfigurationsInput
    connect?: AcademicSessionWhereUniqueInput
  }

  export type ResultPeriodUncheckedCreateNestedManyWithoutConfigurationInput = {
    create?: XOR<ResultPeriodCreateWithoutConfigurationInput, ResultPeriodUncheckedCreateWithoutConfigurationInput> | ResultPeriodCreateWithoutConfigurationInput[] | ResultPeriodUncheckedCreateWithoutConfigurationInput[]
    connectOrCreate?: ResultPeriodCreateOrConnectWithoutConfigurationInput | ResultPeriodCreateOrConnectWithoutConfigurationInput[]
    createMany?: ResultPeriodCreateManyConfigurationInputEnvelope
    connect?: ResultPeriodWhereUniqueInput | ResultPeriodWhereUniqueInput[]
  }

  export type AssessmentComponentUncheckedCreateNestedManyWithoutConfigurationInput = {
    create?: XOR<AssessmentComponentCreateWithoutConfigurationInput, AssessmentComponentUncheckedCreateWithoutConfigurationInput> | AssessmentComponentCreateWithoutConfigurationInput[] | AssessmentComponentUncheckedCreateWithoutConfigurationInput[]
    connectOrCreate?: AssessmentComponentCreateOrConnectWithoutConfigurationInput | AssessmentComponentCreateOrConnectWithoutConfigurationInput[]
    createMany?: AssessmentComponentCreateManyConfigurationInputEnvelope
    connect?: AssessmentComponentWhereUniqueInput | AssessmentComponentWhereUniqueInput[]
  }

  export type GradingScaleUncheckedCreateNestedManyWithoutConfigurationInput = {
    create?: XOR<GradingScaleCreateWithoutConfigurationInput, GradingScaleUncheckedCreateWithoutConfigurationInput> | GradingScaleCreateWithoutConfigurationInput[] | GradingScaleUncheckedCreateWithoutConfigurationInput[]
    connectOrCreate?: GradingScaleCreateOrConnectWithoutConfigurationInput | GradingScaleCreateOrConnectWithoutConfigurationInput[]
    createMany?: GradingScaleCreateManyConfigurationInputEnvelope
    connect?: GradingScaleWhereUniqueInput | GradingScaleWhereUniqueInput[]
  }

  export type ResultPeriodUpdateManyWithoutConfigurationNestedInput = {
    create?: XOR<ResultPeriodCreateWithoutConfigurationInput, ResultPeriodUncheckedCreateWithoutConfigurationInput> | ResultPeriodCreateWithoutConfigurationInput[] | ResultPeriodUncheckedCreateWithoutConfigurationInput[]
    connectOrCreate?: ResultPeriodCreateOrConnectWithoutConfigurationInput | ResultPeriodCreateOrConnectWithoutConfigurationInput[]
    upsert?: ResultPeriodUpsertWithWhereUniqueWithoutConfigurationInput | ResultPeriodUpsertWithWhereUniqueWithoutConfigurationInput[]
    createMany?: ResultPeriodCreateManyConfigurationInputEnvelope
    set?: ResultPeriodWhereUniqueInput | ResultPeriodWhereUniqueInput[]
    disconnect?: ResultPeriodWhereUniqueInput | ResultPeriodWhereUniqueInput[]
    delete?: ResultPeriodWhereUniqueInput | ResultPeriodWhereUniqueInput[]
    connect?: ResultPeriodWhereUniqueInput | ResultPeriodWhereUniqueInput[]
    update?: ResultPeriodUpdateWithWhereUniqueWithoutConfigurationInput | ResultPeriodUpdateWithWhereUniqueWithoutConfigurationInput[]
    updateMany?: ResultPeriodUpdateManyWithWhereWithoutConfigurationInput | ResultPeriodUpdateManyWithWhereWithoutConfigurationInput[]
    deleteMany?: ResultPeriodScalarWhereInput | ResultPeriodScalarWhereInput[]
  }

  export type AssessmentComponentUpdateManyWithoutConfigurationNestedInput = {
    create?: XOR<AssessmentComponentCreateWithoutConfigurationInput, AssessmentComponentUncheckedCreateWithoutConfigurationInput> | AssessmentComponentCreateWithoutConfigurationInput[] | AssessmentComponentUncheckedCreateWithoutConfigurationInput[]
    connectOrCreate?: AssessmentComponentCreateOrConnectWithoutConfigurationInput | AssessmentComponentCreateOrConnectWithoutConfigurationInput[]
    upsert?: AssessmentComponentUpsertWithWhereUniqueWithoutConfigurationInput | AssessmentComponentUpsertWithWhereUniqueWithoutConfigurationInput[]
    createMany?: AssessmentComponentCreateManyConfigurationInputEnvelope
    set?: AssessmentComponentWhereUniqueInput | AssessmentComponentWhereUniqueInput[]
    disconnect?: AssessmentComponentWhereUniqueInput | AssessmentComponentWhereUniqueInput[]
    delete?: AssessmentComponentWhereUniqueInput | AssessmentComponentWhereUniqueInput[]
    connect?: AssessmentComponentWhereUniqueInput | AssessmentComponentWhereUniqueInput[]
    update?: AssessmentComponentUpdateWithWhereUniqueWithoutConfigurationInput | AssessmentComponentUpdateWithWhereUniqueWithoutConfigurationInput[]
    updateMany?: AssessmentComponentUpdateManyWithWhereWithoutConfigurationInput | AssessmentComponentUpdateManyWithWhereWithoutConfigurationInput[]
    deleteMany?: AssessmentComponentScalarWhereInput | AssessmentComponentScalarWhereInput[]
  }

  export type GradingScaleUpdateManyWithoutConfigurationNestedInput = {
    create?: XOR<GradingScaleCreateWithoutConfigurationInput, GradingScaleUncheckedCreateWithoutConfigurationInput> | GradingScaleCreateWithoutConfigurationInput[] | GradingScaleUncheckedCreateWithoutConfigurationInput[]
    connectOrCreate?: GradingScaleCreateOrConnectWithoutConfigurationInput | GradingScaleCreateOrConnectWithoutConfigurationInput[]
    upsert?: GradingScaleUpsertWithWhereUniqueWithoutConfigurationInput | GradingScaleUpsertWithWhereUniqueWithoutConfigurationInput[]
    createMany?: GradingScaleCreateManyConfigurationInputEnvelope
    set?: GradingScaleWhereUniqueInput | GradingScaleWhereUniqueInput[]
    disconnect?: GradingScaleWhereUniqueInput | GradingScaleWhereUniqueInput[]
    delete?: GradingScaleWhereUniqueInput | GradingScaleWhereUniqueInput[]
    connect?: GradingScaleWhereUniqueInput | GradingScaleWhereUniqueInput[]
    update?: GradingScaleUpdateWithWhereUniqueWithoutConfigurationInput | GradingScaleUpdateWithWhereUniqueWithoutConfigurationInput[]
    updateMany?: GradingScaleUpdateManyWithWhereWithoutConfigurationInput | GradingScaleUpdateManyWithWhereWithoutConfigurationInput[]
    deleteMany?: GradingScaleScalarWhereInput | GradingScaleScalarWhereInput[]
  }

  export type SchoolUpdateOneRequiredWithoutResultConfigsNestedInput = {
    create?: XOR<SchoolCreateWithoutResultConfigsInput, SchoolUncheckedCreateWithoutResultConfigsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutResultConfigsInput
    upsert?: SchoolUpsertWithoutResultConfigsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutResultConfigsInput, SchoolUpdateWithoutResultConfigsInput>, SchoolUncheckedUpdateWithoutResultConfigsInput>
  }

  export type AcademicSessionUpdateOneRequiredWithoutResultConfigurationsNestedInput = {
    create?: XOR<AcademicSessionCreateWithoutResultConfigurationsInput, AcademicSessionUncheckedCreateWithoutResultConfigurationsInput>
    connectOrCreate?: AcademicSessionCreateOrConnectWithoutResultConfigurationsInput
    upsert?: AcademicSessionUpsertWithoutResultConfigurationsInput
    connect?: AcademicSessionWhereUniqueInput
    update?: XOR<XOR<AcademicSessionUpdateToOneWithWhereWithoutResultConfigurationsInput, AcademicSessionUpdateWithoutResultConfigurationsInput>, AcademicSessionUncheckedUpdateWithoutResultConfigurationsInput>
  }

  export type ResultPeriodUncheckedUpdateManyWithoutConfigurationNestedInput = {
    create?: XOR<ResultPeriodCreateWithoutConfigurationInput, ResultPeriodUncheckedCreateWithoutConfigurationInput> | ResultPeriodCreateWithoutConfigurationInput[] | ResultPeriodUncheckedCreateWithoutConfigurationInput[]
    connectOrCreate?: ResultPeriodCreateOrConnectWithoutConfigurationInput | ResultPeriodCreateOrConnectWithoutConfigurationInput[]
    upsert?: ResultPeriodUpsertWithWhereUniqueWithoutConfigurationInput | ResultPeriodUpsertWithWhereUniqueWithoutConfigurationInput[]
    createMany?: ResultPeriodCreateManyConfigurationInputEnvelope
    set?: ResultPeriodWhereUniqueInput | ResultPeriodWhereUniqueInput[]
    disconnect?: ResultPeriodWhereUniqueInput | ResultPeriodWhereUniqueInput[]
    delete?: ResultPeriodWhereUniqueInput | ResultPeriodWhereUniqueInput[]
    connect?: ResultPeriodWhereUniqueInput | ResultPeriodWhereUniqueInput[]
    update?: ResultPeriodUpdateWithWhereUniqueWithoutConfigurationInput | ResultPeriodUpdateWithWhereUniqueWithoutConfigurationInput[]
    updateMany?: ResultPeriodUpdateManyWithWhereWithoutConfigurationInput | ResultPeriodUpdateManyWithWhereWithoutConfigurationInput[]
    deleteMany?: ResultPeriodScalarWhereInput | ResultPeriodScalarWhereInput[]
  }

  export type AssessmentComponentUncheckedUpdateManyWithoutConfigurationNestedInput = {
    create?: XOR<AssessmentComponentCreateWithoutConfigurationInput, AssessmentComponentUncheckedCreateWithoutConfigurationInput> | AssessmentComponentCreateWithoutConfigurationInput[] | AssessmentComponentUncheckedCreateWithoutConfigurationInput[]
    connectOrCreate?: AssessmentComponentCreateOrConnectWithoutConfigurationInput | AssessmentComponentCreateOrConnectWithoutConfigurationInput[]
    upsert?: AssessmentComponentUpsertWithWhereUniqueWithoutConfigurationInput | AssessmentComponentUpsertWithWhereUniqueWithoutConfigurationInput[]
    createMany?: AssessmentComponentCreateManyConfigurationInputEnvelope
    set?: AssessmentComponentWhereUniqueInput | AssessmentComponentWhereUniqueInput[]
    disconnect?: AssessmentComponentWhereUniqueInput | AssessmentComponentWhereUniqueInput[]
    delete?: AssessmentComponentWhereUniqueInput | AssessmentComponentWhereUniqueInput[]
    connect?: AssessmentComponentWhereUniqueInput | AssessmentComponentWhereUniqueInput[]
    update?: AssessmentComponentUpdateWithWhereUniqueWithoutConfigurationInput | AssessmentComponentUpdateWithWhereUniqueWithoutConfigurationInput[]
    updateMany?: AssessmentComponentUpdateManyWithWhereWithoutConfigurationInput | AssessmentComponentUpdateManyWithWhereWithoutConfigurationInput[]
    deleteMany?: AssessmentComponentScalarWhereInput | AssessmentComponentScalarWhereInput[]
  }

  export type GradingScaleUncheckedUpdateManyWithoutConfigurationNestedInput = {
    create?: XOR<GradingScaleCreateWithoutConfigurationInput, GradingScaleUncheckedCreateWithoutConfigurationInput> | GradingScaleCreateWithoutConfigurationInput[] | GradingScaleUncheckedCreateWithoutConfigurationInput[]
    connectOrCreate?: GradingScaleCreateOrConnectWithoutConfigurationInput | GradingScaleCreateOrConnectWithoutConfigurationInput[]
    upsert?: GradingScaleUpsertWithWhereUniqueWithoutConfigurationInput | GradingScaleUpsertWithWhereUniqueWithoutConfigurationInput[]
    createMany?: GradingScaleCreateManyConfigurationInputEnvelope
    set?: GradingScaleWhereUniqueInput | GradingScaleWhereUniqueInput[]
    disconnect?: GradingScaleWhereUniqueInput | GradingScaleWhereUniqueInput[]
    delete?: GradingScaleWhereUniqueInput | GradingScaleWhereUniqueInput[]
    connect?: GradingScaleWhereUniqueInput | GradingScaleWhereUniqueInput[]
    update?: GradingScaleUpdateWithWhereUniqueWithoutConfigurationInput | GradingScaleUpdateWithWhereUniqueWithoutConfigurationInput[]
    updateMany?: GradingScaleUpdateManyWithWhereWithoutConfigurationInput | GradingScaleUpdateManyWithWhereWithoutConfigurationInput[]
    deleteMany?: GradingScaleScalarWhereInput | GradingScaleScalarWhereInput[]
  }

  export type ResultConfigurationCreateNestedOneWithoutPeriodsInput = {
    create?: XOR<ResultConfigurationCreateWithoutPeriodsInput, ResultConfigurationUncheckedCreateWithoutPeriodsInput>
    connectOrCreate?: ResultConfigurationCreateOrConnectWithoutPeriodsInput
    connect?: ResultConfigurationWhereUniqueInput
  }

  export type ResultCreateNestedManyWithoutPeriodInput = {
    create?: XOR<ResultCreateWithoutPeriodInput, ResultUncheckedCreateWithoutPeriodInput> | ResultCreateWithoutPeriodInput[] | ResultUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: ResultCreateOrConnectWithoutPeriodInput | ResultCreateOrConnectWithoutPeriodInput[]
    createMany?: ResultCreateManyPeriodInputEnvelope
    connect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
  }

  export type ResultUncheckedCreateNestedManyWithoutPeriodInput = {
    create?: XOR<ResultCreateWithoutPeriodInput, ResultUncheckedCreateWithoutPeriodInput> | ResultCreateWithoutPeriodInput[] | ResultUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: ResultCreateOrConnectWithoutPeriodInput | ResultCreateOrConnectWithoutPeriodInput[]
    createMany?: ResultCreateManyPeriodInputEnvelope
    connect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
  }

  export type ResultConfigurationUpdateOneRequiredWithoutPeriodsNestedInput = {
    create?: XOR<ResultConfigurationCreateWithoutPeriodsInput, ResultConfigurationUncheckedCreateWithoutPeriodsInput>
    connectOrCreate?: ResultConfigurationCreateOrConnectWithoutPeriodsInput
    upsert?: ResultConfigurationUpsertWithoutPeriodsInput
    connect?: ResultConfigurationWhereUniqueInput
    update?: XOR<XOR<ResultConfigurationUpdateToOneWithWhereWithoutPeriodsInput, ResultConfigurationUpdateWithoutPeriodsInput>, ResultConfigurationUncheckedUpdateWithoutPeriodsInput>
  }

  export type ResultUpdateManyWithoutPeriodNestedInput = {
    create?: XOR<ResultCreateWithoutPeriodInput, ResultUncheckedCreateWithoutPeriodInput> | ResultCreateWithoutPeriodInput[] | ResultUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: ResultCreateOrConnectWithoutPeriodInput | ResultCreateOrConnectWithoutPeriodInput[]
    upsert?: ResultUpsertWithWhereUniqueWithoutPeriodInput | ResultUpsertWithWhereUniqueWithoutPeriodInput[]
    createMany?: ResultCreateManyPeriodInputEnvelope
    set?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    disconnect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    delete?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    connect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    update?: ResultUpdateWithWhereUniqueWithoutPeriodInput | ResultUpdateWithWhereUniqueWithoutPeriodInput[]
    updateMany?: ResultUpdateManyWithWhereWithoutPeriodInput | ResultUpdateManyWithWhereWithoutPeriodInput[]
    deleteMany?: ResultScalarWhereInput | ResultScalarWhereInput[]
  }

  export type ResultUncheckedUpdateManyWithoutPeriodNestedInput = {
    create?: XOR<ResultCreateWithoutPeriodInput, ResultUncheckedCreateWithoutPeriodInput> | ResultCreateWithoutPeriodInput[] | ResultUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: ResultCreateOrConnectWithoutPeriodInput | ResultCreateOrConnectWithoutPeriodInput[]
    upsert?: ResultUpsertWithWhereUniqueWithoutPeriodInput | ResultUpsertWithWhereUniqueWithoutPeriodInput[]
    createMany?: ResultCreateManyPeriodInputEnvelope
    set?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    disconnect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    delete?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    connect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    update?: ResultUpdateWithWhereUniqueWithoutPeriodInput | ResultUpdateWithWhereUniqueWithoutPeriodInput[]
    updateMany?: ResultUpdateManyWithWhereWithoutPeriodInput | ResultUpdateManyWithWhereWithoutPeriodInput[]
    deleteMany?: ResultScalarWhereInput | ResultScalarWhereInput[]
  }

  export type ResultConfigurationCreateNestedOneWithoutAssessmentComponentsInput = {
    create?: XOR<ResultConfigurationCreateWithoutAssessmentComponentsInput, ResultConfigurationUncheckedCreateWithoutAssessmentComponentsInput>
    connectOrCreate?: ResultConfigurationCreateOrConnectWithoutAssessmentComponentsInput
    connect?: ResultConfigurationWhereUniqueInput
  }

  export type ComponentScoreCreateNestedManyWithoutComponentInput = {
    create?: XOR<ComponentScoreCreateWithoutComponentInput, ComponentScoreUncheckedCreateWithoutComponentInput> | ComponentScoreCreateWithoutComponentInput[] | ComponentScoreUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: ComponentScoreCreateOrConnectWithoutComponentInput | ComponentScoreCreateOrConnectWithoutComponentInput[]
    createMany?: ComponentScoreCreateManyComponentInputEnvelope
    connect?: ComponentScoreWhereUniqueInput | ComponentScoreWhereUniqueInput[]
  }

  export type ComponentScoreUncheckedCreateNestedManyWithoutComponentInput = {
    create?: XOR<ComponentScoreCreateWithoutComponentInput, ComponentScoreUncheckedCreateWithoutComponentInput> | ComponentScoreCreateWithoutComponentInput[] | ComponentScoreUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: ComponentScoreCreateOrConnectWithoutComponentInput | ComponentScoreCreateOrConnectWithoutComponentInput[]
    createMany?: ComponentScoreCreateManyComponentInputEnvelope
    connect?: ComponentScoreWhereUniqueInput | ComponentScoreWhereUniqueInput[]
  }

  export type ResultConfigurationUpdateOneRequiredWithoutAssessmentComponentsNestedInput = {
    create?: XOR<ResultConfigurationCreateWithoutAssessmentComponentsInput, ResultConfigurationUncheckedCreateWithoutAssessmentComponentsInput>
    connectOrCreate?: ResultConfigurationCreateOrConnectWithoutAssessmentComponentsInput
    upsert?: ResultConfigurationUpsertWithoutAssessmentComponentsInput
    connect?: ResultConfigurationWhereUniqueInput
    update?: XOR<XOR<ResultConfigurationUpdateToOneWithWhereWithoutAssessmentComponentsInput, ResultConfigurationUpdateWithoutAssessmentComponentsInput>, ResultConfigurationUncheckedUpdateWithoutAssessmentComponentsInput>
  }

  export type ComponentScoreUpdateManyWithoutComponentNestedInput = {
    create?: XOR<ComponentScoreCreateWithoutComponentInput, ComponentScoreUncheckedCreateWithoutComponentInput> | ComponentScoreCreateWithoutComponentInput[] | ComponentScoreUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: ComponentScoreCreateOrConnectWithoutComponentInput | ComponentScoreCreateOrConnectWithoutComponentInput[]
    upsert?: ComponentScoreUpsertWithWhereUniqueWithoutComponentInput | ComponentScoreUpsertWithWhereUniqueWithoutComponentInput[]
    createMany?: ComponentScoreCreateManyComponentInputEnvelope
    set?: ComponentScoreWhereUniqueInput | ComponentScoreWhereUniqueInput[]
    disconnect?: ComponentScoreWhereUniqueInput | ComponentScoreWhereUniqueInput[]
    delete?: ComponentScoreWhereUniqueInput | ComponentScoreWhereUniqueInput[]
    connect?: ComponentScoreWhereUniqueInput | ComponentScoreWhereUniqueInput[]
    update?: ComponentScoreUpdateWithWhereUniqueWithoutComponentInput | ComponentScoreUpdateWithWhereUniqueWithoutComponentInput[]
    updateMany?: ComponentScoreUpdateManyWithWhereWithoutComponentInput | ComponentScoreUpdateManyWithWhereWithoutComponentInput[]
    deleteMany?: ComponentScoreScalarWhereInput | ComponentScoreScalarWhereInput[]
  }

  export type ComponentScoreUncheckedUpdateManyWithoutComponentNestedInput = {
    create?: XOR<ComponentScoreCreateWithoutComponentInput, ComponentScoreUncheckedCreateWithoutComponentInput> | ComponentScoreCreateWithoutComponentInput[] | ComponentScoreUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: ComponentScoreCreateOrConnectWithoutComponentInput | ComponentScoreCreateOrConnectWithoutComponentInput[]
    upsert?: ComponentScoreUpsertWithWhereUniqueWithoutComponentInput | ComponentScoreUpsertWithWhereUniqueWithoutComponentInput[]
    createMany?: ComponentScoreCreateManyComponentInputEnvelope
    set?: ComponentScoreWhereUniqueInput | ComponentScoreWhereUniqueInput[]
    disconnect?: ComponentScoreWhereUniqueInput | ComponentScoreWhereUniqueInput[]
    delete?: ComponentScoreWhereUniqueInput | ComponentScoreWhereUniqueInput[]
    connect?: ComponentScoreWhereUniqueInput | ComponentScoreWhereUniqueInput[]
    update?: ComponentScoreUpdateWithWhereUniqueWithoutComponentInput | ComponentScoreUpdateWithWhereUniqueWithoutComponentInput[]
    updateMany?: ComponentScoreUpdateManyWithWhereWithoutComponentInput | ComponentScoreUpdateManyWithWhereWithoutComponentInput[]
    deleteMany?: ComponentScoreScalarWhereInput | ComponentScoreScalarWhereInput[]
  }

  export type ResultConfigurationCreateNestedOneWithoutGradingScaleInput = {
    create?: XOR<ResultConfigurationCreateWithoutGradingScaleInput, ResultConfigurationUncheckedCreateWithoutGradingScaleInput>
    connectOrCreate?: ResultConfigurationCreateOrConnectWithoutGradingScaleInput
    connect?: ResultConfigurationWhereUniqueInput
  }

  export type ResultConfigurationUpdateOneRequiredWithoutGradingScaleNestedInput = {
    create?: XOR<ResultConfigurationCreateWithoutGradingScaleInput, ResultConfigurationUncheckedCreateWithoutGradingScaleInput>
    connectOrCreate?: ResultConfigurationCreateOrConnectWithoutGradingScaleInput
    upsert?: ResultConfigurationUpsertWithoutGradingScaleInput
    connect?: ResultConfigurationWhereUniqueInput
    update?: XOR<XOR<ResultConfigurationUpdateToOneWithWhereWithoutGradingScaleInput, ResultConfigurationUpdateWithoutGradingScaleInput>, ResultConfigurationUncheckedUpdateWithoutGradingScaleInput>
  }

  export type AssessmentComponentCreateNestedOneWithoutScoresInput = {
    create?: XOR<AssessmentComponentCreateWithoutScoresInput, AssessmentComponentUncheckedCreateWithoutScoresInput>
    connectOrCreate?: AssessmentComponentCreateOrConnectWithoutScoresInput
    connect?: AssessmentComponentWhereUniqueInput
  }

  export type ResultCreateNestedOneWithoutComponentScoresInput = {
    create?: XOR<ResultCreateWithoutComponentScoresInput, ResultUncheckedCreateWithoutComponentScoresInput>
    connectOrCreate?: ResultCreateOrConnectWithoutComponentScoresInput
    connect?: ResultWhereUniqueInput
  }

  export type AssessmentComponentUpdateOneRequiredWithoutScoresNestedInput = {
    create?: XOR<AssessmentComponentCreateWithoutScoresInput, AssessmentComponentUncheckedCreateWithoutScoresInput>
    connectOrCreate?: AssessmentComponentCreateOrConnectWithoutScoresInput
    upsert?: AssessmentComponentUpsertWithoutScoresInput
    connect?: AssessmentComponentWhereUniqueInput
    update?: XOR<XOR<AssessmentComponentUpdateToOneWithWhereWithoutScoresInput, AssessmentComponentUpdateWithoutScoresInput>, AssessmentComponentUncheckedUpdateWithoutScoresInput>
  }

  export type ResultUpdateOneRequiredWithoutComponentScoresNestedInput = {
    create?: XOR<ResultCreateWithoutComponentScoresInput, ResultUncheckedCreateWithoutComponentScoresInput>
    connectOrCreate?: ResultCreateOrConnectWithoutComponentScoresInput
    upsert?: ResultUpsertWithoutComponentScoresInput
    connect?: ResultWhereUniqueInput
    update?: XOR<XOR<ResultUpdateToOneWithWhereWithoutComponentScoresInput, ResultUpdateWithoutComponentScoresInput>, ResultUncheckedUpdateWithoutComponentScoresInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumAdminTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminType | EnumAdminTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdminType[] | ListEnumAdminTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminType[] | ListEnumAdminTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminTypeFilter<$PrismaModel> | $Enums.AdminType
  }

  export type NestedEnumAdminTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminType | EnumAdminTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdminType[] | ListEnumAdminTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminType[] | ListEnumAdminTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminTypeWithAggregatesFilter<$PrismaModel> | $Enums.AdminType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminTypeFilter<$PrismaModel>
    _max?: NestedEnumAdminTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumEnrollmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EnrollmentStatus | EnumEnrollmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnrollmentStatus[] | ListEnumEnrollmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnrollmentStatus[] | ListEnumEnrollmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnrollmentStatusFilter<$PrismaModel> | $Enums.EnrollmentStatus
  }

  export type NestedEnumEnrollmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnrollmentStatus | EnumEnrollmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnrollmentStatus[] | ListEnumEnrollmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnrollmentStatus[] | ListEnumEnrollmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnrollmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.EnrollmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnrollmentStatusFilter<$PrismaModel>
    _max?: NestedEnumEnrollmentStatusFilter<$PrismaModel>
  }

  export type NestedEnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumBillAssignmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BillAssignmentType | EnumBillAssignmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BillAssignmentType[] | ListEnumBillAssignmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillAssignmentType[] | ListEnumBillAssignmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBillAssignmentTypeFilter<$PrismaModel> | $Enums.BillAssignmentType
  }

  export type NestedEnumBillStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BillStatus | EnumBillStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BillStatus[] | ListEnumBillStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillStatus[] | ListEnumBillStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBillStatusFilter<$PrismaModel> | $Enums.BillStatus
  }

  export type NestedEnumBillAssignmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BillAssignmentType | EnumBillAssignmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BillAssignmentType[] | ListEnumBillAssignmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillAssignmentType[] | ListEnumBillAssignmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBillAssignmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.BillAssignmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBillAssignmentTypeFilter<$PrismaModel>
    _max?: NestedEnumBillAssignmentTypeFilter<$PrismaModel>
  }

  export type NestedEnumBillStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BillStatus | EnumBillStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BillStatus[] | ListEnumBillStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillStatus[] | ListEnumBillStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBillStatusWithAggregatesFilter<$PrismaModel> | $Enums.BillStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBillStatusFilter<$PrismaModel>
    _max?: NestedEnumBillStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AdminCreateWithoutUserInput = {
    id?: string
    adminType: $Enums.AdminType
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUncheckedCreateWithoutUserInput = {
    id?: string
    adminType: $Enums.AdminType
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminCreateOrConnectWithoutUserInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
  }

  export type ParentCreateWithoutUserInput = {
    id?: string
    occupation?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    alternatePhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: StudentParentCreateNestedManyWithoutParentInput
  }

  export type ParentUncheckedCreateWithoutUserInput = {
    id?: string
    occupation?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    alternatePhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: StudentParentUncheckedCreateNestedManyWithoutParentInput
  }

  export type ParentCreateOrConnectWithoutUserInput = {
    where: ParentWhereUniqueInput
    create: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
  }

  export type PaymentRequestCreateWithoutProcessedByInput = {
    id?: string
    amount: number
    receiptUrl?: string | null
    status?: $Enums.PaymentStatus
    notes?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    billAssignment: BillAssignmentCreateNestedOneWithoutPaymentRequestsInput
    bill: BillCreateNestedOneWithoutPaymentRequestsInput
    student: StudentCreateNestedOneWithoutPaymentRequestsInput
    studentPayment?: StudentPaymentCreateNestedOneWithoutPaymentRequestsInput
  }

  export type PaymentRequestUncheckedCreateWithoutProcessedByInput = {
    id?: string
    billId: string
    billAssignmentId: string
    studentPaymentId?: string | null
    studentId: string
    amount: number
    receiptUrl?: string | null
    status?: $Enums.PaymentStatus
    notes?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentRequestCreateOrConnectWithoutProcessedByInput = {
    where: PaymentRequestWhereUniqueInput
    create: XOR<PaymentRequestCreateWithoutProcessedByInput, PaymentRequestUncheckedCreateWithoutProcessedByInput>
  }

  export type PaymentRequestCreateManyProcessedByInputEnvelope = {
    data: PaymentRequestCreateManyProcessedByInput | PaymentRequestCreateManyProcessedByInput[]
    skipDuplicates?: boolean
  }

  export type ResultCreateWithoutApprovedByInput = {
    id?: string
    total: number
    grade: string
    remark: string
    cumulativeAverage?: number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: string | null
    adminComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    componentScores?: ComponentScoreCreateNestedManyWithoutResultInput
    student: StudentCreateNestedOneWithoutResultsInput
    subject: SubjectCreateNestedOneWithoutResultsInput
    period: ResultPeriodCreateNestedOneWithoutResultsInput
    session: AcademicSessionCreateNestedOneWithoutResultsInput
  }

  export type ResultUncheckedCreateWithoutApprovedByInput = {
    id?: string
    studentId: string
    subjectId: string
    periodId: string
    sessionId: string
    total: number
    grade: string
    remark: string
    cumulativeAverage?: number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: string | null
    adminComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    componentScores?: ComponentScoreUncheckedCreateNestedManyWithoutResultInput
  }

  export type ResultCreateOrConnectWithoutApprovedByInput = {
    where: ResultWhereUniqueInput
    create: XOR<ResultCreateWithoutApprovedByInput, ResultUncheckedCreateWithoutApprovedByInput>
  }

  export type ResultCreateManyApprovedByInputEnvelope = {
    data: ResultCreateManyApprovedByInput | ResultCreateManyApprovedByInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutUserInput = {
    id?: string
    admissionDate?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    religion?: string | null
    bloodGroup?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classId?: string | null
    attendance?: AttendanceCreateNestedManyWithoutStudentInput
    paymentRequests?: PaymentRequestCreateNestedManyWithoutStudentInput
    results?: ResultCreateNestedManyWithoutStudentInput
    department?: DepartmentCreateNestedOneWithoutStudentsInput
    classes?: StudentClassCreateNestedManyWithoutStudentInput
    parents?: StudentParentCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutUserInput = {
    id?: string
    admissionDate?: Date | string | null
    departmentId?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    religion?: string | null
    bloodGroup?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classId?: string | null
    attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    paymentRequests?: PaymentRequestUncheckedCreateNestedManyWithoutStudentInput
    results?: ResultUncheckedCreateNestedManyWithoutStudentInput
    classes?: StudentClassUncheckedCreateNestedManyWithoutStudentInput
    parents?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentUncheckedCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutUserInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
  }

  export type TeacherCreateWithoutUserInput = {
    id?: string
    employeeId?: string | null
    qualifications?: string | null
    specialization?: string | null
    joiningDate?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    emergencyContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassCreateNestedManyWithoutTeacherInput
    subjects?: SubjectTeacherCreateNestedManyWithoutTeacherInput
    department?: DepartmentCreateNestedOneWithoutTeachersInput
  }

  export type TeacherUncheckedCreateWithoutUserInput = {
    id?: string
    employeeId?: string | null
    qualifications?: string | null
    specialization?: string | null
    joiningDate?: Date | string | null
    departmentId?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    emergencyContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    subjects?: SubjectTeacherUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutUserInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
  }

  export type SchoolCreateWithoutUsersInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email: string
    logo?: string | null
    subdomain: string
    primaryColor?: string | null
    secondaryColor?: string | null
    shortName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: AcademicSessionCreateNestedManyWithoutSchoolInput
    bills?: BillCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    departments?: DepartmentCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    paymentAccounts?: PaymentAccountCreateNestedManyWithoutSchoolInput
    levels?: SchoolLevelCreateNestedManyWithoutSchoolInput
    subjects?: SubjectCreateNestedManyWithoutSchoolInput
    resultConfigs?: ResultConfigurationCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email: string
    logo?: string | null
    subdomain: string
    primaryColor?: string | null
    secondaryColor?: string | null
    shortName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: AcademicSessionUncheckedCreateNestedManyWithoutSchoolInput
    bills?: BillUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    paymentAccounts?: PaymentAccountUncheckedCreateNestedManyWithoutSchoolInput
    levels?: SchoolLevelUncheckedCreateNestedManyWithoutSchoolInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutSchoolInput
    resultConfigs?: ResultConfigurationUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutUsersInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
  }

  export type UserActivityLogCreateWithoutUserInput = {
    id?: string
    page: string
    action: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UserActivityLogUncheckedCreateWithoutUserInput = {
    id?: string
    page: string
    action: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UserActivityLogCreateOrConnectWithoutUserInput = {
    where: UserActivityLogWhereUniqueInput
    create: XOR<UserActivityLogCreateWithoutUserInput, UserActivityLogUncheckedCreateWithoutUserInput>
  }

  export type UserActivityLogCreateManyUserInputEnvelope = {
    data: UserActivityLogCreateManyUserInput | UserActivityLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type AdminUpsertWithoutUserInput = {
    update: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutUserInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
  }

  export type AdminUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminType?: EnumAdminTypeFieldUpdateOperationsInput | $Enums.AdminType
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminType?: EnumAdminTypeFieldUpdateOperationsInput | $Enums.AdminType
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentUpsertWithoutUserInput = {
    update: XOR<ParentUpdateWithoutUserInput, ParentUncheckedUpdateWithoutUserInput>
    create: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    where?: ParentWhereInput
  }

  export type ParentUpdateToOneWithWhereWithoutUserInput = {
    where?: ParentWhereInput
    data: XOR<ParentUpdateWithoutUserInput, ParentUncheckedUpdateWithoutUserInput>
  }

  export type ParentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: StudentParentUpdateManyWithoutParentNestedInput
  }

  export type ParentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: StudentParentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type PaymentRequestUpsertWithWhereUniqueWithoutProcessedByInput = {
    where: PaymentRequestWhereUniqueInput
    update: XOR<PaymentRequestUpdateWithoutProcessedByInput, PaymentRequestUncheckedUpdateWithoutProcessedByInput>
    create: XOR<PaymentRequestCreateWithoutProcessedByInput, PaymentRequestUncheckedCreateWithoutProcessedByInput>
  }

  export type PaymentRequestUpdateWithWhereUniqueWithoutProcessedByInput = {
    where: PaymentRequestWhereUniqueInput
    data: XOR<PaymentRequestUpdateWithoutProcessedByInput, PaymentRequestUncheckedUpdateWithoutProcessedByInput>
  }

  export type PaymentRequestUpdateManyWithWhereWithoutProcessedByInput = {
    where: PaymentRequestScalarWhereInput
    data: XOR<PaymentRequestUpdateManyMutationInput, PaymentRequestUncheckedUpdateManyWithoutProcessedByInput>
  }

  export type PaymentRequestScalarWhereInput = {
    AND?: PaymentRequestScalarWhereInput | PaymentRequestScalarWhereInput[]
    OR?: PaymentRequestScalarWhereInput[]
    NOT?: PaymentRequestScalarWhereInput | PaymentRequestScalarWhereInput[]
    id?: StringFilter<"PaymentRequest"> | string
    billId?: StringFilter<"PaymentRequest"> | string
    billAssignmentId?: StringFilter<"PaymentRequest"> | string
    studentPaymentId?: StringNullableFilter<"PaymentRequest"> | string | null
    studentId?: StringFilter<"PaymentRequest"> | string
    amount?: FloatFilter<"PaymentRequest"> | number
    receiptUrl?: StringNullableFilter<"PaymentRequest"> | string | null
    status?: EnumPaymentStatusFilter<"PaymentRequest"> | $Enums.PaymentStatus
    notes?: StringNullableFilter<"PaymentRequest"> | string | null
    processedById?: StringNullableFilter<"PaymentRequest"> | string | null
    processedAt?: DateTimeNullableFilter<"PaymentRequest"> | Date | string | null
    createdAt?: DateTimeFilter<"PaymentRequest"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentRequest"> | Date | string
  }

  export type ResultUpsertWithWhereUniqueWithoutApprovedByInput = {
    where: ResultWhereUniqueInput
    update: XOR<ResultUpdateWithoutApprovedByInput, ResultUncheckedUpdateWithoutApprovedByInput>
    create: XOR<ResultCreateWithoutApprovedByInput, ResultUncheckedCreateWithoutApprovedByInput>
  }

  export type ResultUpdateWithWhereUniqueWithoutApprovedByInput = {
    where: ResultWhereUniqueInput
    data: XOR<ResultUpdateWithoutApprovedByInput, ResultUncheckedUpdateWithoutApprovedByInput>
  }

  export type ResultUpdateManyWithWhereWithoutApprovedByInput = {
    where: ResultScalarWhereInput
    data: XOR<ResultUpdateManyMutationInput, ResultUncheckedUpdateManyWithoutApprovedByInput>
  }

  export type ResultScalarWhereInput = {
    AND?: ResultScalarWhereInput | ResultScalarWhereInput[]
    OR?: ResultScalarWhereInput[]
    NOT?: ResultScalarWhereInput | ResultScalarWhereInput[]
    id?: StringFilter<"Result"> | string
    studentId?: StringFilter<"Result"> | string
    subjectId?: StringFilter<"Result"> | string
    periodId?: StringFilter<"Result"> | string
    sessionId?: StringFilter<"Result"> | string
    total?: FloatFilter<"Result"> | number
    grade?: StringFilter<"Result"> | string
    remark?: StringFilter<"Result"> | string
    cumulativeAverage?: FloatNullableFilter<"Result"> | number | null
    affectiveTraits?: JsonNullableFilter<"Result">
    psychomotorSkills?: JsonNullableFilter<"Result">
    customFields?: JsonNullableFilter<"Result">
    teacherComment?: StringNullableFilter<"Result"> | string | null
    adminComment?: StringNullableFilter<"Result"> | string | null
    approvedById?: StringNullableFilter<"Result"> | string | null
    createdAt?: DateTimeFilter<"Result"> | Date | string
    updatedAt?: DateTimeFilter<"Result"> | Date | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type StudentUpsertWithoutUserInput = {
    update: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutUserInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
  }

  export type StudentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    paymentRequests?: PaymentRequestUpdateManyWithoutStudentNestedInput
    results?: ResultUpdateManyWithoutStudentNestedInput
    department?: DepartmentUpdateOneWithoutStudentsNestedInput
    classes?: StudentClassUpdateManyWithoutStudentNestedInput
    parents?: StudentParentUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    paymentRequests?: PaymentRequestUncheckedUpdateManyWithoutStudentNestedInput
    results?: ResultUncheckedUpdateManyWithoutStudentNestedInput
    classes?: StudentClassUncheckedUpdateManyWithoutStudentNestedInput
    parents?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUncheckedUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type TeacherUpsertWithoutUserInput = {
    update: XOR<TeacherUpdateWithoutUserInput, TeacherUncheckedUpdateWithoutUserInput>
    create: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutUserInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutUserInput, TeacherUncheckedUpdateWithoutUserInput>
  }

  export type TeacherUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassUpdateManyWithoutTeacherNestedInput
    subjects?: SubjectTeacherUpdateManyWithoutTeacherNestedInput
    department?: DepartmentUpdateOneWithoutTeachersNestedInput
  }

  export type TeacherUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    subjects?: SubjectTeacherUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type SchoolUpsertWithoutUsersInput = {
    update: XOR<SchoolUpdateWithoutUsersInput, SchoolUncheckedUpdateWithoutUsersInput>
    create: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutUsersInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutUsersInput, SchoolUncheckedUpdateWithoutUsersInput>
  }

  export type SchoolUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: StringFieldUpdateOperationsInput | string
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    shortName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: AcademicSessionUpdateManyWithoutSchoolNestedInput
    bills?: BillUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    departments?: DepartmentUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    paymentAccounts?: PaymentAccountUpdateManyWithoutSchoolNestedInput
    levels?: SchoolLevelUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUpdateManyWithoutSchoolNestedInput
    resultConfigs?: ResultConfigurationUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: StringFieldUpdateOperationsInput | string
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    shortName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: AcademicSessionUncheckedUpdateManyWithoutSchoolNestedInput
    bills?: BillUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    paymentAccounts?: PaymentAccountUncheckedUpdateManyWithoutSchoolNestedInput
    levels?: SchoolLevelUncheckedUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutSchoolNestedInput
    resultConfigs?: ResultConfigurationUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type UserActivityLogUpsertWithWhereUniqueWithoutUserInput = {
    where: UserActivityLogWhereUniqueInput
    update: XOR<UserActivityLogUpdateWithoutUserInput, UserActivityLogUncheckedUpdateWithoutUserInput>
    create: XOR<UserActivityLogCreateWithoutUserInput, UserActivityLogUncheckedCreateWithoutUserInput>
  }

  export type UserActivityLogUpdateWithWhereUniqueWithoutUserInput = {
    where: UserActivityLogWhereUniqueInput
    data: XOR<UserActivityLogUpdateWithoutUserInput, UserActivityLogUncheckedUpdateWithoutUserInput>
  }

  export type UserActivityLogUpdateManyWithWhereWithoutUserInput = {
    where: UserActivityLogScalarWhereInput
    data: XOR<UserActivityLogUpdateManyMutationInput, UserActivityLogUncheckedUpdateManyWithoutUserInput>
  }

  export type UserActivityLogScalarWhereInput = {
    AND?: UserActivityLogScalarWhereInput | UserActivityLogScalarWhereInput[]
    OR?: UserActivityLogScalarWhereInput[]
    NOT?: UserActivityLogScalarWhereInput | UserActivityLogScalarWhereInput[]
    id?: StringFilter<"UserActivityLog"> | string
    userId?: StringFilter<"UserActivityLog"> | string
    page?: StringFilter<"UserActivityLog"> | string
    action?: StringFilter<"UserActivityLog"> | string
    metadata?: JsonNullableFilter<"UserActivityLog">
    createdAt?: DateTimeFilter<"UserActivityLog"> | Date | string
  }

  export type UserCreateWithoutAdminInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.UserRole
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    parent?: ParentCreateNestedOneWithoutUserInput
    processedPayments?: PaymentRequestCreateNestedManyWithoutProcessedByInput
    approvedResults?: ResultCreateNestedManyWithoutApprovedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    activityLogs?: UserActivityLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdminInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.UserRole
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    schoolId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    parent?: ParentUncheckedCreateNestedOneWithoutUserInput
    processedPayments?: PaymentRequestUncheckedCreateNestedManyWithoutProcessedByInput
    approvedResults?: ResultUncheckedCreateNestedManyWithoutApprovedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    activityLogs?: UserActivityLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdminInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
  }

  export type UserUpsertWithoutAdminInput = {
    update: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
  }

  export type UserUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    parent?: ParentUpdateOneWithoutUserNestedInput
    processedPayments?: PaymentRequestUpdateManyWithoutProcessedByNestedInput
    approvedResults?: ResultUpdateManyWithoutApprovedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    activityLogs?: UserActivityLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    parent?: ParentUncheckedUpdateOneWithoutUserNestedInput
    processedPayments?: PaymentRequestUncheckedUpdateManyWithoutProcessedByNestedInput
    approvedResults?: ResultUncheckedUpdateManyWithoutApprovedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    activityLogs?: UserActivityLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ClassCreateWithoutTeacherInput = {
    id?: string
    name: string
    section?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    level?: SchoolLevelCreateNestedOneWithoutClassesInput
    school: SchoolCreateNestedOneWithoutClassesInput
    subjects?: ClassSubjectCreateNestedManyWithoutClassInput
    students?: StudentClassCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutTeacherInput = {
    id?: string
    name: string
    section?: string | null
    schoolId: string
    levelId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: ClassSubjectUncheckedCreateNestedManyWithoutClassInput
    students?: StudentClassUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutTeacherInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutTeacherInput, ClassUncheckedCreateWithoutTeacherInput>
  }

  export type ClassCreateManyTeacherInputEnvelope = {
    data: ClassCreateManyTeacherInput | ClassCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type SubjectTeacherCreateWithoutTeacherInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: SubjectCreateNestedOneWithoutTeachersInput
  }

  export type SubjectTeacherUncheckedCreateWithoutTeacherInput = {
    id?: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectTeacherCreateOrConnectWithoutTeacherInput = {
    where: SubjectTeacherWhereUniqueInput
    create: XOR<SubjectTeacherCreateWithoutTeacherInput, SubjectTeacherUncheckedCreateWithoutTeacherInput>
  }

  export type SubjectTeacherCreateManyTeacherInputEnvelope = {
    data: SubjectTeacherCreateManyTeacherInput | SubjectTeacherCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentCreateWithoutTeachersInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutDepartmentsInput
    students?: StudentCreateNestedManyWithoutDepartmentInput
    subjects?: SubjectCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutTeachersInput = {
    id?: string
    name: string
    description?: string | null
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutDepartmentInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutTeachersInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutTeachersInput, DepartmentUncheckedCreateWithoutTeachersInput>
  }

  export type UserCreateWithoutTeacherInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.UserRole
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    parent?: ParentCreateNestedOneWithoutUserInput
    processedPayments?: PaymentRequestCreateNestedManyWithoutProcessedByInput
    approvedResults?: ResultCreateNestedManyWithoutApprovedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    activityLogs?: UserActivityLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTeacherInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.UserRole
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    schoolId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    parent?: ParentUncheckedCreateNestedOneWithoutUserInput
    processedPayments?: PaymentRequestUncheckedCreateNestedManyWithoutProcessedByInput
    approvedResults?: ResultUncheckedCreateNestedManyWithoutApprovedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    activityLogs?: UserActivityLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTeacherInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeacherInput, UserUncheckedCreateWithoutTeacherInput>
  }

  export type ClassUpsertWithWhereUniqueWithoutTeacherInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutTeacherInput, ClassUncheckedUpdateWithoutTeacherInput>
    create: XOR<ClassCreateWithoutTeacherInput, ClassUncheckedCreateWithoutTeacherInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutTeacherInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutTeacherInput, ClassUncheckedUpdateWithoutTeacherInput>
  }

  export type ClassUpdateManyWithWhereWithoutTeacherInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutTeacherInput>
  }

  export type ClassScalarWhereInput = {
    AND?: ClassScalarWhereInput | ClassScalarWhereInput[]
    OR?: ClassScalarWhereInput[]
    NOT?: ClassScalarWhereInput | ClassScalarWhereInput[]
    id?: StringFilter<"Class"> | string
    name?: StringFilter<"Class"> | string
    section?: StringNullableFilter<"Class"> | string | null
    schoolId?: StringFilter<"Class"> | string
    teacherId?: StringNullableFilter<"Class"> | string | null
    levelId?: StringNullableFilter<"Class"> | string | null
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
  }

  export type SubjectTeacherUpsertWithWhereUniqueWithoutTeacherInput = {
    where: SubjectTeacherWhereUniqueInput
    update: XOR<SubjectTeacherUpdateWithoutTeacherInput, SubjectTeacherUncheckedUpdateWithoutTeacherInput>
    create: XOR<SubjectTeacherCreateWithoutTeacherInput, SubjectTeacherUncheckedCreateWithoutTeacherInput>
  }

  export type SubjectTeacherUpdateWithWhereUniqueWithoutTeacherInput = {
    where: SubjectTeacherWhereUniqueInput
    data: XOR<SubjectTeacherUpdateWithoutTeacherInput, SubjectTeacherUncheckedUpdateWithoutTeacherInput>
  }

  export type SubjectTeacherUpdateManyWithWhereWithoutTeacherInput = {
    where: SubjectTeacherScalarWhereInput
    data: XOR<SubjectTeacherUpdateManyMutationInput, SubjectTeacherUncheckedUpdateManyWithoutTeacherInput>
  }

  export type SubjectTeacherScalarWhereInput = {
    AND?: SubjectTeacherScalarWhereInput | SubjectTeacherScalarWhereInput[]
    OR?: SubjectTeacherScalarWhereInput[]
    NOT?: SubjectTeacherScalarWhereInput | SubjectTeacherScalarWhereInput[]
    id?: StringFilter<"SubjectTeacher"> | string
    subjectId?: StringFilter<"SubjectTeacher"> | string
    teacherId?: StringFilter<"SubjectTeacher"> | string
    createdAt?: DateTimeFilter<"SubjectTeacher"> | Date | string
    updatedAt?: DateTimeFilter<"SubjectTeacher"> | Date | string
  }

  export type DepartmentUpsertWithoutTeachersInput = {
    update: XOR<DepartmentUpdateWithoutTeachersInput, DepartmentUncheckedUpdateWithoutTeachersInput>
    create: XOR<DepartmentCreateWithoutTeachersInput, DepartmentUncheckedCreateWithoutTeachersInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutTeachersInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutTeachersInput, DepartmentUncheckedUpdateWithoutTeachersInput>
  }

  export type DepartmentUpdateWithoutTeachersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutDepartmentsNestedInput
    students?: StudentUpdateManyWithoutDepartmentNestedInput
    subjects?: SubjectUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutTeachersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutDepartmentNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type UserUpsertWithoutTeacherInput = {
    update: XOR<UserUpdateWithoutTeacherInput, UserUncheckedUpdateWithoutTeacherInput>
    create: XOR<UserCreateWithoutTeacherInput, UserUncheckedCreateWithoutTeacherInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeacherInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeacherInput, UserUncheckedUpdateWithoutTeacherInput>
  }

  export type UserUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    parent?: ParentUpdateOneWithoutUserNestedInput
    processedPayments?: PaymentRequestUpdateManyWithoutProcessedByNestedInput
    approvedResults?: ResultUpdateManyWithoutApprovedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    activityLogs?: UserActivityLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    parent?: ParentUncheckedUpdateOneWithoutUserNestedInput
    processedPayments?: PaymentRequestUncheckedUpdateManyWithoutProcessedByNestedInput
    approvedResults?: ResultUncheckedUpdateManyWithoutApprovedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    activityLogs?: UserActivityLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AttendanceCreateWithoutStudentInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    session: AcademicSessionCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateWithoutStudentInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    sessionId: string
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceCreateOrConnectWithoutStudentInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutStudentInput, AttendanceUncheckedCreateWithoutStudentInput>
  }

  export type AttendanceCreateManyStudentInputEnvelope = {
    data: AttendanceCreateManyStudentInput | AttendanceCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type PaymentRequestCreateWithoutStudentInput = {
    id?: string
    amount: number
    receiptUrl?: string | null
    status?: $Enums.PaymentStatus
    notes?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    billAssignment: BillAssignmentCreateNestedOneWithoutPaymentRequestsInput
    bill: BillCreateNestedOneWithoutPaymentRequestsInput
    processedBy?: UserCreateNestedOneWithoutProcessedPaymentsInput
    studentPayment?: StudentPaymentCreateNestedOneWithoutPaymentRequestsInput
  }

  export type PaymentRequestUncheckedCreateWithoutStudentInput = {
    id?: string
    billId: string
    billAssignmentId: string
    studentPaymentId?: string | null
    amount: number
    receiptUrl?: string | null
    status?: $Enums.PaymentStatus
    notes?: string | null
    processedById?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentRequestCreateOrConnectWithoutStudentInput = {
    where: PaymentRequestWhereUniqueInput
    create: XOR<PaymentRequestCreateWithoutStudentInput, PaymentRequestUncheckedCreateWithoutStudentInput>
  }

  export type PaymentRequestCreateManyStudentInputEnvelope = {
    data: PaymentRequestCreateManyStudentInput | PaymentRequestCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type ResultCreateWithoutStudentInput = {
    id?: string
    total: number
    grade: string
    remark: string
    cumulativeAverage?: number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: string | null
    adminComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    componentScores?: ComponentScoreCreateNestedManyWithoutResultInput
    subject: SubjectCreateNestedOneWithoutResultsInput
    period: ResultPeriodCreateNestedOneWithoutResultsInput
    session: AcademicSessionCreateNestedOneWithoutResultsInput
    approvedBy?: UserCreateNestedOneWithoutApprovedResultsInput
  }

  export type ResultUncheckedCreateWithoutStudentInput = {
    id?: string
    subjectId: string
    periodId: string
    sessionId: string
    total: number
    grade: string
    remark: string
    cumulativeAverage?: number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: string | null
    adminComment?: string | null
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    componentScores?: ComponentScoreUncheckedCreateNestedManyWithoutResultInput
  }

  export type ResultCreateOrConnectWithoutStudentInput = {
    where: ResultWhereUniqueInput
    create: XOR<ResultCreateWithoutStudentInput, ResultUncheckedCreateWithoutStudentInput>
  }

  export type ResultCreateManyStudentInputEnvelope = {
    data: ResultCreateManyStudentInput | ResultCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentCreateWithoutStudentsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutDepartmentsInput
    subjects?: SubjectCreateNestedManyWithoutDepartmentInput
    teachers?: TeacherCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutStudentsInput = {
    id?: string
    name: string
    description?: string | null
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: SubjectUncheckedCreateNestedManyWithoutDepartmentInput
    teachers?: TeacherUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutStudentsInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutStudentsInput, DepartmentUncheckedCreateWithoutStudentsInput>
  }

  export type UserCreateWithoutStudentInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.UserRole
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    parent?: ParentCreateNestedOneWithoutUserInput
    processedPayments?: PaymentRequestCreateNestedManyWithoutProcessedByInput
    approvedResults?: ResultCreateNestedManyWithoutApprovedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    activityLogs?: UserActivityLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStudentInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.UserRole
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    schoolId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    parent?: ParentUncheckedCreateNestedOneWithoutUserInput
    processedPayments?: PaymentRequestUncheckedCreateNestedManyWithoutProcessedByInput
    approvedResults?: ResultUncheckedCreateNestedManyWithoutApprovedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    activityLogs?: UserActivityLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStudentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
  }

  export type StudentClassCreateWithoutStudentInput = {
    id?: string
    rollNumber?: string | null
    status?: $Enums.EnrollmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutStudentsInput
    session: AcademicSessionCreateNestedOneWithoutStudentClassesInput
  }

  export type StudentClassUncheckedCreateWithoutStudentInput = {
    id?: string
    classId: string
    sessionId: string
    rollNumber?: string | null
    status?: $Enums.EnrollmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentClassCreateOrConnectWithoutStudentInput = {
    where: StudentClassWhereUniqueInput
    create: XOR<StudentClassCreateWithoutStudentInput, StudentClassUncheckedCreateWithoutStudentInput>
  }

  export type StudentClassCreateManyStudentInputEnvelope = {
    data: StudentClassCreateManyStudentInput | StudentClassCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentParentCreateWithoutStudentInput = {
    id?: string
    relation?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent: ParentCreateNestedOneWithoutChildrenInput
  }

  export type StudentParentUncheckedCreateWithoutStudentInput = {
    id?: string
    parentId: string
    relation?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentParentCreateOrConnectWithoutStudentInput = {
    where: StudentParentWhereUniqueInput
    create: XOR<StudentParentCreateWithoutStudentInput, StudentParentUncheckedCreateWithoutStudentInput>
  }

  export type StudentParentCreateManyStudentInputEnvelope = {
    data: StudentParentCreateManyStudentInput | StudentParentCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentPaymentCreateWithoutStudentInput = {
    id?: string
    amountPaid: number
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentRequests?: PaymentRequestCreateNestedManyWithoutStudentPaymentInput
    billAssignment: BillAssignmentCreateNestedOneWithoutStudentPaymentsInput
  }

  export type StudentPaymentUncheckedCreateWithoutStudentInput = {
    id?: string
    billAssignmentId: string
    amountPaid: number
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentRequests?: PaymentRequestUncheckedCreateNestedManyWithoutStudentPaymentInput
  }

  export type StudentPaymentCreateOrConnectWithoutStudentInput = {
    where: StudentPaymentWhereUniqueInput
    create: XOR<StudentPaymentCreateWithoutStudentInput, StudentPaymentUncheckedCreateWithoutStudentInput>
  }

  export type StudentPaymentCreateManyStudentInputEnvelope = {
    data: StudentPaymentCreateManyStudentInput | StudentPaymentCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentSubjectCreateWithoutStudentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: SubjectCreateNestedOneWithoutStudentsInput
  }

  export type StudentSubjectUncheckedCreateWithoutStudentInput = {
    id?: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSubjectCreateOrConnectWithoutStudentInput = {
    where: StudentSubjectWhereUniqueInput
    create: XOR<StudentSubjectCreateWithoutStudentInput, StudentSubjectUncheckedCreateWithoutStudentInput>
  }

  export type StudentSubjectCreateManyStudentInputEnvelope = {
    data: StudentSubjectCreateManyStudentInput | StudentSubjectCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceUpsertWithWhereUniqueWithoutStudentInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutStudentInput, AttendanceUncheckedUpdateWithoutStudentInput>
    create: XOR<AttendanceCreateWithoutStudentInput, AttendanceUncheckedCreateWithoutStudentInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutStudentInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutStudentInput, AttendanceUncheckedUpdateWithoutStudentInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutStudentInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutStudentInput>
  }

  export type AttendanceScalarWhereInput = {
    AND?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    OR?: AttendanceScalarWhereInput[]
    NOT?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    id?: StringFilter<"Attendance"> | string
    date?: DateTimeFilter<"Attendance"> | Date | string
    status?: EnumAttendanceStatusFilter<"Attendance"> | $Enums.AttendanceStatus
    studentId?: StringFilter<"Attendance"> | string
    sessionId?: StringFilter<"Attendance"> | string
    remarks?: StringNullableFilter<"Attendance"> | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
  }

  export type PaymentRequestUpsertWithWhereUniqueWithoutStudentInput = {
    where: PaymentRequestWhereUniqueInput
    update: XOR<PaymentRequestUpdateWithoutStudentInput, PaymentRequestUncheckedUpdateWithoutStudentInput>
    create: XOR<PaymentRequestCreateWithoutStudentInput, PaymentRequestUncheckedCreateWithoutStudentInput>
  }

  export type PaymentRequestUpdateWithWhereUniqueWithoutStudentInput = {
    where: PaymentRequestWhereUniqueInput
    data: XOR<PaymentRequestUpdateWithoutStudentInput, PaymentRequestUncheckedUpdateWithoutStudentInput>
  }

  export type PaymentRequestUpdateManyWithWhereWithoutStudentInput = {
    where: PaymentRequestScalarWhereInput
    data: XOR<PaymentRequestUpdateManyMutationInput, PaymentRequestUncheckedUpdateManyWithoutStudentInput>
  }

  export type ResultUpsertWithWhereUniqueWithoutStudentInput = {
    where: ResultWhereUniqueInput
    update: XOR<ResultUpdateWithoutStudentInput, ResultUncheckedUpdateWithoutStudentInput>
    create: XOR<ResultCreateWithoutStudentInput, ResultUncheckedCreateWithoutStudentInput>
  }

  export type ResultUpdateWithWhereUniqueWithoutStudentInput = {
    where: ResultWhereUniqueInput
    data: XOR<ResultUpdateWithoutStudentInput, ResultUncheckedUpdateWithoutStudentInput>
  }

  export type ResultUpdateManyWithWhereWithoutStudentInput = {
    where: ResultScalarWhereInput
    data: XOR<ResultUpdateManyMutationInput, ResultUncheckedUpdateManyWithoutStudentInput>
  }

  export type DepartmentUpsertWithoutStudentsInput = {
    update: XOR<DepartmentUpdateWithoutStudentsInput, DepartmentUncheckedUpdateWithoutStudentsInput>
    create: XOR<DepartmentCreateWithoutStudentsInput, DepartmentUncheckedCreateWithoutStudentsInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutStudentsInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutStudentsInput, DepartmentUncheckedUpdateWithoutStudentsInput>
  }

  export type DepartmentUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutDepartmentsNestedInput
    subjects?: SubjectUpdateManyWithoutDepartmentNestedInput
    teachers?: TeacherUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectUncheckedUpdateManyWithoutDepartmentNestedInput
    teachers?: TeacherUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type UserUpsertWithoutStudentInput = {
    update: XOR<UserUpdateWithoutStudentInput, UserUncheckedUpdateWithoutStudentInput>
    create: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStudentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStudentInput, UserUncheckedUpdateWithoutStudentInput>
  }

  export type UserUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    parent?: ParentUpdateOneWithoutUserNestedInput
    processedPayments?: PaymentRequestUpdateManyWithoutProcessedByNestedInput
    approvedResults?: ResultUpdateManyWithoutApprovedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    activityLogs?: UserActivityLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    parent?: ParentUncheckedUpdateOneWithoutUserNestedInput
    processedPayments?: PaymentRequestUncheckedUpdateManyWithoutProcessedByNestedInput
    approvedResults?: ResultUncheckedUpdateManyWithoutApprovedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    activityLogs?: UserActivityLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StudentClassUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentClassWhereUniqueInput
    update: XOR<StudentClassUpdateWithoutStudentInput, StudentClassUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentClassCreateWithoutStudentInput, StudentClassUncheckedCreateWithoutStudentInput>
  }

  export type StudentClassUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentClassWhereUniqueInput
    data: XOR<StudentClassUpdateWithoutStudentInput, StudentClassUncheckedUpdateWithoutStudentInput>
  }

  export type StudentClassUpdateManyWithWhereWithoutStudentInput = {
    where: StudentClassScalarWhereInput
    data: XOR<StudentClassUpdateManyMutationInput, StudentClassUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentClassScalarWhereInput = {
    AND?: StudentClassScalarWhereInput | StudentClassScalarWhereInput[]
    OR?: StudentClassScalarWhereInput[]
    NOT?: StudentClassScalarWhereInput | StudentClassScalarWhereInput[]
    id?: StringFilter<"StudentClass"> | string
    studentId?: StringFilter<"StudentClass"> | string
    classId?: StringFilter<"StudentClass"> | string
    sessionId?: StringFilter<"StudentClass"> | string
    rollNumber?: StringNullableFilter<"StudentClass"> | string | null
    status?: EnumEnrollmentStatusFilter<"StudentClass"> | $Enums.EnrollmentStatus
    createdAt?: DateTimeFilter<"StudentClass"> | Date | string
    updatedAt?: DateTimeFilter<"StudentClass"> | Date | string
  }

  export type StudentParentUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentParentWhereUniqueInput
    update: XOR<StudentParentUpdateWithoutStudentInput, StudentParentUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentParentCreateWithoutStudentInput, StudentParentUncheckedCreateWithoutStudentInput>
  }

  export type StudentParentUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentParentWhereUniqueInput
    data: XOR<StudentParentUpdateWithoutStudentInput, StudentParentUncheckedUpdateWithoutStudentInput>
  }

  export type StudentParentUpdateManyWithWhereWithoutStudentInput = {
    where: StudentParentScalarWhereInput
    data: XOR<StudentParentUpdateManyMutationInput, StudentParentUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentParentScalarWhereInput = {
    AND?: StudentParentScalarWhereInput | StudentParentScalarWhereInput[]
    OR?: StudentParentScalarWhereInput[]
    NOT?: StudentParentScalarWhereInput | StudentParentScalarWhereInput[]
    id?: StringFilter<"StudentParent"> | string
    studentId?: StringFilter<"StudentParent"> | string
    parentId?: StringFilter<"StudentParent"> | string
    relation?: StringNullableFilter<"StudentParent"> | string | null
    isPrimary?: BoolFilter<"StudentParent"> | boolean
    createdAt?: DateTimeFilter<"StudentParent"> | Date | string
    updatedAt?: DateTimeFilter<"StudentParent"> | Date | string
  }

  export type StudentPaymentUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentPaymentWhereUniqueInput
    update: XOR<StudentPaymentUpdateWithoutStudentInput, StudentPaymentUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentPaymentCreateWithoutStudentInput, StudentPaymentUncheckedCreateWithoutStudentInput>
  }

  export type StudentPaymentUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentPaymentWhereUniqueInput
    data: XOR<StudentPaymentUpdateWithoutStudentInput, StudentPaymentUncheckedUpdateWithoutStudentInput>
  }

  export type StudentPaymentUpdateManyWithWhereWithoutStudentInput = {
    where: StudentPaymentScalarWhereInput
    data: XOR<StudentPaymentUpdateManyMutationInput, StudentPaymentUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentPaymentScalarWhereInput = {
    AND?: StudentPaymentScalarWhereInput | StudentPaymentScalarWhereInput[]
    OR?: StudentPaymentScalarWhereInput[]
    NOT?: StudentPaymentScalarWhereInput | StudentPaymentScalarWhereInput[]
    id?: StringFilter<"StudentPayment"> | string
    billAssignmentId?: StringFilter<"StudentPayment"> | string
    studentId?: StringFilter<"StudentPayment"> | string
    amountPaid?: FloatFilter<"StudentPayment"> | number
    createdAt?: DateTimeFilter<"StudentPayment"> | Date | string
    updatedAt?: DateTimeFilter<"StudentPayment"> | Date | string
  }

  export type StudentSubjectUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentSubjectWhereUniqueInput
    update: XOR<StudentSubjectUpdateWithoutStudentInput, StudentSubjectUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentSubjectCreateWithoutStudentInput, StudentSubjectUncheckedCreateWithoutStudentInput>
  }

  export type StudentSubjectUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentSubjectWhereUniqueInput
    data: XOR<StudentSubjectUpdateWithoutStudentInput, StudentSubjectUncheckedUpdateWithoutStudentInput>
  }

  export type StudentSubjectUpdateManyWithWhereWithoutStudentInput = {
    where: StudentSubjectScalarWhereInput
    data: XOR<StudentSubjectUpdateManyMutationInput, StudentSubjectUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentSubjectScalarWhereInput = {
    AND?: StudentSubjectScalarWhereInput | StudentSubjectScalarWhereInput[]
    OR?: StudentSubjectScalarWhereInput[]
    NOT?: StudentSubjectScalarWhereInput | StudentSubjectScalarWhereInput[]
    id?: StringFilter<"StudentSubject"> | string
    studentId?: StringFilter<"StudentSubject"> | string
    subjectId?: StringFilter<"StudentSubject"> | string
    createdAt?: DateTimeFilter<"StudentSubject"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSubject"> | Date | string
  }

  export type UserCreateWithoutParentInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.UserRole
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    processedPayments?: PaymentRequestCreateNestedManyWithoutProcessedByInput
    approvedResults?: ResultCreateNestedManyWithoutApprovedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    activityLogs?: UserActivityLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutParentInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.UserRole
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    schoolId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    processedPayments?: PaymentRequestUncheckedCreateNestedManyWithoutProcessedByInput
    approvedResults?: ResultUncheckedCreateNestedManyWithoutApprovedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    activityLogs?: UserActivityLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutParentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutParentInput, UserUncheckedCreateWithoutParentInput>
  }

  export type StudentParentCreateWithoutParentInput = {
    id?: string
    relation?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutParentsInput
  }

  export type StudentParentUncheckedCreateWithoutParentInput = {
    id?: string
    studentId: string
    relation?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentParentCreateOrConnectWithoutParentInput = {
    where: StudentParentWhereUniqueInput
    create: XOR<StudentParentCreateWithoutParentInput, StudentParentUncheckedCreateWithoutParentInput>
  }

  export type StudentParentCreateManyParentInputEnvelope = {
    data: StudentParentCreateManyParentInput | StudentParentCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutParentInput = {
    update: XOR<UserUpdateWithoutParentInput, UserUncheckedUpdateWithoutParentInput>
    create: XOR<UserCreateWithoutParentInput, UserUncheckedCreateWithoutParentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutParentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutParentInput, UserUncheckedUpdateWithoutParentInput>
  }

  export type UserUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    processedPayments?: PaymentRequestUpdateManyWithoutProcessedByNestedInput
    approvedResults?: ResultUpdateManyWithoutApprovedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    activityLogs?: UserActivityLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    processedPayments?: PaymentRequestUncheckedUpdateManyWithoutProcessedByNestedInput
    approvedResults?: ResultUncheckedUpdateManyWithoutApprovedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    activityLogs?: UserActivityLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StudentParentUpsertWithWhereUniqueWithoutParentInput = {
    where: StudentParentWhereUniqueInput
    update: XOR<StudentParentUpdateWithoutParentInput, StudentParentUncheckedUpdateWithoutParentInput>
    create: XOR<StudentParentCreateWithoutParentInput, StudentParentUncheckedCreateWithoutParentInput>
  }

  export type StudentParentUpdateWithWhereUniqueWithoutParentInput = {
    where: StudentParentWhereUniqueInput
    data: XOR<StudentParentUpdateWithoutParentInput, StudentParentUncheckedUpdateWithoutParentInput>
  }

  export type StudentParentUpdateManyWithWhereWithoutParentInput = {
    where: StudentParentScalarWhereInput
    data: XOR<StudentParentUpdateManyMutationInput, StudentParentUncheckedUpdateManyWithoutParentInput>
  }

  export type AcademicSessionCreateWithoutSchoolInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    attendance?: AttendanceCreateNestedManyWithoutSessionInput
    results?: ResultCreateNestedManyWithoutSessionInput
    studentClasses?: StudentClassCreateNestedManyWithoutSessionInput
    resultConfigurations?: ResultConfigurationCreateNestedManyWithoutSessionInput
  }

  export type AcademicSessionUncheckedCreateWithoutSchoolInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    attendance?: AttendanceUncheckedCreateNestedManyWithoutSessionInput
    results?: ResultUncheckedCreateNestedManyWithoutSessionInput
    studentClasses?: StudentClassUncheckedCreateNestedManyWithoutSessionInput
    resultConfigurations?: ResultConfigurationUncheckedCreateNestedManyWithoutSessionInput
  }

  export type AcademicSessionCreateOrConnectWithoutSchoolInput = {
    where: AcademicSessionWhereUniqueInput
    create: XOR<AcademicSessionCreateWithoutSchoolInput, AcademicSessionUncheckedCreateWithoutSchoolInput>
  }

  export type AcademicSessionCreateManySchoolInputEnvelope = {
    data: AcademicSessionCreateManySchoolInput | AcademicSessionCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type BillCreateWithoutSchoolInput = {
    id?: string
    name: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    account: PaymentAccountCreateNestedOneWithoutBillsInput
    assignments?: BillAssignmentCreateNestedManyWithoutBillInput
    items?: BillItemCreateNestedManyWithoutBillInput
    paymentRequests?: PaymentRequestCreateNestedManyWithoutBillInput
  }

  export type BillUncheckedCreateWithoutSchoolInput = {
    id?: string
    name: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accountId: string
    assignments?: BillAssignmentUncheckedCreateNestedManyWithoutBillInput
    items?: BillItemUncheckedCreateNestedManyWithoutBillInput
    paymentRequests?: PaymentRequestUncheckedCreateNestedManyWithoutBillInput
  }

  export type BillCreateOrConnectWithoutSchoolInput = {
    where: BillWhereUniqueInput
    create: XOR<BillCreateWithoutSchoolInput, BillUncheckedCreateWithoutSchoolInput>
  }

  export type BillCreateManySchoolInputEnvelope = {
    data: BillCreateManySchoolInput | BillCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type ClassCreateWithoutSchoolInput = {
    id?: string
    name: string
    section?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    level?: SchoolLevelCreateNestedOneWithoutClassesInput
    teacher?: TeacherCreateNestedOneWithoutClassesInput
    subjects?: ClassSubjectCreateNestedManyWithoutClassInput
    students?: StudentClassCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutSchoolInput = {
    id?: string
    name: string
    section?: string | null
    teacherId?: string | null
    levelId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: ClassSubjectUncheckedCreateNestedManyWithoutClassInput
    students?: StudentClassUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutSchoolInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput>
  }

  export type ClassCreateManySchoolInputEnvelope = {
    data: ClassCreateManySchoolInput | ClassCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentCreateWithoutSchoolInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentCreateNestedManyWithoutDepartmentInput
    subjects?: SubjectCreateNestedManyWithoutDepartmentInput
    teachers?: TeacherCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutSchoolInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutDepartmentInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutDepartmentInput
    teachers?: TeacherUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutSchoolInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutSchoolInput, DepartmentUncheckedCreateWithoutSchoolInput>
  }

  export type DepartmentCreateManySchoolInputEnvelope = {
    data: DepartmentCreateManySchoolInput | DepartmentCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutSchoolInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    location?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUncheckedCreateWithoutSchoolInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    location?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventCreateOrConnectWithoutSchoolInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutSchoolInput, EventUncheckedCreateWithoutSchoolInput>
  }

  export type EventCreateManySchoolInputEnvelope = {
    data: EventCreateManySchoolInput | EventCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type PaymentAccountCreateWithoutSchoolInput = {
    id?: string
    name: string
    accountNo: string
    bankName: string
    branchCode?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bills?: BillCreateNestedManyWithoutAccountInput
  }

  export type PaymentAccountUncheckedCreateWithoutSchoolInput = {
    id?: string
    name: string
    accountNo: string
    bankName: string
    branchCode?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bills?: BillUncheckedCreateNestedManyWithoutAccountInput
  }

  export type PaymentAccountCreateOrConnectWithoutSchoolInput = {
    where: PaymentAccountWhereUniqueInput
    create: XOR<PaymentAccountCreateWithoutSchoolInput, PaymentAccountUncheckedCreateWithoutSchoolInput>
  }

  export type PaymentAccountCreateManySchoolInputEnvelope = {
    data: PaymentAccountCreateManySchoolInput | PaymentAccountCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type SchoolLevelCreateWithoutSchoolInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassCreateNestedManyWithoutLevelInput
    subjects?: SubjectCreateNestedManyWithoutLevelInput
  }

  export type SchoolLevelUncheckedCreateWithoutSchoolInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassUncheckedCreateNestedManyWithoutLevelInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutLevelInput
  }

  export type SchoolLevelCreateOrConnectWithoutSchoolInput = {
    where: SchoolLevelWhereUniqueInput
    create: XOR<SchoolLevelCreateWithoutSchoolInput, SchoolLevelUncheckedCreateWithoutSchoolInput>
  }

  export type SchoolLevelCreateManySchoolInputEnvelope = {
    data: SchoolLevelCreateManySchoolInput | SchoolLevelCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type SubjectCreateWithoutSchoolInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassSubjectCreateNestedManyWithoutSubjectInput
    results?: ResultCreateNestedManyWithoutSubjectInput
    students?: StudentSubjectCreateNestedManyWithoutSubjectInput
    department?: DepartmentCreateNestedOneWithoutSubjectsInput
    level?: SchoolLevelCreateNestedOneWithoutSubjectsInput
    teachers?: SubjectTeacherCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutSchoolInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    departmentId?: string | null
    levelId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassSubjectUncheckedCreateNestedManyWithoutSubjectInput
    results?: ResultUncheckedCreateNestedManyWithoutSubjectInput
    students?: StudentSubjectUncheckedCreateNestedManyWithoutSubjectInput
    teachers?: SubjectTeacherUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutSchoolInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutSchoolInput, SubjectUncheckedCreateWithoutSchoolInput>
  }

  export type SubjectCreateManySchoolInputEnvelope = {
    data: SubjectCreateManySchoolInput | SubjectCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutSchoolInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.UserRole
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    parent?: ParentCreateNestedOneWithoutUserInput
    processedPayments?: PaymentRequestCreateNestedManyWithoutProcessedByInput
    approvedResults?: ResultCreateNestedManyWithoutApprovedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    activityLogs?: UserActivityLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSchoolInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.UserRole
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    parent?: ParentUncheckedCreateNestedOneWithoutUserInput
    processedPayments?: PaymentRequestUncheckedCreateNestedManyWithoutProcessedByInput
    approvedResults?: ResultUncheckedCreateNestedManyWithoutApprovedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    activityLogs?: UserActivityLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSchoolInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput>
  }

  export type UserCreateManySchoolInputEnvelope = {
    data: UserCreateManySchoolInput | UserCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type ResultConfigurationCreateWithoutSchoolInput = {
    id?: string
    cumulativeEnabled?: boolean
    cumulativeMethod?: string
    showCumulativePerTerm?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    periods?: ResultPeriodCreateNestedManyWithoutConfigurationInput
    assessmentComponents?: AssessmentComponentCreateNestedManyWithoutConfigurationInput
    gradingScale?: GradingScaleCreateNestedManyWithoutConfigurationInput
    session: AcademicSessionCreateNestedOneWithoutResultConfigurationsInput
  }

  export type ResultConfigurationUncheckedCreateWithoutSchoolInput = {
    id?: string
    sessionId: string
    cumulativeEnabled?: boolean
    cumulativeMethod?: string
    showCumulativePerTerm?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    periods?: ResultPeriodUncheckedCreateNestedManyWithoutConfigurationInput
    assessmentComponents?: AssessmentComponentUncheckedCreateNestedManyWithoutConfigurationInput
    gradingScale?: GradingScaleUncheckedCreateNestedManyWithoutConfigurationInput
  }

  export type ResultConfigurationCreateOrConnectWithoutSchoolInput = {
    where: ResultConfigurationWhereUniqueInput
    create: XOR<ResultConfigurationCreateWithoutSchoolInput, ResultConfigurationUncheckedCreateWithoutSchoolInput>
  }

  export type ResultConfigurationCreateManySchoolInputEnvelope = {
    data: ResultConfigurationCreateManySchoolInput | ResultConfigurationCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type AcademicSessionUpsertWithWhereUniqueWithoutSchoolInput = {
    where: AcademicSessionWhereUniqueInput
    update: XOR<AcademicSessionUpdateWithoutSchoolInput, AcademicSessionUncheckedUpdateWithoutSchoolInput>
    create: XOR<AcademicSessionCreateWithoutSchoolInput, AcademicSessionUncheckedCreateWithoutSchoolInput>
  }

  export type AcademicSessionUpdateWithWhereUniqueWithoutSchoolInput = {
    where: AcademicSessionWhereUniqueInput
    data: XOR<AcademicSessionUpdateWithoutSchoolInput, AcademicSessionUncheckedUpdateWithoutSchoolInput>
  }

  export type AcademicSessionUpdateManyWithWhereWithoutSchoolInput = {
    where: AcademicSessionScalarWhereInput
    data: XOR<AcademicSessionUpdateManyMutationInput, AcademicSessionUncheckedUpdateManyWithoutSchoolInput>
  }

  export type AcademicSessionScalarWhereInput = {
    AND?: AcademicSessionScalarWhereInput | AcademicSessionScalarWhereInput[]
    OR?: AcademicSessionScalarWhereInput[]
    NOT?: AcademicSessionScalarWhereInput | AcademicSessionScalarWhereInput[]
    id?: StringFilter<"AcademicSession"> | string
    name?: StringFilter<"AcademicSession"> | string
    startDate?: DateTimeFilter<"AcademicSession"> | Date | string
    endDate?: DateTimeFilter<"AcademicSession"> | Date | string
    isCurrent?: BoolFilter<"AcademicSession"> | boolean
    schoolId?: StringFilter<"AcademicSession"> | string
    createdAt?: DateTimeFilter<"AcademicSession"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicSession"> | Date | string
  }

  export type BillUpsertWithWhereUniqueWithoutSchoolInput = {
    where: BillWhereUniqueInput
    update: XOR<BillUpdateWithoutSchoolInput, BillUncheckedUpdateWithoutSchoolInput>
    create: XOR<BillCreateWithoutSchoolInput, BillUncheckedCreateWithoutSchoolInput>
  }

  export type BillUpdateWithWhereUniqueWithoutSchoolInput = {
    where: BillWhereUniqueInput
    data: XOR<BillUpdateWithoutSchoolInput, BillUncheckedUpdateWithoutSchoolInput>
  }

  export type BillUpdateManyWithWhereWithoutSchoolInput = {
    where: BillScalarWhereInput
    data: XOR<BillUpdateManyMutationInput, BillUncheckedUpdateManyWithoutSchoolInput>
  }

  export type BillScalarWhereInput = {
    AND?: BillScalarWhereInput | BillScalarWhereInput[]
    OR?: BillScalarWhereInput[]
    NOT?: BillScalarWhereInput | BillScalarWhereInput[]
    id?: StringFilter<"Bill"> | string
    name?: StringFilter<"Bill"> | string
    amount?: FloatFilter<"Bill"> | number
    createdAt?: DateTimeFilter<"Bill"> | Date | string
    updatedAt?: DateTimeFilter<"Bill"> | Date | string
    schoolId?: StringFilter<"Bill"> | string
    accountId?: StringFilter<"Bill"> | string
  }

  export type ClassUpsertWithWhereUniqueWithoutSchoolInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutSchoolInput, ClassUncheckedUpdateWithoutSchoolInput>
    create: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutSchoolInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutSchoolInput, ClassUncheckedUpdateWithoutSchoolInput>
  }

  export type ClassUpdateManyWithWhereWithoutSchoolInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutSchoolInput>
  }

  export type DepartmentUpsertWithWhereUniqueWithoutSchoolInput = {
    where: DepartmentWhereUniqueInput
    update: XOR<DepartmentUpdateWithoutSchoolInput, DepartmentUncheckedUpdateWithoutSchoolInput>
    create: XOR<DepartmentCreateWithoutSchoolInput, DepartmentUncheckedCreateWithoutSchoolInput>
  }

  export type DepartmentUpdateWithWhereUniqueWithoutSchoolInput = {
    where: DepartmentWhereUniqueInput
    data: XOR<DepartmentUpdateWithoutSchoolInput, DepartmentUncheckedUpdateWithoutSchoolInput>
  }

  export type DepartmentUpdateManyWithWhereWithoutSchoolInput = {
    where: DepartmentScalarWhereInput
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyWithoutSchoolInput>
  }

  export type DepartmentScalarWhereInput = {
    AND?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    OR?: DepartmentScalarWhereInput[]
    NOT?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    id?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    description?: StringNullableFilter<"Department"> | string | null
    schoolId?: StringFilter<"Department"> | string
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
  }

  export type EventUpsertWithWhereUniqueWithoutSchoolInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutSchoolInput, EventUncheckedUpdateWithoutSchoolInput>
    create: XOR<EventCreateWithoutSchoolInput, EventUncheckedCreateWithoutSchoolInput>
  }

  export type EventUpdateWithWhereUniqueWithoutSchoolInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutSchoolInput, EventUncheckedUpdateWithoutSchoolInput>
  }

  export type EventUpdateManyWithWhereWithoutSchoolInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutSchoolInput>
  }

  export type EventScalarWhereInput = {
    AND?: EventScalarWhereInput | EventScalarWhereInput[]
    OR?: EventScalarWhereInput[]
    NOT?: EventScalarWhereInput | EventScalarWhereInput[]
    id?: StringFilter<"Event"> | string
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    startDate?: DateTimeFilter<"Event"> | Date | string
    endDate?: DateTimeNullableFilter<"Event"> | Date | string | null
    location?: StringNullableFilter<"Event"> | string | null
    isPublic?: BoolFilter<"Event"> | boolean
    schoolId?: StringFilter<"Event"> | string
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
  }

  export type PaymentAccountUpsertWithWhereUniqueWithoutSchoolInput = {
    where: PaymentAccountWhereUniqueInput
    update: XOR<PaymentAccountUpdateWithoutSchoolInput, PaymentAccountUncheckedUpdateWithoutSchoolInput>
    create: XOR<PaymentAccountCreateWithoutSchoolInput, PaymentAccountUncheckedCreateWithoutSchoolInput>
  }

  export type PaymentAccountUpdateWithWhereUniqueWithoutSchoolInput = {
    where: PaymentAccountWhereUniqueInput
    data: XOR<PaymentAccountUpdateWithoutSchoolInput, PaymentAccountUncheckedUpdateWithoutSchoolInput>
  }

  export type PaymentAccountUpdateManyWithWhereWithoutSchoolInput = {
    where: PaymentAccountScalarWhereInput
    data: XOR<PaymentAccountUpdateManyMutationInput, PaymentAccountUncheckedUpdateManyWithoutSchoolInput>
  }

  export type PaymentAccountScalarWhereInput = {
    AND?: PaymentAccountScalarWhereInput | PaymentAccountScalarWhereInput[]
    OR?: PaymentAccountScalarWhereInput[]
    NOT?: PaymentAccountScalarWhereInput | PaymentAccountScalarWhereInput[]
    id?: StringFilter<"PaymentAccount"> | string
    name?: StringFilter<"PaymentAccount"> | string
    accountNo?: StringFilter<"PaymentAccount"> | string
    bankName?: StringFilter<"PaymentAccount"> | string
    branchCode?: StringNullableFilter<"PaymentAccount"> | string | null
    description?: StringNullableFilter<"PaymentAccount"> | string | null
    isActive?: BoolFilter<"PaymentAccount"> | boolean
    schoolId?: StringFilter<"PaymentAccount"> | string
    createdAt?: DateTimeFilter<"PaymentAccount"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentAccount"> | Date | string
  }

  export type SchoolLevelUpsertWithWhereUniqueWithoutSchoolInput = {
    where: SchoolLevelWhereUniqueInput
    update: XOR<SchoolLevelUpdateWithoutSchoolInput, SchoolLevelUncheckedUpdateWithoutSchoolInput>
    create: XOR<SchoolLevelCreateWithoutSchoolInput, SchoolLevelUncheckedCreateWithoutSchoolInput>
  }

  export type SchoolLevelUpdateWithWhereUniqueWithoutSchoolInput = {
    where: SchoolLevelWhereUniqueInput
    data: XOR<SchoolLevelUpdateWithoutSchoolInput, SchoolLevelUncheckedUpdateWithoutSchoolInput>
  }

  export type SchoolLevelUpdateManyWithWhereWithoutSchoolInput = {
    where: SchoolLevelScalarWhereInput
    data: XOR<SchoolLevelUpdateManyMutationInput, SchoolLevelUncheckedUpdateManyWithoutSchoolInput>
  }

  export type SchoolLevelScalarWhereInput = {
    AND?: SchoolLevelScalarWhereInput | SchoolLevelScalarWhereInput[]
    OR?: SchoolLevelScalarWhereInput[]
    NOT?: SchoolLevelScalarWhereInput | SchoolLevelScalarWhereInput[]
    id?: StringFilter<"SchoolLevel"> | string
    name?: StringFilter<"SchoolLevel"> | string
    description?: StringNullableFilter<"SchoolLevel"> | string | null
    order?: IntFilter<"SchoolLevel"> | number
    schoolId?: StringFilter<"SchoolLevel"> | string
    createdAt?: DateTimeFilter<"SchoolLevel"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolLevel"> | Date | string
  }

  export type SubjectUpsertWithWhereUniqueWithoutSchoolInput = {
    where: SubjectWhereUniqueInput
    update: XOR<SubjectUpdateWithoutSchoolInput, SubjectUncheckedUpdateWithoutSchoolInput>
    create: XOR<SubjectCreateWithoutSchoolInput, SubjectUncheckedCreateWithoutSchoolInput>
  }

  export type SubjectUpdateWithWhereUniqueWithoutSchoolInput = {
    where: SubjectWhereUniqueInput
    data: XOR<SubjectUpdateWithoutSchoolInput, SubjectUncheckedUpdateWithoutSchoolInput>
  }

  export type SubjectUpdateManyWithWhereWithoutSchoolInput = {
    where: SubjectScalarWhereInput
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyWithoutSchoolInput>
  }

  export type SubjectScalarWhereInput = {
    AND?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
    OR?: SubjectScalarWhereInput[]
    NOT?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
    id?: StringFilter<"Subject"> | string
    name?: StringFilter<"Subject"> | string
    code?: StringNullableFilter<"Subject"> | string | null
    description?: StringNullableFilter<"Subject"> | string | null
    schoolId?: StringFilter<"Subject"> | string
    departmentId?: StringNullableFilter<"Subject"> | string | null
    levelId?: StringNullableFilter<"Subject"> | string | null
    createdAt?: DateTimeFilter<"Subject"> | Date | string
    updatedAt?: DateTimeFilter<"Subject"> | Date | string
  }

  export type UserUpsertWithWhereUniqueWithoutSchoolInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutSchoolInput, UserUncheckedUpdateWithoutSchoolInput>
    create: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput>
  }

  export type UserUpdateWithWhereUniqueWithoutSchoolInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutSchoolInput, UserUncheckedUpdateWithoutSchoolInput>
  }

  export type UserUpdateManyWithWhereWithoutSchoolInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutSchoolInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    profileImage?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    schoolId?: StringNullableFilter<"User"> | string | null
  }

  export type ResultConfigurationUpsertWithWhereUniqueWithoutSchoolInput = {
    where: ResultConfigurationWhereUniqueInput
    update: XOR<ResultConfigurationUpdateWithoutSchoolInput, ResultConfigurationUncheckedUpdateWithoutSchoolInput>
    create: XOR<ResultConfigurationCreateWithoutSchoolInput, ResultConfigurationUncheckedCreateWithoutSchoolInput>
  }

  export type ResultConfigurationUpdateWithWhereUniqueWithoutSchoolInput = {
    where: ResultConfigurationWhereUniqueInput
    data: XOR<ResultConfigurationUpdateWithoutSchoolInput, ResultConfigurationUncheckedUpdateWithoutSchoolInput>
  }

  export type ResultConfigurationUpdateManyWithWhereWithoutSchoolInput = {
    where: ResultConfigurationScalarWhereInput
    data: XOR<ResultConfigurationUpdateManyMutationInput, ResultConfigurationUncheckedUpdateManyWithoutSchoolInput>
  }

  export type ResultConfigurationScalarWhereInput = {
    AND?: ResultConfigurationScalarWhereInput | ResultConfigurationScalarWhereInput[]
    OR?: ResultConfigurationScalarWhereInput[]
    NOT?: ResultConfigurationScalarWhereInput | ResultConfigurationScalarWhereInput[]
    id?: StringFilter<"ResultConfiguration"> | string
    schoolId?: StringFilter<"ResultConfiguration"> | string
    sessionId?: StringFilter<"ResultConfiguration"> | string
    cumulativeEnabled?: BoolFilter<"ResultConfiguration"> | boolean
    cumulativeMethod?: StringFilter<"ResultConfiguration"> | string
    showCumulativePerTerm?: BoolFilter<"ResultConfiguration"> | boolean
    createdAt?: DateTimeFilter<"ResultConfiguration"> | Date | string
    updatedAt?: DateTimeFilter<"ResultConfiguration"> | Date | string
  }

  export type SchoolCreateWithoutDepartmentsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email: string
    logo?: string | null
    subdomain: string
    primaryColor?: string | null
    secondaryColor?: string | null
    shortName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: AcademicSessionCreateNestedManyWithoutSchoolInput
    bills?: BillCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    paymentAccounts?: PaymentAccountCreateNestedManyWithoutSchoolInput
    levels?: SchoolLevelCreateNestedManyWithoutSchoolInput
    subjects?: SubjectCreateNestedManyWithoutSchoolInput
    users?: UserCreateNestedManyWithoutSchoolInput
    resultConfigs?: ResultConfigurationCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutDepartmentsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email: string
    logo?: string | null
    subdomain: string
    primaryColor?: string | null
    secondaryColor?: string | null
    shortName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: AcademicSessionUncheckedCreateNestedManyWithoutSchoolInput
    bills?: BillUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    paymentAccounts?: PaymentAccountUncheckedCreateNestedManyWithoutSchoolInput
    levels?: SchoolLevelUncheckedCreateNestedManyWithoutSchoolInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutSchoolInput
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    resultConfigs?: ResultConfigurationUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutDepartmentsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutDepartmentsInput, SchoolUncheckedCreateWithoutDepartmentsInput>
  }

  export type StudentCreateWithoutDepartmentInput = {
    id?: string
    admissionDate?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    religion?: string | null
    bloodGroup?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classId?: string | null
    attendance?: AttendanceCreateNestedManyWithoutStudentInput
    paymentRequests?: PaymentRequestCreateNestedManyWithoutStudentInput
    results?: ResultCreateNestedManyWithoutStudentInput
    user: UserCreateNestedOneWithoutStudentInput
    classes?: StudentClassCreateNestedManyWithoutStudentInput
    parents?: StudentParentCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutDepartmentInput = {
    id?: string
    userId: string
    admissionDate?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    religion?: string | null
    bloodGroup?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classId?: string | null
    attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    paymentRequests?: PaymentRequestUncheckedCreateNestedManyWithoutStudentInput
    results?: ResultUncheckedCreateNestedManyWithoutStudentInput
    classes?: StudentClassUncheckedCreateNestedManyWithoutStudentInput
    parents?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentUncheckedCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutDepartmentInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutDepartmentInput, StudentUncheckedCreateWithoutDepartmentInput>
  }

  export type StudentCreateManyDepartmentInputEnvelope = {
    data: StudentCreateManyDepartmentInput | StudentCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type SubjectCreateWithoutDepartmentInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassSubjectCreateNestedManyWithoutSubjectInput
    results?: ResultCreateNestedManyWithoutSubjectInput
    students?: StudentSubjectCreateNestedManyWithoutSubjectInput
    level?: SchoolLevelCreateNestedOneWithoutSubjectsInput
    school: SchoolCreateNestedOneWithoutSubjectsInput
    teachers?: SubjectTeacherCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutDepartmentInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    schoolId: string
    levelId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassSubjectUncheckedCreateNestedManyWithoutSubjectInput
    results?: ResultUncheckedCreateNestedManyWithoutSubjectInput
    students?: StudentSubjectUncheckedCreateNestedManyWithoutSubjectInput
    teachers?: SubjectTeacherUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutDepartmentInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutDepartmentInput, SubjectUncheckedCreateWithoutDepartmentInput>
  }

  export type SubjectCreateManyDepartmentInputEnvelope = {
    data: SubjectCreateManyDepartmentInput | SubjectCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type TeacherCreateWithoutDepartmentInput = {
    id?: string
    employeeId?: string | null
    qualifications?: string | null
    specialization?: string | null
    joiningDate?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    emergencyContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassCreateNestedManyWithoutTeacherInput
    subjects?: SubjectTeacherCreateNestedManyWithoutTeacherInput
    user: UserCreateNestedOneWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutDepartmentInput = {
    id?: string
    userId: string
    employeeId?: string | null
    qualifications?: string | null
    specialization?: string | null
    joiningDate?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    emergencyContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    subjects?: SubjectTeacherUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutDepartmentInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutDepartmentInput, TeacherUncheckedCreateWithoutDepartmentInput>
  }

  export type TeacherCreateManyDepartmentInputEnvelope = {
    data: TeacherCreateManyDepartmentInput | TeacherCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type SchoolUpsertWithoutDepartmentsInput = {
    update: XOR<SchoolUpdateWithoutDepartmentsInput, SchoolUncheckedUpdateWithoutDepartmentsInput>
    create: XOR<SchoolCreateWithoutDepartmentsInput, SchoolUncheckedCreateWithoutDepartmentsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutDepartmentsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutDepartmentsInput, SchoolUncheckedUpdateWithoutDepartmentsInput>
  }

  export type SchoolUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: StringFieldUpdateOperationsInput | string
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    shortName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: AcademicSessionUpdateManyWithoutSchoolNestedInput
    bills?: BillUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    paymentAccounts?: PaymentAccountUpdateManyWithoutSchoolNestedInput
    levels?: SchoolLevelUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUpdateManyWithoutSchoolNestedInput
    users?: UserUpdateManyWithoutSchoolNestedInput
    resultConfigs?: ResultConfigurationUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: StringFieldUpdateOperationsInput | string
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    shortName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: AcademicSessionUncheckedUpdateManyWithoutSchoolNestedInput
    bills?: BillUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    paymentAccounts?: PaymentAccountUncheckedUpdateManyWithoutSchoolNestedInput
    levels?: SchoolLevelUncheckedUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutSchoolNestedInput
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    resultConfigs?: ResultConfigurationUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type StudentUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutDepartmentInput, StudentUncheckedUpdateWithoutDepartmentInput>
    create: XOR<StudentCreateWithoutDepartmentInput, StudentUncheckedCreateWithoutDepartmentInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutDepartmentInput, StudentUncheckedUpdateWithoutDepartmentInput>
  }

  export type StudentUpdateManyWithWhereWithoutDepartmentInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type StudentScalarWhereInput = {
    AND?: StudentScalarWhereInput | StudentScalarWhereInput[]
    OR?: StudentScalarWhereInput[]
    NOT?: StudentScalarWhereInput | StudentScalarWhereInput[]
    id?: StringFilter<"Student"> | string
    userId?: StringFilter<"Student"> | string
    admissionDate?: DateTimeNullableFilter<"Student"> | Date | string | null
    departmentId?: StringNullableFilter<"Student"> | string | null
    address?: StringNullableFilter<"Student"> | string | null
    city?: StringNullableFilter<"Student"> | string | null
    state?: StringNullableFilter<"Student"> | string | null
    country?: StringNullableFilter<"Student"> | string | null
    phone?: StringNullableFilter<"Student"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Student"> | Date | string | null
    gender?: StringNullableFilter<"Student"> | string | null
    religion?: StringNullableFilter<"Student"> | string | null
    bloodGroup?: StringNullableFilter<"Student"> | string | null
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    classId?: StringNullableFilter<"Student"> | string | null
  }

  export type SubjectUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: SubjectWhereUniqueInput
    update: XOR<SubjectUpdateWithoutDepartmentInput, SubjectUncheckedUpdateWithoutDepartmentInput>
    create: XOR<SubjectCreateWithoutDepartmentInput, SubjectUncheckedCreateWithoutDepartmentInput>
  }

  export type SubjectUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: SubjectWhereUniqueInput
    data: XOR<SubjectUpdateWithoutDepartmentInput, SubjectUncheckedUpdateWithoutDepartmentInput>
  }

  export type SubjectUpdateManyWithWhereWithoutDepartmentInput = {
    where: SubjectScalarWhereInput
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type TeacherUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: TeacherWhereUniqueInput
    update: XOR<TeacherUpdateWithoutDepartmentInput, TeacherUncheckedUpdateWithoutDepartmentInput>
    create: XOR<TeacherCreateWithoutDepartmentInput, TeacherUncheckedCreateWithoutDepartmentInput>
  }

  export type TeacherUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: TeacherWhereUniqueInput
    data: XOR<TeacherUpdateWithoutDepartmentInput, TeacherUncheckedUpdateWithoutDepartmentInput>
  }

  export type TeacherUpdateManyWithWhereWithoutDepartmentInput = {
    where: TeacherScalarWhereInput
    data: XOR<TeacherUpdateManyMutationInput, TeacherUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type TeacherScalarWhereInput = {
    AND?: TeacherScalarWhereInput | TeacherScalarWhereInput[]
    OR?: TeacherScalarWhereInput[]
    NOT?: TeacherScalarWhereInput | TeacherScalarWhereInput[]
    id?: StringFilter<"Teacher"> | string
    userId?: StringFilter<"Teacher"> | string
    employeeId?: StringNullableFilter<"Teacher"> | string | null
    qualifications?: StringNullableFilter<"Teacher"> | string | null
    specialization?: StringNullableFilter<"Teacher"> | string | null
    joiningDate?: DateTimeNullableFilter<"Teacher"> | Date | string | null
    departmentId?: StringNullableFilter<"Teacher"> | string | null
    address?: StringNullableFilter<"Teacher"> | string | null
    city?: StringNullableFilter<"Teacher"> | string | null
    state?: StringNullableFilter<"Teacher"> | string | null
    country?: StringNullableFilter<"Teacher"> | string | null
    phone?: StringNullableFilter<"Teacher"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Teacher"> | Date | string | null
    gender?: StringNullableFilter<"Teacher"> | string | null
    emergencyContact?: StringNullableFilter<"Teacher"> | string | null
    createdAt?: DateTimeFilter<"Teacher"> | Date | string
    updatedAt?: DateTimeFilter<"Teacher"> | Date | string
  }

  export type SchoolLevelCreateWithoutClassesInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutLevelsInput
    subjects?: SubjectCreateNestedManyWithoutLevelInput
  }

  export type SchoolLevelUncheckedCreateWithoutClassesInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: SubjectUncheckedCreateNestedManyWithoutLevelInput
  }

  export type SchoolLevelCreateOrConnectWithoutClassesInput = {
    where: SchoolLevelWhereUniqueInput
    create: XOR<SchoolLevelCreateWithoutClassesInput, SchoolLevelUncheckedCreateWithoutClassesInput>
  }

  export type SchoolCreateWithoutClassesInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email: string
    logo?: string | null
    subdomain: string
    primaryColor?: string | null
    secondaryColor?: string | null
    shortName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: AcademicSessionCreateNestedManyWithoutSchoolInput
    bills?: BillCreateNestedManyWithoutSchoolInput
    departments?: DepartmentCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    paymentAccounts?: PaymentAccountCreateNestedManyWithoutSchoolInput
    levels?: SchoolLevelCreateNestedManyWithoutSchoolInput
    subjects?: SubjectCreateNestedManyWithoutSchoolInput
    users?: UserCreateNestedManyWithoutSchoolInput
    resultConfigs?: ResultConfigurationCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutClassesInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email: string
    logo?: string | null
    subdomain: string
    primaryColor?: string | null
    secondaryColor?: string | null
    shortName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: AcademicSessionUncheckedCreateNestedManyWithoutSchoolInput
    bills?: BillUncheckedCreateNestedManyWithoutSchoolInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    paymentAccounts?: PaymentAccountUncheckedCreateNestedManyWithoutSchoolInput
    levels?: SchoolLevelUncheckedCreateNestedManyWithoutSchoolInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutSchoolInput
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    resultConfigs?: ResultConfigurationUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutClassesInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutClassesInput, SchoolUncheckedCreateWithoutClassesInput>
  }

  export type TeacherCreateWithoutClassesInput = {
    id?: string
    employeeId?: string | null
    qualifications?: string | null
    specialization?: string | null
    joiningDate?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    emergencyContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: SubjectTeacherCreateNestedManyWithoutTeacherInput
    department?: DepartmentCreateNestedOneWithoutTeachersInput
    user: UserCreateNestedOneWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutClassesInput = {
    id?: string
    userId: string
    employeeId?: string | null
    qualifications?: string | null
    specialization?: string | null
    joiningDate?: Date | string | null
    departmentId?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    emergencyContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: SubjectTeacherUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutClassesInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutClassesInput, TeacherUncheckedCreateWithoutClassesInput>
  }

  export type ClassSubjectCreateWithoutClassInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: SubjectCreateNestedOneWithoutClassesInput
  }

  export type ClassSubjectUncheckedCreateWithoutClassInput = {
    id?: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassSubjectCreateOrConnectWithoutClassInput = {
    where: ClassSubjectWhereUniqueInput
    create: XOR<ClassSubjectCreateWithoutClassInput, ClassSubjectUncheckedCreateWithoutClassInput>
  }

  export type ClassSubjectCreateManyClassInputEnvelope = {
    data: ClassSubjectCreateManyClassInput | ClassSubjectCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type StudentClassCreateWithoutClassInput = {
    id?: string
    rollNumber?: string | null
    status?: $Enums.EnrollmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    session: AcademicSessionCreateNestedOneWithoutStudentClassesInput
    student: StudentCreateNestedOneWithoutClassesInput
  }

  export type StudentClassUncheckedCreateWithoutClassInput = {
    id?: string
    studentId: string
    sessionId: string
    rollNumber?: string | null
    status?: $Enums.EnrollmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentClassCreateOrConnectWithoutClassInput = {
    where: StudentClassWhereUniqueInput
    create: XOR<StudentClassCreateWithoutClassInput, StudentClassUncheckedCreateWithoutClassInput>
  }

  export type StudentClassCreateManyClassInputEnvelope = {
    data: StudentClassCreateManyClassInput | StudentClassCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type SchoolLevelUpsertWithoutClassesInput = {
    update: XOR<SchoolLevelUpdateWithoutClassesInput, SchoolLevelUncheckedUpdateWithoutClassesInput>
    create: XOR<SchoolLevelCreateWithoutClassesInput, SchoolLevelUncheckedCreateWithoutClassesInput>
    where?: SchoolLevelWhereInput
  }

  export type SchoolLevelUpdateToOneWithWhereWithoutClassesInput = {
    where?: SchoolLevelWhereInput
    data: XOR<SchoolLevelUpdateWithoutClassesInput, SchoolLevelUncheckedUpdateWithoutClassesInput>
  }

  export type SchoolLevelUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutLevelsNestedInput
    subjects?: SubjectUpdateManyWithoutLevelNestedInput
  }

  export type SchoolLevelUncheckedUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectUncheckedUpdateManyWithoutLevelNestedInput
  }

  export type SchoolUpsertWithoutClassesInput = {
    update: XOR<SchoolUpdateWithoutClassesInput, SchoolUncheckedUpdateWithoutClassesInput>
    create: XOR<SchoolCreateWithoutClassesInput, SchoolUncheckedCreateWithoutClassesInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutClassesInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutClassesInput, SchoolUncheckedUpdateWithoutClassesInput>
  }

  export type SchoolUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: StringFieldUpdateOperationsInput | string
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    shortName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: AcademicSessionUpdateManyWithoutSchoolNestedInput
    bills?: BillUpdateManyWithoutSchoolNestedInput
    departments?: DepartmentUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    paymentAccounts?: PaymentAccountUpdateManyWithoutSchoolNestedInput
    levels?: SchoolLevelUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUpdateManyWithoutSchoolNestedInput
    users?: UserUpdateManyWithoutSchoolNestedInput
    resultConfigs?: ResultConfigurationUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: StringFieldUpdateOperationsInput | string
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    shortName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: AcademicSessionUncheckedUpdateManyWithoutSchoolNestedInput
    bills?: BillUncheckedUpdateManyWithoutSchoolNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    paymentAccounts?: PaymentAccountUncheckedUpdateManyWithoutSchoolNestedInput
    levels?: SchoolLevelUncheckedUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutSchoolNestedInput
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    resultConfigs?: ResultConfigurationUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type TeacherUpsertWithoutClassesInput = {
    update: XOR<TeacherUpdateWithoutClassesInput, TeacherUncheckedUpdateWithoutClassesInput>
    create: XOR<TeacherCreateWithoutClassesInput, TeacherUncheckedCreateWithoutClassesInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutClassesInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutClassesInput, TeacherUncheckedUpdateWithoutClassesInput>
  }

  export type TeacherUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectTeacherUpdateManyWithoutTeacherNestedInput
    department?: DepartmentUpdateOneWithoutTeachersNestedInput
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectTeacherUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type ClassSubjectUpsertWithWhereUniqueWithoutClassInput = {
    where: ClassSubjectWhereUniqueInput
    update: XOR<ClassSubjectUpdateWithoutClassInput, ClassSubjectUncheckedUpdateWithoutClassInput>
    create: XOR<ClassSubjectCreateWithoutClassInput, ClassSubjectUncheckedCreateWithoutClassInput>
  }

  export type ClassSubjectUpdateWithWhereUniqueWithoutClassInput = {
    where: ClassSubjectWhereUniqueInput
    data: XOR<ClassSubjectUpdateWithoutClassInput, ClassSubjectUncheckedUpdateWithoutClassInput>
  }

  export type ClassSubjectUpdateManyWithWhereWithoutClassInput = {
    where: ClassSubjectScalarWhereInput
    data: XOR<ClassSubjectUpdateManyMutationInput, ClassSubjectUncheckedUpdateManyWithoutClassInput>
  }

  export type ClassSubjectScalarWhereInput = {
    AND?: ClassSubjectScalarWhereInput | ClassSubjectScalarWhereInput[]
    OR?: ClassSubjectScalarWhereInput[]
    NOT?: ClassSubjectScalarWhereInput | ClassSubjectScalarWhereInput[]
    id?: StringFilter<"ClassSubject"> | string
    classId?: StringFilter<"ClassSubject"> | string
    subjectId?: StringFilter<"ClassSubject"> | string
    createdAt?: DateTimeFilter<"ClassSubject"> | Date | string
    updatedAt?: DateTimeFilter<"ClassSubject"> | Date | string
  }

  export type StudentClassUpsertWithWhereUniqueWithoutClassInput = {
    where: StudentClassWhereUniqueInput
    update: XOR<StudentClassUpdateWithoutClassInput, StudentClassUncheckedUpdateWithoutClassInput>
    create: XOR<StudentClassCreateWithoutClassInput, StudentClassUncheckedCreateWithoutClassInput>
  }

  export type StudentClassUpdateWithWhereUniqueWithoutClassInput = {
    where: StudentClassWhereUniqueInput
    data: XOR<StudentClassUpdateWithoutClassInput, StudentClassUncheckedUpdateWithoutClassInput>
  }

  export type StudentClassUpdateManyWithWhereWithoutClassInput = {
    where: StudentClassScalarWhereInput
    data: XOR<StudentClassUpdateManyMutationInput, StudentClassUncheckedUpdateManyWithoutClassInput>
  }

  export type ClassSubjectCreateWithoutSubjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutSubjectsInput
  }

  export type ClassSubjectUncheckedCreateWithoutSubjectInput = {
    id?: string
    classId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassSubjectCreateOrConnectWithoutSubjectInput = {
    where: ClassSubjectWhereUniqueInput
    create: XOR<ClassSubjectCreateWithoutSubjectInput, ClassSubjectUncheckedCreateWithoutSubjectInput>
  }

  export type ClassSubjectCreateManySubjectInputEnvelope = {
    data: ClassSubjectCreateManySubjectInput | ClassSubjectCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type ResultCreateWithoutSubjectInput = {
    id?: string
    total: number
    grade: string
    remark: string
    cumulativeAverage?: number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: string | null
    adminComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    componentScores?: ComponentScoreCreateNestedManyWithoutResultInput
    student: StudentCreateNestedOneWithoutResultsInput
    period: ResultPeriodCreateNestedOneWithoutResultsInput
    session: AcademicSessionCreateNestedOneWithoutResultsInput
    approvedBy?: UserCreateNestedOneWithoutApprovedResultsInput
  }

  export type ResultUncheckedCreateWithoutSubjectInput = {
    id?: string
    studentId: string
    periodId: string
    sessionId: string
    total: number
    grade: string
    remark: string
    cumulativeAverage?: number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: string | null
    adminComment?: string | null
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    componentScores?: ComponentScoreUncheckedCreateNestedManyWithoutResultInput
  }

  export type ResultCreateOrConnectWithoutSubjectInput = {
    where: ResultWhereUniqueInput
    create: XOR<ResultCreateWithoutSubjectInput, ResultUncheckedCreateWithoutSubjectInput>
  }

  export type ResultCreateManySubjectInputEnvelope = {
    data: ResultCreateManySubjectInput | ResultCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type StudentSubjectCreateWithoutSubjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutSubjectsInput
  }

  export type StudentSubjectUncheckedCreateWithoutSubjectInput = {
    id?: string
    studentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSubjectCreateOrConnectWithoutSubjectInput = {
    where: StudentSubjectWhereUniqueInput
    create: XOR<StudentSubjectCreateWithoutSubjectInput, StudentSubjectUncheckedCreateWithoutSubjectInput>
  }

  export type StudentSubjectCreateManySubjectInputEnvelope = {
    data: StudentSubjectCreateManySubjectInput | StudentSubjectCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentCreateWithoutSubjectsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutDepartmentsInput
    students?: StudentCreateNestedManyWithoutDepartmentInput
    teachers?: TeacherCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutSubjectsInput = {
    id?: string
    name: string
    description?: string | null
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutDepartmentInput
    teachers?: TeacherUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutSubjectsInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutSubjectsInput, DepartmentUncheckedCreateWithoutSubjectsInput>
  }

  export type SchoolLevelCreateWithoutSubjectsInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassCreateNestedManyWithoutLevelInput
    school: SchoolCreateNestedOneWithoutLevelsInput
  }

  export type SchoolLevelUncheckedCreateWithoutSubjectsInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassUncheckedCreateNestedManyWithoutLevelInput
  }

  export type SchoolLevelCreateOrConnectWithoutSubjectsInput = {
    where: SchoolLevelWhereUniqueInput
    create: XOR<SchoolLevelCreateWithoutSubjectsInput, SchoolLevelUncheckedCreateWithoutSubjectsInput>
  }

  export type SchoolCreateWithoutSubjectsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email: string
    logo?: string | null
    subdomain: string
    primaryColor?: string | null
    secondaryColor?: string | null
    shortName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: AcademicSessionCreateNestedManyWithoutSchoolInput
    bills?: BillCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    departments?: DepartmentCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    paymentAccounts?: PaymentAccountCreateNestedManyWithoutSchoolInput
    levels?: SchoolLevelCreateNestedManyWithoutSchoolInput
    users?: UserCreateNestedManyWithoutSchoolInput
    resultConfigs?: ResultConfigurationCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutSubjectsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email: string
    logo?: string | null
    subdomain: string
    primaryColor?: string | null
    secondaryColor?: string | null
    shortName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: AcademicSessionUncheckedCreateNestedManyWithoutSchoolInput
    bills?: BillUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    paymentAccounts?: PaymentAccountUncheckedCreateNestedManyWithoutSchoolInput
    levels?: SchoolLevelUncheckedCreateNestedManyWithoutSchoolInput
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    resultConfigs?: ResultConfigurationUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutSubjectsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutSubjectsInput, SchoolUncheckedCreateWithoutSubjectsInput>
  }

  export type SubjectTeacherCreateWithoutSubjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: TeacherCreateNestedOneWithoutSubjectsInput
  }

  export type SubjectTeacherUncheckedCreateWithoutSubjectInput = {
    id?: string
    teacherId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectTeacherCreateOrConnectWithoutSubjectInput = {
    where: SubjectTeacherWhereUniqueInput
    create: XOR<SubjectTeacherCreateWithoutSubjectInput, SubjectTeacherUncheckedCreateWithoutSubjectInput>
  }

  export type SubjectTeacherCreateManySubjectInputEnvelope = {
    data: SubjectTeacherCreateManySubjectInput | SubjectTeacherCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type ClassSubjectUpsertWithWhereUniqueWithoutSubjectInput = {
    where: ClassSubjectWhereUniqueInput
    update: XOR<ClassSubjectUpdateWithoutSubjectInput, ClassSubjectUncheckedUpdateWithoutSubjectInput>
    create: XOR<ClassSubjectCreateWithoutSubjectInput, ClassSubjectUncheckedCreateWithoutSubjectInput>
  }

  export type ClassSubjectUpdateWithWhereUniqueWithoutSubjectInput = {
    where: ClassSubjectWhereUniqueInput
    data: XOR<ClassSubjectUpdateWithoutSubjectInput, ClassSubjectUncheckedUpdateWithoutSubjectInput>
  }

  export type ClassSubjectUpdateManyWithWhereWithoutSubjectInput = {
    where: ClassSubjectScalarWhereInput
    data: XOR<ClassSubjectUpdateManyMutationInput, ClassSubjectUncheckedUpdateManyWithoutSubjectInput>
  }

  export type ResultUpsertWithWhereUniqueWithoutSubjectInput = {
    where: ResultWhereUniqueInput
    update: XOR<ResultUpdateWithoutSubjectInput, ResultUncheckedUpdateWithoutSubjectInput>
    create: XOR<ResultCreateWithoutSubjectInput, ResultUncheckedCreateWithoutSubjectInput>
  }

  export type ResultUpdateWithWhereUniqueWithoutSubjectInput = {
    where: ResultWhereUniqueInput
    data: XOR<ResultUpdateWithoutSubjectInput, ResultUncheckedUpdateWithoutSubjectInput>
  }

  export type ResultUpdateManyWithWhereWithoutSubjectInput = {
    where: ResultScalarWhereInput
    data: XOR<ResultUpdateManyMutationInput, ResultUncheckedUpdateManyWithoutSubjectInput>
  }

  export type StudentSubjectUpsertWithWhereUniqueWithoutSubjectInput = {
    where: StudentSubjectWhereUniqueInput
    update: XOR<StudentSubjectUpdateWithoutSubjectInput, StudentSubjectUncheckedUpdateWithoutSubjectInput>
    create: XOR<StudentSubjectCreateWithoutSubjectInput, StudentSubjectUncheckedCreateWithoutSubjectInput>
  }

  export type StudentSubjectUpdateWithWhereUniqueWithoutSubjectInput = {
    where: StudentSubjectWhereUniqueInput
    data: XOR<StudentSubjectUpdateWithoutSubjectInput, StudentSubjectUncheckedUpdateWithoutSubjectInput>
  }

  export type StudentSubjectUpdateManyWithWhereWithoutSubjectInput = {
    where: StudentSubjectScalarWhereInput
    data: XOR<StudentSubjectUpdateManyMutationInput, StudentSubjectUncheckedUpdateManyWithoutSubjectInput>
  }

  export type DepartmentUpsertWithoutSubjectsInput = {
    update: XOR<DepartmentUpdateWithoutSubjectsInput, DepartmentUncheckedUpdateWithoutSubjectsInput>
    create: XOR<DepartmentCreateWithoutSubjectsInput, DepartmentUncheckedCreateWithoutSubjectsInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutSubjectsInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutSubjectsInput, DepartmentUncheckedUpdateWithoutSubjectsInput>
  }

  export type DepartmentUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutDepartmentsNestedInput
    students?: StudentUpdateManyWithoutDepartmentNestedInput
    teachers?: TeacherUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutDepartmentNestedInput
    teachers?: TeacherUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type SchoolLevelUpsertWithoutSubjectsInput = {
    update: XOR<SchoolLevelUpdateWithoutSubjectsInput, SchoolLevelUncheckedUpdateWithoutSubjectsInput>
    create: XOR<SchoolLevelCreateWithoutSubjectsInput, SchoolLevelUncheckedCreateWithoutSubjectsInput>
    where?: SchoolLevelWhereInput
  }

  export type SchoolLevelUpdateToOneWithWhereWithoutSubjectsInput = {
    where?: SchoolLevelWhereInput
    data: XOR<SchoolLevelUpdateWithoutSubjectsInput, SchoolLevelUncheckedUpdateWithoutSubjectsInput>
  }

  export type SchoolLevelUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassUpdateManyWithoutLevelNestedInput
    school?: SchoolUpdateOneRequiredWithoutLevelsNestedInput
  }

  export type SchoolLevelUncheckedUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassUncheckedUpdateManyWithoutLevelNestedInput
  }

  export type SchoolUpsertWithoutSubjectsInput = {
    update: XOR<SchoolUpdateWithoutSubjectsInput, SchoolUncheckedUpdateWithoutSubjectsInput>
    create: XOR<SchoolCreateWithoutSubjectsInput, SchoolUncheckedCreateWithoutSubjectsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutSubjectsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutSubjectsInput, SchoolUncheckedUpdateWithoutSubjectsInput>
  }

  export type SchoolUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: StringFieldUpdateOperationsInput | string
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    shortName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: AcademicSessionUpdateManyWithoutSchoolNestedInput
    bills?: BillUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    departments?: DepartmentUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    paymentAccounts?: PaymentAccountUpdateManyWithoutSchoolNestedInput
    levels?: SchoolLevelUpdateManyWithoutSchoolNestedInput
    users?: UserUpdateManyWithoutSchoolNestedInput
    resultConfigs?: ResultConfigurationUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: StringFieldUpdateOperationsInput | string
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    shortName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: AcademicSessionUncheckedUpdateManyWithoutSchoolNestedInput
    bills?: BillUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    paymentAccounts?: PaymentAccountUncheckedUpdateManyWithoutSchoolNestedInput
    levels?: SchoolLevelUncheckedUpdateManyWithoutSchoolNestedInput
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    resultConfigs?: ResultConfigurationUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SubjectTeacherUpsertWithWhereUniqueWithoutSubjectInput = {
    where: SubjectTeacherWhereUniqueInput
    update: XOR<SubjectTeacherUpdateWithoutSubjectInput, SubjectTeacherUncheckedUpdateWithoutSubjectInput>
    create: XOR<SubjectTeacherCreateWithoutSubjectInput, SubjectTeacherUncheckedCreateWithoutSubjectInput>
  }

  export type SubjectTeacherUpdateWithWhereUniqueWithoutSubjectInput = {
    where: SubjectTeacherWhereUniqueInput
    data: XOR<SubjectTeacherUpdateWithoutSubjectInput, SubjectTeacherUncheckedUpdateWithoutSubjectInput>
  }

  export type SubjectTeacherUpdateManyWithWhereWithoutSubjectInput = {
    where: SubjectTeacherScalarWhereInput
    data: XOR<SubjectTeacherUpdateManyMutationInput, SubjectTeacherUncheckedUpdateManyWithoutSubjectInput>
  }

  export type SchoolCreateWithoutSessionsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email: string
    logo?: string | null
    subdomain: string
    primaryColor?: string | null
    secondaryColor?: string | null
    shortName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bills?: BillCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    departments?: DepartmentCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    paymentAccounts?: PaymentAccountCreateNestedManyWithoutSchoolInput
    levels?: SchoolLevelCreateNestedManyWithoutSchoolInput
    subjects?: SubjectCreateNestedManyWithoutSchoolInput
    users?: UserCreateNestedManyWithoutSchoolInput
    resultConfigs?: ResultConfigurationCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutSessionsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email: string
    logo?: string | null
    subdomain: string
    primaryColor?: string | null
    secondaryColor?: string | null
    shortName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bills?: BillUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    paymentAccounts?: PaymentAccountUncheckedCreateNestedManyWithoutSchoolInput
    levels?: SchoolLevelUncheckedCreateNestedManyWithoutSchoolInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutSchoolInput
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    resultConfigs?: ResultConfigurationUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutSessionsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutSessionsInput, SchoolUncheckedCreateWithoutSessionsInput>
  }

  export type AttendanceCreateWithoutSessionInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateWithoutSessionInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    studentId: string
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceCreateOrConnectWithoutSessionInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutSessionInput, AttendanceUncheckedCreateWithoutSessionInput>
  }

  export type AttendanceCreateManySessionInputEnvelope = {
    data: AttendanceCreateManySessionInput | AttendanceCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type ResultCreateWithoutSessionInput = {
    id?: string
    total: number
    grade: string
    remark: string
    cumulativeAverage?: number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: string | null
    adminComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    componentScores?: ComponentScoreCreateNestedManyWithoutResultInput
    student: StudentCreateNestedOneWithoutResultsInput
    subject: SubjectCreateNestedOneWithoutResultsInput
    period: ResultPeriodCreateNestedOneWithoutResultsInput
    approvedBy?: UserCreateNestedOneWithoutApprovedResultsInput
  }

  export type ResultUncheckedCreateWithoutSessionInput = {
    id?: string
    studentId: string
    subjectId: string
    periodId: string
    total: number
    grade: string
    remark: string
    cumulativeAverage?: number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: string | null
    adminComment?: string | null
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    componentScores?: ComponentScoreUncheckedCreateNestedManyWithoutResultInput
  }

  export type ResultCreateOrConnectWithoutSessionInput = {
    where: ResultWhereUniqueInput
    create: XOR<ResultCreateWithoutSessionInput, ResultUncheckedCreateWithoutSessionInput>
  }

  export type ResultCreateManySessionInputEnvelope = {
    data: ResultCreateManySessionInput | ResultCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type StudentClassCreateWithoutSessionInput = {
    id?: string
    rollNumber?: string | null
    status?: $Enums.EnrollmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutStudentsInput
    student: StudentCreateNestedOneWithoutClassesInput
  }

  export type StudentClassUncheckedCreateWithoutSessionInput = {
    id?: string
    studentId: string
    classId: string
    rollNumber?: string | null
    status?: $Enums.EnrollmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentClassCreateOrConnectWithoutSessionInput = {
    where: StudentClassWhereUniqueInput
    create: XOR<StudentClassCreateWithoutSessionInput, StudentClassUncheckedCreateWithoutSessionInput>
  }

  export type StudentClassCreateManySessionInputEnvelope = {
    data: StudentClassCreateManySessionInput | StudentClassCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type ResultConfigurationCreateWithoutSessionInput = {
    id?: string
    cumulativeEnabled?: boolean
    cumulativeMethod?: string
    showCumulativePerTerm?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    periods?: ResultPeriodCreateNestedManyWithoutConfigurationInput
    assessmentComponents?: AssessmentComponentCreateNestedManyWithoutConfigurationInput
    gradingScale?: GradingScaleCreateNestedManyWithoutConfigurationInput
    school: SchoolCreateNestedOneWithoutResultConfigsInput
  }

  export type ResultConfigurationUncheckedCreateWithoutSessionInput = {
    id?: string
    schoolId: string
    cumulativeEnabled?: boolean
    cumulativeMethod?: string
    showCumulativePerTerm?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    periods?: ResultPeriodUncheckedCreateNestedManyWithoutConfigurationInput
    assessmentComponents?: AssessmentComponentUncheckedCreateNestedManyWithoutConfigurationInput
    gradingScale?: GradingScaleUncheckedCreateNestedManyWithoutConfigurationInput
  }

  export type ResultConfigurationCreateOrConnectWithoutSessionInput = {
    where: ResultConfigurationWhereUniqueInput
    create: XOR<ResultConfigurationCreateWithoutSessionInput, ResultConfigurationUncheckedCreateWithoutSessionInput>
  }

  export type ResultConfigurationCreateManySessionInputEnvelope = {
    data: ResultConfigurationCreateManySessionInput | ResultConfigurationCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type SchoolUpsertWithoutSessionsInput = {
    update: XOR<SchoolUpdateWithoutSessionsInput, SchoolUncheckedUpdateWithoutSessionsInput>
    create: XOR<SchoolCreateWithoutSessionsInput, SchoolUncheckedCreateWithoutSessionsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutSessionsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutSessionsInput, SchoolUncheckedUpdateWithoutSessionsInput>
  }

  export type SchoolUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: StringFieldUpdateOperationsInput | string
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    shortName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: BillUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    departments?: DepartmentUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    paymentAccounts?: PaymentAccountUpdateManyWithoutSchoolNestedInput
    levels?: SchoolLevelUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUpdateManyWithoutSchoolNestedInput
    users?: UserUpdateManyWithoutSchoolNestedInput
    resultConfigs?: ResultConfigurationUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: StringFieldUpdateOperationsInput | string
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    shortName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: BillUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    paymentAccounts?: PaymentAccountUncheckedUpdateManyWithoutSchoolNestedInput
    levels?: SchoolLevelUncheckedUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutSchoolNestedInput
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    resultConfigs?: ResultConfigurationUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type AttendanceUpsertWithWhereUniqueWithoutSessionInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutSessionInput, AttendanceUncheckedUpdateWithoutSessionInput>
    create: XOR<AttendanceCreateWithoutSessionInput, AttendanceUncheckedCreateWithoutSessionInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutSessionInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutSessionInput, AttendanceUncheckedUpdateWithoutSessionInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutSessionInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutSessionInput>
  }

  export type ResultUpsertWithWhereUniqueWithoutSessionInput = {
    where: ResultWhereUniqueInput
    update: XOR<ResultUpdateWithoutSessionInput, ResultUncheckedUpdateWithoutSessionInput>
    create: XOR<ResultCreateWithoutSessionInput, ResultUncheckedCreateWithoutSessionInput>
  }

  export type ResultUpdateWithWhereUniqueWithoutSessionInput = {
    where: ResultWhereUniqueInput
    data: XOR<ResultUpdateWithoutSessionInput, ResultUncheckedUpdateWithoutSessionInput>
  }

  export type ResultUpdateManyWithWhereWithoutSessionInput = {
    where: ResultScalarWhereInput
    data: XOR<ResultUpdateManyMutationInput, ResultUncheckedUpdateManyWithoutSessionInput>
  }

  export type StudentClassUpsertWithWhereUniqueWithoutSessionInput = {
    where: StudentClassWhereUniqueInput
    update: XOR<StudentClassUpdateWithoutSessionInput, StudentClassUncheckedUpdateWithoutSessionInput>
    create: XOR<StudentClassCreateWithoutSessionInput, StudentClassUncheckedCreateWithoutSessionInput>
  }

  export type StudentClassUpdateWithWhereUniqueWithoutSessionInput = {
    where: StudentClassWhereUniqueInput
    data: XOR<StudentClassUpdateWithoutSessionInput, StudentClassUncheckedUpdateWithoutSessionInput>
  }

  export type StudentClassUpdateManyWithWhereWithoutSessionInput = {
    where: StudentClassScalarWhereInput
    data: XOR<StudentClassUpdateManyMutationInput, StudentClassUncheckedUpdateManyWithoutSessionInput>
  }

  export type ResultConfigurationUpsertWithWhereUniqueWithoutSessionInput = {
    where: ResultConfigurationWhereUniqueInput
    update: XOR<ResultConfigurationUpdateWithoutSessionInput, ResultConfigurationUncheckedUpdateWithoutSessionInput>
    create: XOR<ResultConfigurationCreateWithoutSessionInput, ResultConfigurationUncheckedCreateWithoutSessionInput>
  }

  export type ResultConfigurationUpdateWithWhereUniqueWithoutSessionInput = {
    where: ResultConfigurationWhereUniqueInput
    data: XOR<ResultConfigurationUpdateWithoutSessionInput, ResultConfigurationUncheckedUpdateWithoutSessionInput>
  }

  export type ResultConfigurationUpdateManyWithWhereWithoutSessionInput = {
    where: ResultConfigurationScalarWhereInput
    data: XOR<ResultConfigurationUpdateManyMutationInput, ResultConfigurationUncheckedUpdateManyWithoutSessionInput>
  }

  export type ClassCreateWithoutStudentsInput = {
    id?: string
    name: string
    section?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    level?: SchoolLevelCreateNestedOneWithoutClassesInput
    school: SchoolCreateNestedOneWithoutClassesInput
    teacher?: TeacherCreateNestedOneWithoutClassesInput
    subjects?: ClassSubjectCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutStudentsInput = {
    id?: string
    name: string
    section?: string | null
    schoolId: string
    teacherId?: string | null
    levelId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: ClassSubjectUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutStudentsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutStudentsInput, ClassUncheckedCreateWithoutStudentsInput>
  }

  export type AcademicSessionCreateWithoutStudentClassesInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutSessionsInput
    attendance?: AttendanceCreateNestedManyWithoutSessionInput
    results?: ResultCreateNestedManyWithoutSessionInput
    resultConfigurations?: ResultConfigurationCreateNestedManyWithoutSessionInput
  }

  export type AcademicSessionUncheckedCreateWithoutStudentClassesInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    attendance?: AttendanceUncheckedCreateNestedManyWithoutSessionInput
    results?: ResultUncheckedCreateNestedManyWithoutSessionInput
    resultConfigurations?: ResultConfigurationUncheckedCreateNestedManyWithoutSessionInput
  }

  export type AcademicSessionCreateOrConnectWithoutStudentClassesInput = {
    where: AcademicSessionWhereUniqueInput
    create: XOR<AcademicSessionCreateWithoutStudentClassesInput, AcademicSessionUncheckedCreateWithoutStudentClassesInput>
  }

  export type StudentCreateWithoutClassesInput = {
    id?: string
    admissionDate?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    religion?: string | null
    bloodGroup?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classId?: string | null
    attendance?: AttendanceCreateNestedManyWithoutStudentInput
    paymentRequests?: PaymentRequestCreateNestedManyWithoutStudentInput
    results?: ResultCreateNestedManyWithoutStudentInput
    department?: DepartmentCreateNestedOneWithoutStudentsInput
    user: UserCreateNestedOneWithoutStudentInput
    parents?: StudentParentCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutClassesInput = {
    id?: string
    userId: string
    admissionDate?: Date | string | null
    departmentId?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    religion?: string | null
    bloodGroup?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classId?: string | null
    attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    paymentRequests?: PaymentRequestUncheckedCreateNestedManyWithoutStudentInput
    results?: ResultUncheckedCreateNestedManyWithoutStudentInput
    parents?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentUncheckedCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutClassesInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutClassesInput, StudentUncheckedCreateWithoutClassesInput>
  }

  export type ClassUpsertWithoutStudentsInput = {
    update: XOR<ClassUpdateWithoutStudentsInput, ClassUncheckedUpdateWithoutStudentsInput>
    create: XOR<ClassCreateWithoutStudentsInput, ClassUncheckedCreateWithoutStudentsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutStudentsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutStudentsInput, ClassUncheckedUpdateWithoutStudentsInput>
  }

  export type ClassUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: SchoolLevelUpdateOneWithoutClassesNestedInput
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    teacher?: TeacherUpdateOneWithoutClassesNestedInput
    subjects?: ClassSubjectUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: ClassSubjectUncheckedUpdateManyWithoutClassNestedInput
  }

  export type AcademicSessionUpsertWithoutStudentClassesInput = {
    update: XOR<AcademicSessionUpdateWithoutStudentClassesInput, AcademicSessionUncheckedUpdateWithoutStudentClassesInput>
    create: XOR<AcademicSessionCreateWithoutStudentClassesInput, AcademicSessionUncheckedCreateWithoutStudentClassesInput>
    where?: AcademicSessionWhereInput
  }

  export type AcademicSessionUpdateToOneWithWhereWithoutStudentClassesInput = {
    where?: AcademicSessionWhereInput
    data: XOR<AcademicSessionUpdateWithoutStudentClassesInput, AcademicSessionUncheckedUpdateWithoutStudentClassesInput>
  }

  export type AcademicSessionUpdateWithoutStudentClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutSessionsNestedInput
    attendance?: AttendanceUpdateManyWithoutSessionNestedInput
    results?: ResultUpdateManyWithoutSessionNestedInput
    resultConfigurations?: ResultConfigurationUpdateManyWithoutSessionNestedInput
  }

  export type AcademicSessionUncheckedUpdateWithoutStudentClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: AttendanceUncheckedUpdateManyWithoutSessionNestedInput
    results?: ResultUncheckedUpdateManyWithoutSessionNestedInput
    resultConfigurations?: ResultConfigurationUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type StudentUpsertWithoutClassesInput = {
    update: XOR<StudentUpdateWithoutClassesInput, StudentUncheckedUpdateWithoutClassesInput>
    create: XOR<StudentCreateWithoutClassesInput, StudentUncheckedCreateWithoutClassesInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutClassesInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutClassesInput, StudentUncheckedUpdateWithoutClassesInput>
  }

  export type StudentUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    paymentRequests?: PaymentRequestUpdateManyWithoutStudentNestedInput
    results?: ResultUpdateManyWithoutStudentNestedInput
    department?: DepartmentUpdateOneWithoutStudentsNestedInput
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    parents?: StudentParentUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    paymentRequests?: PaymentRequestUncheckedUpdateManyWithoutStudentNestedInput
    results?: ResultUncheckedUpdateManyWithoutStudentNestedInput
    parents?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUncheckedUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ParentCreateWithoutChildrenInput = {
    id?: string
    occupation?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    alternatePhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutParentInput
  }

  export type ParentUncheckedCreateWithoutChildrenInput = {
    id?: string
    userId: string
    occupation?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    alternatePhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParentCreateOrConnectWithoutChildrenInput = {
    where: ParentWhereUniqueInput
    create: XOR<ParentCreateWithoutChildrenInput, ParentUncheckedCreateWithoutChildrenInput>
  }

  export type StudentCreateWithoutParentsInput = {
    id?: string
    admissionDate?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    religion?: string | null
    bloodGroup?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classId?: string | null
    attendance?: AttendanceCreateNestedManyWithoutStudentInput
    paymentRequests?: PaymentRequestCreateNestedManyWithoutStudentInput
    results?: ResultCreateNestedManyWithoutStudentInput
    department?: DepartmentCreateNestedOneWithoutStudentsInput
    user: UserCreateNestedOneWithoutStudentInput
    classes?: StudentClassCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutParentsInput = {
    id?: string
    userId: string
    admissionDate?: Date | string | null
    departmentId?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    religion?: string | null
    bloodGroup?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classId?: string | null
    attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    paymentRequests?: PaymentRequestUncheckedCreateNestedManyWithoutStudentInput
    results?: ResultUncheckedCreateNestedManyWithoutStudentInput
    classes?: StudentClassUncheckedCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentUncheckedCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutParentsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutParentsInput, StudentUncheckedCreateWithoutParentsInput>
  }

  export type ParentUpsertWithoutChildrenInput = {
    update: XOR<ParentUpdateWithoutChildrenInput, ParentUncheckedUpdateWithoutChildrenInput>
    create: XOR<ParentCreateWithoutChildrenInput, ParentUncheckedCreateWithoutChildrenInput>
    where?: ParentWhereInput
  }

  export type ParentUpdateToOneWithWhereWithoutChildrenInput = {
    where?: ParentWhereInput
    data: XOR<ParentUpdateWithoutChildrenInput, ParentUncheckedUpdateWithoutChildrenInput>
  }

  export type ParentUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutParentNestedInput
  }

  export type ParentUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUpsertWithoutParentsInput = {
    update: XOR<StudentUpdateWithoutParentsInput, StudentUncheckedUpdateWithoutParentsInput>
    create: XOR<StudentCreateWithoutParentsInput, StudentUncheckedCreateWithoutParentsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutParentsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutParentsInput, StudentUncheckedUpdateWithoutParentsInput>
  }

  export type StudentUpdateWithoutParentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    paymentRequests?: PaymentRequestUpdateManyWithoutStudentNestedInput
    results?: ResultUpdateManyWithoutStudentNestedInput
    department?: DepartmentUpdateOneWithoutStudentsNestedInput
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    classes?: StudentClassUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutParentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    paymentRequests?: PaymentRequestUncheckedUpdateManyWithoutStudentNestedInput
    results?: ResultUncheckedUpdateManyWithoutStudentNestedInput
    classes?: StudentClassUncheckedUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUncheckedUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type SubjectCreateWithoutTeachersInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassSubjectCreateNestedManyWithoutSubjectInput
    results?: ResultCreateNestedManyWithoutSubjectInput
    students?: StudentSubjectCreateNestedManyWithoutSubjectInput
    department?: DepartmentCreateNestedOneWithoutSubjectsInput
    level?: SchoolLevelCreateNestedOneWithoutSubjectsInput
    school: SchoolCreateNestedOneWithoutSubjectsInput
  }

  export type SubjectUncheckedCreateWithoutTeachersInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    schoolId: string
    departmentId?: string | null
    levelId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassSubjectUncheckedCreateNestedManyWithoutSubjectInput
    results?: ResultUncheckedCreateNestedManyWithoutSubjectInput
    students?: StudentSubjectUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutTeachersInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutTeachersInput, SubjectUncheckedCreateWithoutTeachersInput>
  }

  export type TeacherCreateWithoutSubjectsInput = {
    id?: string
    employeeId?: string | null
    qualifications?: string | null
    specialization?: string | null
    joiningDate?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    emergencyContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassCreateNestedManyWithoutTeacherInput
    department?: DepartmentCreateNestedOneWithoutTeachersInput
    user: UserCreateNestedOneWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutSubjectsInput = {
    id?: string
    userId: string
    employeeId?: string | null
    qualifications?: string | null
    specialization?: string | null
    joiningDate?: Date | string | null
    departmentId?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    emergencyContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutSubjectsInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutSubjectsInput, TeacherUncheckedCreateWithoutSubjectsInput>
  }

  export type SubjectUpsertWithoutTeachersInput = {
    update: XOR<SubjectUpdateWithoutTeachersInput, SubjectUncheckedUpdateWithoutTeachersInput>
    create: XOR<SubjectCreateWithoutTeachersInput, SubjectUncheckedCreateWithoutTeachersInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutTeachersInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutTeachersInput, SubjectUncheckedUpdateWithoutTeachersInput>
  }

  export type SubjectUpdateWithoutTeachersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassSubjectUpdateManyWithoutSubjectNestedInput
    results?: ResultUpdateManyWithoutSubjectNestedInput
    students?: StudentSubjectUpdateManyWithoutSubjectNestedInput
    department?: DepartmentUpdateOneWithoutSubjectsNestedInput
    level?: SchoolLevelUpdateOneWithoutSubjectsNestedInput
    school?: SchoolUpdateOneRequiredWithoutSubjectsNestedInput
  }

  export type SubjectUncheckedUpdateWithoutTeachersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    results?: ResultUncheckedUpdateManyWithoutSubjectNestedInput
    students?: StudentSubjectUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type TeacherUpsertWithoutSubjectsInput = {
    update: XOR<TeacherUpdateWithoutSubjectsInput, TeacherUncheckedUpdateWithoutSubjectsInput>
    create: XOR<TeacherCreateWithoutSubjectsInput, TeacherUncheckedCreateWithoutSubjectsInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutSubjectsInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutSubjectsInput, TeacherUncheckedUpdateWithoutSubjectsInput>
  }

  export type TeacherUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassUpdateManyWithoutTeacherNestedInput
    department?: DepartmentUpdateOneWithoutTeachersNestedInput
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type ClassCreateWithoutSubjectsInput = {
    id?: string
    name: string
    section?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    level?: SchoolLevelCreateNestedOneWithoutClassesInput
    school: SchoolCreateNestedOneWithoutClassesInput
    teacher?: TeacherCreateNestedOneWithoutClassesInput
    students?: StudentClassCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutSubjectsInput = {
    id?: string
    name: string
    section?: string | null
    schoolId: string
    teacherId?: string | null
    levelId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentClassUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutSubjectsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutSubjectsInput, ClassUncheckedCreateWithoutSubjectsInput>
  }

  export type SubjectCreateWithoutClassesInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    results?: ResultCreateNestedManyWithoutSubjectInput
    students?: StudentSubjectCreateNestedManyWithoutSubjectInput
    department?: DepartmentCreateNestedOneWithoutSubjectsInput
    level?: SchoolLevelCreateNestedOneWithoutSubjectsInput
    school: SchoolCreateNestedOneWithoutSubjectsInput
    teachers?: SubjectTeacherCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutClassesInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    schoolId: string
    departmentId?: string | null
    levelId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    results?: ResultUncheckedCreateNestedManyWithoutSubjectInput
    students?: StudentSubjectUncheckedCreateNestedManyWithoutSubjectInput
    teachers?: SubjectTeacherUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutClassesInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutClassesInput, SubjectUncheckedCreateWithoutClassesInput>
  }

  export type ClassUpsertWithoutSubjectsInput = {
    update: XOR<ClassUpdateWithoutSubjectsInput, ClassUncheckedUpdateWithoutSubjectsInput>
    create: XOR<ClassCreateWithoutSubjectsInput, ClassUncheckedCreateWithoutSubjectsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutSubjectsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutSubjectsInput, ClassUncheckedUpdateWithoutSubjectsInput>
  }

  export type ClassUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: SchoolLevelUpdateOneWithoutClassesNestedInput
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    teacher?: TeacherUpdateOneWithoutClassesNestedInput
    students?: StudentClassUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentClassUncheckedUpdateManyWithoutClassNestedInput
  }

  export type SubjectUpsertWithoutClassesInput = {
    update: XOR<SubjectUpdateWithoutClassesInput, SubjectUncheckedUpdateWithoutClassesInput>
    create: XOR<SubjectCreateWithoutClassesInput, SubjectUncheckedCreateWithoutClassesInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutClassesInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutClassesInput, SubjectUncheckedUpdateWithoutClassesInput>
  }

  export type SubjectUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: ResultUpdateManyWithoutSubjectNestedInput
    students?: StudentSubjectUpdateManyWithoutSubjectNestedInput
    department?: DepartmentUpdateOneWithoutSubjectsNestedInput
    level?: SchoolLevelUpdateOneWithoutSubjectsNestedInput
    school?: SchoolUpdateOneRequiredWithoutSubjectsNestedInput
    teachers?: SubjectTeacherUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: ResultUncheckedUpdateManyWithoutSubjectNestedInput
    students?: StudentSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    teachers?: SubjectTeacherUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type AcademicSessionCreateWithoutAttendanceInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutSessionsInput
    results?: ResultCreateNestedManyWithoutSessionInput
    studentClasses?: StudentClassCreateNestedManyWithoutSessionInput
    resultConfigurations?: ResultConfigurationCreateNestedManyWithoutSessionInput
  }

  export type AcademicSessionUncheckedCreateWithoutAttendanceInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    results?: ResultUncheckedCreateNestedManyWithoutSessionInput
    studentClasses?: StudentClassUncheckedCreateNestedManyWithoutSessionInput
    resultConfigurations?: ResultConfigurationUncheckedCreateNestedManyWithoutSessionInput
  }

  export type AcademicSessionCreateOrConnectWithoutAttendanceInput = {
    where: AcademicSessionWhereUniqueInput
    create: XOR<AcademicSessionCreateWithoutAttendanceInput, AcademicSessionUncheckedCreateWithoutAttendanceInput>
  }

  export type StudentCreateWithoutAttendanceInput = {
    id?: string
    admissionDate?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    religion?: string | null
    bloodGroup?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classId?: string | null
    paymentRequests?: PaymentRequestCreateNestedManyWithoutStudentInput
    results?: ResultCreateNestedManyWithoutStudentInput
    department?: DepartmentCreateNestedOneWithoutStudentsInput
    user: UserCreateNestedOneWithoutStudentInput
    classes?: StudentClassCreateNestedManyWithoutStudentInput
    parents?: StudentParentCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutAttendanceInput = {
    id?: string
    userId: string
    admissionDate?: Date | string | null
    departmentId?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    religion?: string | null
    bloodGroup?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classId?: string | null
    paymentRequests?: PaymentRequestUncheckedCreateNestedManyWithoutStudentInput
    results?: ResultUncheckedCreateNestedManyWithoutStudentInput
    classes?: StudentClassUncheckedCreateNestedManyWithoutStudentInput
    parents?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentUncheckedCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutAttendanceInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAttendanceInput, StudentUncheckedCreateWithoutAttendanceInput>
  }

  export type AcademicSessionUpsertWithoutAttendanceInput = {
    update: XOR<AcademicSessionUpdateWithoutAttendanceInput, AcademicSessionUncheckedUpdateWithoutAttendanceInput>
    create: XOR<AcademicSessionCreateWithoutAttendanceInput, AcademicSessionUncheckedCreateWithoutAttendanceInput>
    where?: AcademicSessionWhereInput
  }

  export type AcademicSessionUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: AcademicSessionWhereInput
    data: XOR<AcademicSessionUpdateWithoutAttendanceInput, AcademicSessionUncheckedUpdateWithoutAttendanceInput>
  }

  export type AcademicSessionUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutSessionsNestedInput
    results?: ResultUpdateManyWithoutSessionNestedInput
    studentClasses?: StudentClassUpdateManyWithoutSessionNestedInput
    resultConfigurations?: ResultConfigurationUpdateManyWithoutSessionNestedInput
  }

  export type AcademicSessionUncheckedUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: ResultUncheckedUpdateManyWithoutSessionNestedInput
    studentClasses?: StudentClassUncheckedUpdateManyWithoutSessionNestedInput
    resultConfigurations?: ResultConfigurationUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type StudentUpsertWithoutAttendanceInput = {
    update: XOR<StudentUpdateWithoutAttendanceInput, StudentUncheckedUpdateWithoutAttendanceInput>
    create: XOR<StudentCreateWithoutAttendanceInput, StudentUncheckedCreateWithoutAttendanceInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutAttendanceInput, StudentUncheckedUpdateWithoutAttendanceInput>
  }

  export type StudentUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentRequests?: PaymentRequestUpdateManyWithoutStudentNestedInput
    results?: ResultUpdateManyWithoutStudentNestedInput
    department?: DepartmentUpdateOneWithoutStudentsNestedInput
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    classes?: StudentClassUpdateManyWithoutStudentNestedInput
    parents?: StudentParentUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentRequests?: PaymentRequestUncheckedUpdateManyWithoutStudentNestedInput
    results?: ResultUncheckedUpdateManyWithoutStudentNestedInput
    classes?: StudentClassUncheckedUpdateManyWithoutStudentNestedInput
    parents?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUncheckedUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ComponentScoreCreateWithoutResultInput = {
    id?: string
    score: number
    createdAt?: Date | string
    updatedAt?: Date | string
    component: AssessmentComponentCreateNestedOneWithoutScoresInput
  }

  export type ComponentScoreUncheckedCreateWithoutResultInput = {
    id?: string
    score: number
    componentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComponentScoreCreateOrConnectWithoutResultInput = {
    where: ComponentScoreWhereUniqueInput
    create: XOR<ComponentScoreCreateWithoutResultInput, ComponentScoreUncheckedCreateWithoutResultInput>
  }

  export type ComponentScoreCreateManyResultInputEnvelope = {
    data: ComponentScoreCreateManyResultInput | ComponentScoreCreateManyResultInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutResultsInput = {
    id?: string
    admissionDate?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    religion?: string | null
    bloodGroup?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classId?: string | null
    attendance?: AttendanceCreateNestedManyWithoutStudentInput
    paymentRequests?: PaymentRequestCreateNestedManyWithoutStudentInput
    department?: DepartmentCreateNestedOneWithoutStudentsInput
    user: UserCreateNestedOneWithoutStudentInput
    classes?: StudentClassCreateNestedManyWithoutStudentInput
    parents?: StudentParentCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutResultsInput = {
    id?: string
    userId: string
    admissionDate?: Date | string | null
    departmentId?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    religion?: string | null
    bloodGroup?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classId?: string | null
    attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    paymentRequests?: PaymentRequestUncheckedCreateNestedManyWithoutStudentInput
    classes?: StudentClassUncheckedCreateNestedManyWithoutStudentInput
    parents?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentUncheckedCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutResultsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutResultsInput, StudentUncheckedCreateWithoutResultsInput>
  }

  export type SubjectCreateWithoutResultsInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassSubjectCreateNestedManyWithoutSubjectInput
    students?: StudentSubjectCreateNestedManyWithoutSubjectInput
    department?: DepartmentCreateNestedOneWithoutSubjectsInput
    level?: SchoolLevelCreateNestedOneWithoutSubjectsInput
    school: SchoolCreateNestedOneWithoutSubjectsInput
    teachers?: SubjectTeacherCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutResultsInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    schoolId: string
    departmentId?: string | null
    levelId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassSubjectUncheckedCreateNestedManyWithoutSubjectInput
    students?: StudentSubjectUncheckedCreateNestedManyWithoutSubjectInput
    teachers?: SubjectTeacherUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutResultsInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutResultsInput, SubjectUncheckedCreateWithoutResultsInput>
  }

  export type ResultPeriodCreateWithoutResultsInput = {
    id?: string
    name: string
    weight?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    configuration: ResultConfigurationCreateNestedOneWithoutPeriodsInput
  }

  export type ResultPeriodUncheckedCreateWithoutResultsInput = {
    id?: string
    name: string
    weight?: number
    configurationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResultPeriodCreateOrConnectWithoutResultsInput = {
    where: ResultPeriodWhereUniqueInput
    create: XOR<ResultPeriodCreateWithoutResultsInput, ResultPeriodUncheckedCreateWithoutResultsInput>
  }

  export type AcademicSessionCreateWithoutResultsInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutSessionsInput
    attendance?: AttendanceCreateNestedManyWithoutSessionInput
    studentClasses?: StudentClassCreateNestedManyWithoutSessionInput
    resultConfigurations?: ResultConfigurationCreateNestedManyWithoutSessionInput
  }

  export type AcademicSessionUncheckedCreateWithoutResultsInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    attendance?: AttendanceUncheckedCreateNestedManyWithoutSessionInput
    studentClasses?: StudentClassUncheckedCreateNestedManyWithoutSessionInput
    resultConfigurations?: ResultConfigurationUncheckedCreateNestedManyWithoutSessionInput
  }

  export type AcademicSessionCreateOrConnectWithoutResultsInput = {
    where: AcademicSessionWhereUniqueInput
    create: XOR<AcademicSessionCreateWithoutResultsInput, AcademicSessionUncheckedCreateWithoutResultsInput>
  }

  export type UserCreateWithoutApprovedResultsInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.UserRole
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    parent?: ParentCreateNestedOneWithoutUserInput
    processedPayments?: PaymentRequestCreateNestedManyWithoutProcessedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    activityLogs?: UserActivityLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutApprovedResultsInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.UserRole
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    schoolId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    parent?: ParentUncheckedCreateNestedOneWithoutUserInput
    processedPayments?: PaymentRequestUncheckedCreateNestedManyWithoutProcessedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    activityLogs?: UserActivityLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutApprovedResultsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovedResultsInput, UserUncheckedCreateWithoutApprovedResultsInput>
  }

  export type ComponentScoreUpsertWithWhereUniqueWithoutResultInput = {
    where: ComponentScoreWhereUniqueInput
    update: XOR<ComponentScoreUpdateWithoutResultInput, ComponentScoreUncheckedUpdateWithoutResultInput>
    create: XOR<ComponentScoreCreateWithoutResultInput, ComponentScoreUncheckedCreateWithoutResultInput>
  }

  export type ComponentScoreUpdateWithWhereUniqueWithoutResultInput = {
    where: ComponentScoreWhereUniqueInput
    data: XOR<ComponentScoreUpdateWithoutResultInput, ComponentScoreUncheckedUpdateWithoutResultInput>
  }

  export type ComponentScoreUpdateManyWithWhereWithoutResultInput = {
    where: ComponentScoreScalarWhereInput
    data: XOR<ComponentScoreUpdateManyMutationInput, ComponentScoreUncheckedUpdateManyWithoutResultInput>
  }

  export type ComponentScoreScalarWhereInput = {
    AND?: ComponentScoreScalarWhereInput | ComponentScoreScalarWhereInput[]
    OR?: ComponentScoreScalarWhereInput[]
    NOT?: ComponentScoreScalarWhereInput | ComponentScoreScalarWhereInput[]
    id?: StringFilter<"ComponentScore"> | string
    score?: FloatFilter<"ComponentScore"> | number
    componentId?: StringFilter<"ComponentScore"> | string
    resultId?: StringFilter<"ComponentScore"> | string
    createdAt?: DateTimeFilter<"ComponentScore"> | Date | string
    updatedAt?: DateTimeFilter<"ComponentScore"> | Date | string
  }

  export type StudentUpsertWithoutResultsInput = {
    update: XOR<StudentUpdateWithoutResultsInput, StudentUncheckedUpdateWithoutResultsInput>
    create: XOR<StudentCreateWithoutResultsInput, StudentUncheckedCreateWithoutResultsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutResultsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutResultsInput, StudentUncheckedUpdateWithoutResultsInput>
  }

  export type StudentUpdateWithoutResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    paymentRequests?: PaymentRequestUpdateManyWithoutStudentNestedInput
    department?: DepartmentUpdateOneWithoutStudentsNestedInput
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    classes?: StudentClassUpdateManyWithoutStudentNestedInput
    parents?: StudentParentUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    paymentRequests?: PaymentRequestUncheckedUpdateManyWithoutStudentNestedInput
    classes?: StudentClassUncheckedUpdateManyWithoutStudentNestedInput
    parents?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUncheckedUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type SubjectUpsertWithoutResultsInput = {
    update: XOR<SubjectUpdateWithoutResultsInput, SubjectUncheckedUpdateWithoutResultsInput>
    create: XOR<SubjectCreateWithoutResultsInput, SubjectUncheckedCreateWithoutResultsInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutResultsInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutResultsInput, SubjectUncheckedUpdateWithoutResultsInput>
  }

  export type SubjectUpdateWithoutResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassSubjectUpdateManyWithoutSubjectNestedInput
    students?: StudentSubjectUpdateManyWithoutSubjectNestedInput
    department?: DepartmentUpdateOneWithoutSubjectsNestedInput
    level?: SchoolLevelUpdateOneWithoutSubjectsNestedInput
    school?: SchoolUpdateOneRequiredWithoutSubjectsNestedInput
    teachers?: SubjectTeacherUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    students?: StudentSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    teachers?: SubjectTeacherUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type ResultPeriodUpsertWithoutResultsInput = {
    update: XOR<ResultPeriodUpdateWithoutResultsInput, ResultPeriodUncheckedUpdateWithoutResultsInput>
    create: XOR<ResultPeriodCreateWithoutResultsInput, ResultPeriodUncheckedCreateWithoutResultsInput>
    where?: ResultPeriodWhereInput
  }

  export type ResultPeriodUpdateToOneWithWhereWithoutResultsInput = {
    where?: ResultPeriodWhereInput
    data: XOR<ResultPeriodUpdateWithoutResultsInput, ResultPeriodUncheckedUpdateWithoutResultsInput>
  }

  export type ResultPeriodUpdateWithoutResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    configuration?: ResultConfigurationUpdateOneRequiredWithoutPeriodsNestedInput
  }

  export type ResultPeriodUncheckedUpdateWithoutResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    configurationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicSessionUpsertWithoutResultsInput = {
    update: XOR<AcademicSessionUpdateWithoutResultsInput, AcademicSessionUncheckedUpdateWithoutResultsInput>
    create: XOR<AcademicSessionCreateWithoutResultsInput, AcademicSessionUncheckedCreateWithoutResultsInput>
    where?: AcademicSessionWhereInput
  }

  export type AcademicSessionUpdateToOneWithWhereWithoutResultsInput = {
    where?: AcademicSessionWhereInput
    data: XOR<AcademicSessionUpdateWithoutResultsInput, AcademicSessionUncheckedUpdateWithoutResultsInput>
  }

  export type AcademicSessionUpdateWithoutResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutSessionsNestedInput
    attendance?: AttendanceUpdateManyWithoutSessionNestedInput
    studentClasses?: StudentClassUpdateManyWithoutSessionNestedInput
    resultConfigurations?: ResultConfigurationUpdateManyWithoutSessionNestedInput
  }

  export type AcademicSessionUncheckedUpdateWithoutResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: AttendanceUncheckedUpdateManyWithoutSessionNestedInput
    studentClasses?: StudentClassUncheckedUpdateManyWithoutSessionNestedInput
    resultConfigurations?: ResultConfigurationUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type UserUpsertWithoutApprovedResultsInput = {
    update: XOR<UserUpdateWithoutApprovedResultsInput, UserUncheckedUpdateWithoutApprovedResultsInput>
    create: XOR<UserCreateWithoutApprovedResultsInput, UserUncheckedCreateWithoutApprovedResultsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovedResultsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovedResultsInput, UserUncheckedUpdateWithoutApprovedResultsInput>
  }

  export type UserUpdateWithoutApprovedResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    parent?: ParentUpdateOneWithoutUserNestedInput
    processedPayments?: PaymentRequestUpdateManyWithoutProcessedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    activityLogs?: UserActivityLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovedResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    parent?: ParentUncheckedUpdateOneWithoutUserNestedInput
    processedPayments?: PaymentRequestUncheckedUpdateManyWithoutProcessedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    activityLogs?: UserActivityLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SchoolCreateWithoutEventsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email: string
    logo?: string | null
    subdomain: string
    primaryColor?: string | null
    secondaryColor?: string | null
    shortName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: AcademicSessionCreateNestedManyWithoutSchoolInput
    bills?: BillCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    departments?: DepartmentCreateNestedManyWithoutSchoolInput
    paymentAccounts?: PaymentAccountCreateNestedManyWithoutSchoolInput
    levels?: SchoolLevelCreateNestedManyWithoutSchoolInput
    subjects?: SubjectCreateNestedManyWithoutSchoolInput
    users?: UserCreateNestedManyWithoutSchoolInput
    resultConfigs?: ResultConfigurationCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutEventsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email: string
    logo?: string | null
    subdomain: string
    primaryColor?: string | null
    secondaryColor?: string | null
    shortName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: AcademicSessionUncheckedCreateNestedManyWithoutSchoolInput
    bills?: BillUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutSchoolInput
    paymentAccounts?: PaymentAccountUncheckedCreateNestedManyWithoutSchoolInput
    levels?: SchoolLevelUncheckedCreateNestedManyWithoutSchoolInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutSchoolInput
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    resultConfigs?: ResultConfigurationUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutEventsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutEventsInput, SchoolUncheckedCreateWithoutEventsInput>
  }

  export type SchoolUpsertWithoutEventsInput = {
    update: XOR<SchoolUpdateWithoutEventsInput, SchoolUncheckedUpdateWithoutEventsInput>
    create: XOR<SchoolCreateWithoutEventsInput, SchoolUncheckedCreateWithoutEventsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutEventsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutEventsInput, SchoolUncheckedUpdateWithoutEventsInput>
  }

  export type SchoolUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: StringFieldUpdateOperationsInput | string
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    shortName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: AcademicSessionUpdateManyWithoutSchoolNestedInput
    bills?: BillUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    departments?: DepartmentUpdateManyWithoutSchoolNestedInput
    paymentAccounts?: PaymentAccountUpdateManyWithoutSchoolNestedInput
    levels?: SchoolLevelUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUpdateManyWithoutSchoolNestedInput
    users?: UserUpdateManyWithoutSchoolNestedInput
    resultConfigs?: ResultConfigurationUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: StringFieldUpdateOperationsInput | string
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    shortName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: AcademicSessionUncheckedUpdateManyWithoutSchoolNestedInput
    bills?: BillUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutSchoolNestedInput
    paymentAccounts?: PaymentAccountUncheckedUpdateManyWithoutSchoolNestedInput
    levels?: SchoolLevelUncheckedUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutSchoolNestedInput
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    resultConfigs?: ResultConfigurationUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type StudentCreateWithoutSubjectsInput = {
    id?: string
    admissionDate?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    religion?: string | null
    bloodGroup?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classId?: string | null
    attendance?: AttendanceCreateNestedManyWithoutStudentInput
    paymentRequests?: PaymentRequestCreateNestedManyWithoutStudentInput
    results?: ResultCreateNestedManyWithoutStudentInput
    department?: DepartmentCreateNestedOneWithoutStudentsInput
    user: UserCreateNestedOneWithoutStudentInput
    classes?: StudentClassCreateNestedManyWithoutStudentInput
    parents?: StudentParentCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutSubjectsInput = {
    id?: string
    userId: string
    admissionDate?: Date | string | null
    departmentId?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    religion?: string | null
    bloodGroup?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classId?: string | null
    attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    paymentRequests?: PaymentRequestUncheckedCreateNestedManyWithoutStudentInput
    results?: ResultUncheckedCreateNestedManyWithoutStudentInput
    classes?: StudentClassUncheckedCreateNestedManyWithoutStudentInput
    parents?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutSubjectsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutSubjectsInput, StudentUncheckedCreateWithoutSubjectsInput>
  }

  export type SubjectCreateWithoutStudentsInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassSubjectCreateNestedManyWithoutSubjectInput
    results?: ResultCreateNestedManyWithoutSubjectInput
    department?: DepartmentCreateNestedOneWithoutSubjectsInput
    level?: SchoolLevelCreateNestedOneWithoutSubjectsInput
    school: SchoolCreateNestedOneWithoutSubjectsInput
    teachers?: SubjectTeacherCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutStudentsInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    schoolId: string
    departmentId?: string | null
    levelId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassSubjectUncheckedCreateNestedManyWithoutSubjectInput
    results?: ResultUncheckedCreateNestedManyWithoutSubjectInput
    teachers?: SubjectTeacherUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutStudentsInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutStudentsInput, SubjectUncheckedCreateWithoutStudentsInput>
  }

  export type StudentUpsertWithoutSubjectsInput = {
    update: XOR<StudentUpdateWithoutSubjectsInput, StudentUncheckedUpdateWithoutSubjectsInput>
    create: XOR<StudentCreateWithoutSubjectsInput, StudentUncheckedCreateWithoutSubjectsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutSubjectsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutSubjectsInput, StudentUncheckedUpdateWithoutSubjectsInput>
  }

  export type StudentUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    paymentRequests?: PaymentRequestUpdateManyWithoutStudentNestedInput
    results?: ResultUpdateManyWithoutStudentNestedInput
    department?: DepartmentUpdateOneWithoutStudentsNestedInput
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    classes?: StudentClassUpdateManyWithoutStudentNestedInput
    parents?: StudentParentUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    paymentRequests?: PaymentRequestUncheckedUpdateManyWithoutStudentNestedInput
    results?: ResultUncheckedUpdateManyWithoutStudentNestedInput
    classes?: StudentClassUncheckedUpdateManyWithoutStudentNestedInput
    parents?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type SubjectUpsertWithoutStudentsInput = {
    update: XOR<SubjectUpdateWithoutStudentsInput, SubjectUncheckedUpdateWithoutStudentsInput>
    create: XOR<SubjectCreateWithoutStudentsInput, SubjectUncheckedCreateWithoutStudentsInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutStudentsInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutStudentsInput, SubjectUncheckedUpdateWithoutStudentsInput>
  }

  export type SubjectUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassSubjectUpdateManyWithoutSubjectNestedInput
    results?: ResultUpdateManyWithoutSubjectNestedInput
    department?: DepartmentUpdateOneWithoutSubjectsNestedInput
    level?: SchoolLevelUpdateOneWithoutSubjectsNestedInput
    school?: SchoolUpdateOneRequiredWithoutSubjectsNestedInput
    teachers?: SubjectTeacherUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    results?: ResultUncheckedUpdateManyWithoutSubjectNestedInput
    teachers?: SubjectTeacherUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type PaymentAccountCreateWithoutBillsInput = {
    id?: string
    name: string
    accountNo: string
    bankName: string
    branchCode?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutPaymentAccountsInput
  }

  export type PaymentAccountUncheckedCreateWithoutBillsInput = {
    id?: string
    name: string
    accountNo: string
    bankName: string
    branchCode?: string | null
    description?: string | null
    isActive?: boolean
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentAccountCreateOrConnectWithoutBillsInput = {
    where: PaymentAccountWhereUniqueInput
    create: XOR<PaymentAccountCreateWithoutBillsInput, PaymentAccountUncheckedCreateWithoutBillsInput>
  }

  export type SchoolCreateWithoutBillsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email: string
    logo?: string | null
    subdomain: string
    primaryColor?: string | null
    secondaryColor?: string | null
    shortName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: AcademicSessionCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    departments?: DepartmentCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    paymentAccounts?: PaymentAccountCreateNestedManyWithoutSchoolInput
    levels?: SchoolLevelCreateNestedManyWithoutSchoolInput
    subjects?: SubjectCreateNestedManyWithoutSchoolInput
    users?: UserCreateNestedManyWithoutSchoolInput
    resultConfigs?: ResultConfigurationCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutBillsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email: string
    logo?: string | null
    subdomain: string
    primaryColor?: string | null
    secondaryColor?: string | null
    shortName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: AcademicSessionUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    paymentAccounts?: PaymentAccountUncheckedCreateNestedManyWithoutSchoolInput
    levels?: SchoolLevelUncheckedCreateNestedManyWithoutSchoolInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutSchoolInput
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    resultConfigs?: ResultConfigurationUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutBillsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutBillsInput, SchoolUncheckedCreateWithoutBillsInput>
  }

  export type BillAssignmentCreateWithoutBillInput = {
    id?: string
    targetType: $Enums.BillAssignmentType
    targetId: string
    dueDate: Date | string
    status?: $Enums.BillStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentRequests?: PaymentRequestCreateNestedManyWithoutBillAssignmentInput
    studentPayments?: StudentPaymentCreateNestedManyWithoutBillAssignmentInput
  }

  export type BillAssignmentUncheckedCreateWithoutBillInput = {
    id?: string
    targetType: $Enums.BillAssignmentType
    targetId: string
    dueDate: Date | string
    status?: $Enums.BillStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentRequests?: PaymentRequestUncheckedCreateNestedManyWithoutBillAssignmentInput
    studentPayments?: StudentPaymentUncheckedCreateNestedManyWithoutBillAssignmentInput
  }

  export type BillAssignmentCreateOrConnectWithoutBillInput = {
    where: BillAssignmentWhereUniqueInput
    create: XOR<BillAssignmentCreateWithoutBillInput, BillAssignmentUncheckedCreateWithoutBillInput>
  }

  export type BillAssignmentCreateManyBillInputEnvelope = {
    data: BillAssignmentCreateManyBillInput | BillAssignmentCreateManyBillInput[]
    skipDuplicates?: boolean
  }

  export type BillItemCreateWithoutBillInput = {
    id?: string
    name: string
    amount: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillItemUncheckedCreateWithoutBillInput = {
    id?: string
    name: string
    amount: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillItemCreateOrConnectWithoutBillInput = {
    where: BillItemWhereUniqueInput
    create: XOR<BillItemCreateWithoutBillInput, BillItemUncheckedCreateWithoutBillInput>
  }

  export type BillItemCreateManyBillInputEnvelope = {
    data: BillItemCreateManyBillInput | BillItemCreateManyBillInput[]
    skipDuplicates?: boolean
  }

  export type PaymentRequestCreateWithoutBillInput = {
    id?: string
    amount: number
    receiptUrl?: string | null
    status?: $Enums.PaymentStatus
    notes?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    billAssignment: BillAssignmentCreateNestedOneWithoutPaymentRequestsInput
    processedBy?: UserCreateNestedOneWithoutProcessedPaymentsInput
    student: StudentCreateNestedOneWithoutPaymentRequestsInput
    studentPayment?: StudentPaymentCreateNestedOneWithoutPaymentRequestsInput
  }

  export type PaymentRequestUncheckedCreateWithoutBillInput = {
    id?: string
    billAssignmentId: string
    studentPaymentId?: string | null
    studentId: string
    amount: number
    receiptUrl?: string | null
    status?: $Enums.PaymentStatus
    notes?: string | null
    processedById?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentRequestCreateOrConnectWithoutBillInput = {
    where: PaymentRequestWhereUniqueInput
    create: XOR<PaymentRequestCreateWithoutBillInput, PaymentRequestUncheckedCreateWithoutBillInput>
  }

  export type PaymentRequestCreateManyBillInputEnvelope = {
    data: PaymentRequestCreateManyBillInput | PaymentRequestCreateManyBillInput[]
    skipDuplicates?: boolean
  }

  export type PaymentAccountUpsertWithoutBillsInput = {
    update: XOR<PaymentAccountUpdateWithoutBillsInput, PaymentAccountUncheckedUpdateWithoutBillsInput>
    create: XOR<PaymentAccountCreateWithoutBillsInput, PaymentAccountUncheckedCreateWithoutBillsInput>
    where?: PaymentAccountWhereInput
  }

  export type PaymentAccountUpdateToOneWithWhereWithoutBillsInput = {
    where?: PaymentAccountWhereInput
    data: XOR<PaymentAccountUpdateWithoutBillsInput, PaymentAccountUncheckedUpdateWithoutBillsInput>
  }

  export type PaymentAccountUpdateWithoutBillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountNo?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    branchCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutPaymentAccountsNestedInput
  }

  export type PaymentAccountUncheckedUpdateWithoutBillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountNo?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    branchCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolUpsertWithoutBillsInput = {
    update: XOR<SchoolUpdateWithoutBillsInput, SchoolUncheckedUpdateWithoutBillsInput>
    create: XOR<SchoolCreateWithoutBillsInput, SchoolUncheckedCreateWithoutBillsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutBillsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutBillsInput, SchoolUncheckedUpdateWithoutBillsInput>
  }

  export type SchoolUpdateWithoutBillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: StringFieldUpdateOperationsInput | string
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    shortName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: AcademicSessionUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    departments?: DepartmentUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    paymentAccounts?: PaymentAccountUpdateManyWithoutSchoolNestedInput
    levels?: SchoolLevelUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUpdateManyWithoutSchoolNestedInput
    users?: UserUpdateManyWithoutSchoolNestedInput
    resultConfigs?: ResultConfigurationUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutBillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: StringFieldUpdateOperationsInput | string
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    shortName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: AcademicSessionUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    paymentAccounts?: PaymentAccountUncheckedUpdateManyWithoutSchoolNestedInput
    levels?: SchoolLevelUncheckedUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutSchoolNestedInput
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    resultConfigs?: ResultConfigurationUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type BillAssignmentUpsertWithWhereUniqueWithoutBillInput = {
    where: BillAssignmentWhereUniqueInput
    update: XOR<BillAssignmentUpdateWithoutBillInput, BillAssignmentUncheckedUpdateWithoutBillInput>
    create: XOR<BillAssignmentCreateWithoutBillInput, BillAssignmentUncheckedCreateWithoutBillInput>
  }

  export type BillAssignmentUpdateWithWhereUniqueWithoutBillInput = {
    where: BillAssignmentWhereUniqueInput
    data: XOR<BillAssignmentUpdateWithoutBillInput, BillAssignmentUncheckedUpdateWithoutBillInput>
  }

  export type BillAssignmentUpdateManyWithWhereWithoutBillInput = {
    where: BillAssignmentScalarWhereInput
    data: XOR<BillAssignmentUpdateManyMutationInput, BillAssignmentUncheckedUpdateManyWithoutBillInput>
  }

  export type BillAssignmentScalarWhereInput = {
    AND?: BillAssignmentScalarWhereInput | BillAssignmentScalarWhereInput[]
    OR?: BillAssignmentScalarWhereInput[]
    NOT?: BillAssignmentScalarWhereInput | BillAssignmentScalarWhereInput[]
    id?: StringFilter<"BillAssignment"> | string
    billId?: StringFilter<"BillAssignment"> | string
    targetType?: EnumBillAssignmentTypeFilter<"BillAssignment"> | $Enums.BillAssignmentType
    targetId?: StringFilter<"BillAssignment"> | string
    dueDate?: DateTimeFilter<"BillAssignment"> | Date | string
    status?: EnumBillStatusFilter<"BillAssignment"> | $Enums.BillStatus
    createdAt?: DateTimeFilter<"BillAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"BillAssignment"> | Date | string
  }

  export type BillItemUpsertWithWhereUniqueWithoutBillInput = {
    where: BillItemWhereUniqueInput
    update: XOR<BillItemUpdateWithoutBillInput, BillItemUncheckedUpdateWithoutBillInput>
    create: XOR<BillItemCreateWithoutBillInput, BillItemUncheckedCreateWithoutBillInput>
  }

  export type BillItemUpdateWithWhereUniqueWithoutBillInput = {
    where: BillItemWhereUniqueInput
    data: XOR<BillItemUpdateWithoutBillInput, BillItemUncheckedUpdateWithoutBillInput>
  }

  export type BillItemUpdateManyWithWhereWithoutBillInput = {
    where: BillItemScalarWhereInput
    data: XOR<BillItemUpdateManyMutationInput, BillItemUncheckedUpdateManyWithoutBillInput>
  }

  export type BillItemScalarWhereInput = {
    AND?: BillItemScalarWhereInput | BillItemScalarWhereInput[]
    OR?: BillItemScalarWhereInput[]
    NOT?: BillItemScalarWhereInput | BillItemScalarWhereInput[]
    id?: StringFilter<"BillItem"> | string
    billId?: StringFilter<"BillItem"> | string
    name?: StringFilter<"BillItem"> | string
    amount?: FloatFilter<"BillItem"> | number
    description?: StringNullableFilter<"BillItem"> | string | null
    createdAt?: DateTimeFilter<"BillItem"> | Date | string
    updatedAt?: DateTimeFilter<"BillItem"> | Date | string
  }

  export type PaymentRequestUpsertWithWhereUniqueWithoutBillInput = {
    where: PaymentRequestWhereUniqueInput
    update: XOR<PaymentRequestUpdateWithoutBillInput, PaymentRequestUncheckedUpdateWithoutBillInput>
    create: XOR<PaymentRequestCreateWithoutBillInput, PaymentRequestUncheckedCreateWithoutBillInput>
  }

  export type PaymentRequestUpdateWithWhereUniqueWithoutBillInput = {
    where: PaymentRequestWhereUniqueInput
    data: XOR<PaymentRequestUpdateWithoutBillInput, PaymentRequestUncheckedUpdateWithoutBillInput>
  }

  export type PaymentRequestUpdateManyWithWhereWithoutBillInput = {
    where: PaymentRequestScalarWhereInput
    data: XOR<PaymentRequestUpdateManyMutationInput, PaymentRequestUncheckedUpdateManyWithoutBillInput>
  }

  export type BillCreateWithoutItemsInput = {
    id?: string
    name: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    account: PaymentAccountCreateNestedOneWithoutBillsInput
    school: SchoolCreateNestedOneWithoutBillsInput
    assignments?: BillAssignmentCreateNestedManyWithoutBillInput
    paymentRequests?: PaymentRequestCreateNestedManyWithoutBillInput
  }

  export type BillUncheckedCreateWithoutItemsInput = {
    id?: string
    name: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schoolId: string
    accountId: string
    assignments?: BillAssignmentUncheckedCreateNestedManyWithoutBillInput
    paymentRequests?: PaymentRequestUncheckedCreateNestedManyWithoutBillInput
  }

  export type BillCreateOrConnectWithoutItemsInput = {
    where: BillWhereUniqueInput
    create: XOR<BillCreateWithoutItemsInput, BillUncheckedCreateWithoutItemsInput>
  }

  export type BillUpsertWithoutItemsInput = {
    update: XOR<BillUpdateWithoutItemsInput, BillUncheckedUpdateWithoutItemsInput>
    create: XOR<BillCreateWithoutItemsInput, BillUncheckedCreateWithoutItemsInput>
    where?: BillWhereInput
  }

  export type BillUpdateToOneWithWhereWithoutItemsInput = {
    where?: BillWhereInput
    data: XOR<BillUpdateWithoutItemsInput, BillUncheckedUpdateWithoutItemsInput>
  }

  export type BillUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: PaymentAccountUpdateOneRequiredWithoutBillsNestedInput
    school?: SchoolUpdateOneRequiredWithoutBillsNestedInput
    assignments?: BillAssignmentUpdateManyWithoutBillNestedInput
    paymentRequests?: PaymentRequestUpdateManyWithoutBillNestedInput
  }

  export type BillUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    assignments?: BillAssignmentUncheckedUpdateManyWithoutBillNestedInput
    paymentRequests?: PaymentRequestUncheckedUpdateManyWithoutBillNestedInput
  }

  export type BillCreateWithoutAccountInput = {
    id?: string
    name: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutBillsInput
    assignments?: BillAssignmentCreateNestedManyWithoutBillInput
    items?: BillItemCreateNestedManyWithoutBillInput
    paymentRequests?: PaymentRequestCreateNestedManyWithoutBillInput
  }

  export type BillUncheckedCreateWithoutAccountInput = {
    id?: string
    name: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schoolId: string
    assignments?: BillAssignmentUncheckedCreateNestedManyWithoutBillInput
    items?: BillItemUncheckedCreateNestedManyWithoutBillInput
    paymentRequests?: PaymentRequestUncheckedCreateNestedManyWithoutBillInput
  }

  export type BillCreateOrConnectWithoutAccountInput = {
    where: BillWhereUniqueInput
    create: XOR<BillCreateWithoutAccountInput, BillUncheckedCreateWithoutAccountInput>
  }

  export type BillCreateManyAccountInputEnvelope = {
    data: BillCreateManyAccountInput | BillCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type SchoolCreateWithoutPaymentAccountsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email: string
    logo?: string | null
    subdomain: string
    primaryColor?: string | null
    secondaryColor?: string | null
    shortName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: AcademicSessionCreateNestedManyWithoutSchoolInput
    bills?: BillCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    departments?: DepartmentCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    levels?: SchoolLevelCreateNestedManyWithoutSchoolInput
    subjects?: SubjectCreateNestedManyWithoutSchoolInput
    users?: UserCreateNestedManyWithoutSchoolInput
    resultConfigs?: ResultConfigurationCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutPaymentAccountsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email: string
    logo?: string | null
    subdomain: string
    primaryColor?: string | null
    secondaryColor?: string | null
    shortName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: AcademicSessionUncheckedCreateNestedManyWithoutSchoolInput
    bills?: BillUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    levels?: SchoolLevelUncheckedCreateNestedManyWithoutSchoolInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutSchoolInput
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    resultConfigs?: ResultConfigurationUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutPaymentAccountsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutPaymentAccountsInput, SchoolUncheckedCreateWithoutPaymentAccountsInput>
  }

  export type BillUpsertWithWhereUniqueWithoutAccountInput = {
    where: BillWhereUniqueInput
    update: XOR<BillUpdateWithoutAccountInput, BillUncheckedUpdateWithoutAccountInput>
    create: XOR<BillCreateWithoutAccountInput, BillUncheckedCreateWithoutAccountInput>
  }

  export type BillUpdateWithWhereUniqueWithoutAccountInput = {
    where: BillWhereUniqueInput
    data: XOR<BillUpdateWithoutAccountInput, BillUncheckedUpdateWithoutAccountInput>
  }

  export type BillUpdateManyWithWhereWithoutAccountInput = {
    where: BillScalarWhereInput
    data: XOR<BillUpdateManyMutationInput, BillUncheckedUpdateManyWithoutAccountInput>
  }

  export type SchoolUpsertWithoutPaymentAccountsInput = {
    update: XOR<SchoolUpdateWithoutPaymentAccountsInput, SchoolUncheckedUpdateWithoutPaymentAccountsInput>
    create: XOR<SchoolCreateWithoutPaymentAccountsInput, SchoolUncheckedCreateWithoutPaymentAccountsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutPaymentAccountsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutPaymentAccountsInput, SchoolUncheckedUpdateWithoutPaymentAccountsInput>
  }

  export type SchoolUpdateWithoutPaymentAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: StringFieldUpdateOperationsInput | string
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    shortName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: AcademicSessionUpdateManyWithoutSchoolNestedInput
    bills?: BillUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    departments?: DepartmentUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    levels?: SchoolLevelUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUpdateManyWithoutSchoolNestedInput
    users?: UserUpdateManyWithoutSchoolNestedInput
    resultConfigs?: ResultConfigurationUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutPaymentAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: StringFieldUpdateOperationsInput | string
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    shortName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: AcademicSessionUncheckedUpdateManyWithoutSchoolNestedInput
    bills?: BillUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    levels?: SchoolLevelUncheckedUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutSchoolNestedInput
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    resultConfigs?: ResultConfigurationUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type BillCreateWithoutAssignmentsInput = {
    id?: string
    name: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    account: PaymentAccountCreateNestedOneWithoutBillsInput
    school: SchoolCreateNestedOneWithoutBillsInput
    items?: BillItemCreateNestedManyWithoutBillInput
    paymentRequests?: PaymentRequestCreateNestedManyWithoutBillInput
  }

  export type BillUncheckedCreateWithoutAssignmentsInput = {
    id?: string
    name: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schoolId: string
    accountId: string
    items?: BillItemUncheckedCreateNestedManyWithoutBillInput
    paymentRequests?: PaymentRequestUncheckedCreateNestedManyWithoutBillInput
  }

  export type BillCreateOrConnectWithoutAssignmentsInput = {
    where: BillWhereUniqueInput
    create: XOR<BillCreateWithoutAssignmentsInput, BillUncheckedCreateWithoutAssignmentsInput>
  }

  export type PaymentRequestCreateWithoutBillAssignmentInput = {
    id?: string
    amount: number
    receiptUrl?: string | null
    status?: $Enums.PaymentStatus
    notes?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bill: BillCreateNestedOneWithoutPaymentRequestsInput
    processedBy?: UserCreateNestedOneWithoutProcessedPaymentsInput
    student: StudentCreateNestedOneWithoutPaymentRequestsInput
    studentPayment?: StudentPaymentCreateNestedOneWithoutPaymentRequestsInput
  }

  export type PaymentRequestUncheckedCreateWithoutBillAssignmentInput = {
    id?: string
    billId: string
    studentPaymentId?: string | null
    studentId: string
    amount: number
    receiptUrl?: string | null
    status?: $Enums.PaymentStatus
    notes?: string | null
    processedById?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentRequestCreateOrConnectWithoutBillAssignmentInput = {
    where: PaymentRequestWhereUniqueInput
    create: XOR<PaymentRequestCreateWithoutBillAssignmentInput, PaymentRequestUncheckedCreateWithoutBillAssignmentInput>
  }

  export type PaymentRequestCreateManyBillAssignmentInputEnvelope = {
    data: PaymentRequestCreateManyBillAssignmentInput | PaymentRequestCreateManyBillAssignmentInput[]
    skipDuplicates?: boolean
  }

  export type StudentPaymentCreateWithoutBillAssignmentInput = {
    id?: string
    amountPaid: number
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentRequests?: PaymentRequestCreateNestedManyWithoutStudentPaymentInput
    student: StudentCreateNestedOneWithoutPaymentsInput
  }

  export type StudentPaymentUncheckedCreateWithoutBillAssignmentInput = {
    id?: string
    studentId: string
    amountPaid: number
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentRequests?: PaymentRequestUncheckedCreateNestedManyWithoutStudentPaymentInput
  }

  export type StudentPaymentCreateOrConnectWithoutBillAssignmentInput = {
    where: StudentPaymentWhereUniqueInput
    create: XOR<StudentPaymentCreateWithoutBillAssignmentInput, StudentPaymentUncheckedCreateWithoutBillAssignmentInput>
  }

  export type StudentPaymentCreateManyBillAssignmentInputEnvelope = {
    data: StudentPaymentCreateManyBillAssignmentInput | StudentPaymentCreateManyBillAssignmentInput[]
    skipDuplicates?: boolean
  }

  export type BillUpsertWithoutAssignmentsInput = {
    update: XOR<BillUpdateWithoutAssignmentsInput, BillUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<BillCreateWithoutAssignmentsInput, BillUncheckedCreateWithoutAssignmentsInput>
    where?: BillWhereInput
  }

  export type BillUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: BillWhereInput
    data: XOR<BillUpdateWithoutAssignmentsInput, BillUncheckedUpdateWithoutAssignmentsInput>
  }

  export type BillUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: PaymentAccountUpdateOneRequiredWithoutBillsNestedInput
    school?: SchoolUpdateOneRequiredWithoutBillsNestedInput
    items?: BillItemUpdateManyWithoutBillNestedInput
    paymentRequests?: PaymentRequestUpdateManyWithoutBillNestedInput
  }

  export type BillUncheckedUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    items?: BillItemUncheckedUpdateManyWithoutBillNestedInput
    paymentRequests?: PaymentRequestUncheckedUpdateManyWithoutBillNestedInput
  }

  export type PaymentRequestUpsertWithWhereUniqueWithoutBillAssignmentInput = {
    where: PaymentRequestWhereUniqueInput
    update: XOR<PaymentRequestUpdateWithoutBillAssignmentInput, PaymentRequestUncheckedUpdateWithoutBillAssignmentInput>
    create: XOR<PaymentRequestCreateWithoutBillAssignmentInput, PaymentRequestUncheckedCreateWithoutBillAssignmentInput>
  }

  export type PaymentRequestUpdateWithWhereUniqueWithoutBillAssignmentInput = {
    where: PaymentRequestWhereUniqueInput
    data: XOR<PaymentRequestUpdateWithoutBillAssignmentInput, PaymentRequestUncheckedUpdateWithoutBillAssignmentInput>
  }

  export type PaymentRequestUpdateManyWithWhereWithoutBillAssignmentInput = {
    where: PaymentRequestScalarWhereInput
    data: XOR<PaymentRequestUpdateManyMutationInput, PaymentRequestUncheckedUpdateManyWithoutBillAssignmentInput>
  }

  export type StudentPaymentUpsertWithWhereUniqueWithoutBillAssignmentInput = {
    where: StudentPaymentWhereUniqueInput
    update: XOR<StudentPaymentUpdateWithoutBillAssignmentInput, StudentPaymentUncheckedUpdateWithoutBillAssignmentInput>
    create: XOR<StudentPaymentCreateWithoutBillAssignmentInput, StudentPaymentUncheckedCreateWithoutBillAssignmentInput>
  }

  export type StudentPaymentUpdateWithWhereUniqueWithoutBillAssignmentInput = {
    where: StudentPaymentWhereUniqueInput
    data: XOR<StudentPaymentUpdateWithoutBillAssignmentInput, StudentPaymentUncheckedUpdateWithoutBillAssignmentInput>
  }

  export type StudentPaymentUpdateManyWithWhereWithoutBillAssignmentInput = {
    where: StudentPaymentScalarWhereInput
    data: XOR<StudentPaymentUpdateManyMutationInput, StudentPaymentUncheckedUpdateManyWithoutBillAssignmentInput>
  }

  export type PaymentRequestCreateWithoutStudentPaymentInput = {
    id?: string
    amount: number
    receiptUrl?: string | null
    status?: $Enums.PaymentStatus
    notes?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    billAssignment: BillAssignmentCreateNestedOneWithoutPaymentRequestsInput
    bill: BillCreateNestedOneWithoutPaymentRequestsInput
    processedBy?: UserCreateNestedOneWithoutProcessedPaymentsInput
    student: StudentCreateNestedOneWithoutPaymentRequestsInput
  }

  export type PaymentRequestUncheckedCreateWithoutStudentPaymentInput = {
    id?: string
    billId: string
    billAssignmentId: string
    studentId: string
    amount: number
    receiptUrl?: string | null
    status?: $Enums.PaymentStatus
    notes?: string | null
    processedById?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentRequestCreateOrConnectWithoutStudentPaymentInput = {
    where: PaymentRequestWhereUniqueInput
    create: XOR<PaymentRequestCreateWithoutStudentPaymentInput, PaymentRequestUncheckedCreateWithoutStudentPaymentInput>
  }

  export type PaymentRequestCreateManyStudentPaymentInputEnvelope = {
    data: PaymentRequestCreateManyStudentPaymentInput | PaymentRequestCreateManyStudentPaymentInput[]
    skipDuplicates?: boolean
  }

  export type BillAssignmentCreateWithoutStudentPaymentsInput = {
    id?: string
    targetType: $Enums.BillAssignmentType
    targetId: string
    dueDate: Date | string
    status?: $Enums.BillStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    bill: BillCreateNestedOneWithoutAssignmentsInput
    paymentRequests?: PaymentRequestCreateNestedManyWithoutBillAssignmentInput
  }

  export type BillAssignmentUncheckedCreateWithoutStudentPaymentsInput = {
    id?: string
    billId: string
    targetType: $Enums.BillAssignmentType
    targetId: string
    dueDate: Date | string
    status?: $Enums.BillStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentRequests?: PaymentRequestUncheckedCreateNestedManyWithoutBillAssignmentInput
  }

  export type BillAssignmentCreateOrConnectWithoutStudentPaymentsInput = {
    where: BillAssignmentWhereUniqueInput
    create: XOR<BillAssignmentCreateWithoutStudentPaymentsInput, BillAssignmentUncheckedCreateWithoutStudentPaymentsInput>
  }

  export type StudentCreateWithoutPaymentsInput = {
    id?: string
    admissionDate?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    religion?: string | null
    bloodGroup?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classId?: string | null
    attendance?: AttendanceCreateNestedManyWithoutStudentInput
    paymentRequests?: PaymentRequestCreateNestedManyWithoutStudentInput
    results?: ResultCreateNestedManyWithoutStudentInput
    department?: DepartmentCreateNestedOneWithoutStudentsInput
    user: UserCreateNestedOneWithoutStudentInput
    classes?: StudentClassCreateNestedManyWithoutStudentInput
    parents?: StudentParentCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutPaymentsInput = {
    id?: string
    userId: string
    admissionDate?: Date | string | null
    departmentId?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    religion?: string | null
    bloodGroup?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classId?: string | null
    attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    paymentRequests?: PaymentRequestUncheckedCreateNestedManyWithoutStudentInput
    results?: ResultUncheckedCreateNestedManyWithoutStudentInput
    classes?: StudentClassUncheckedCreateNestedManyWithoutStudentInput
    parents?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutPaymentsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutPaymentsInput, StudentUncheckedCreateWithoutPaymentsInput>
  }

  export type PaymentRequestUpsertWithWhereUniqueWithoutStudentPaymentInput = {
    where: PaymentRequestWhereUniqueInput
    update: XOR<PaymentRequestUpdateWithoutStudentPaymentInput, PaymentRequestUncheckedUpdateWithoutStudentPaymentInput>
    create: XOR<PaymentRequestCreateWithoutStudentPaymentInput, PaymentRequestUncheckedCreateWithoutStudentPaymentInput>
  }

  export type PaymentRequestUpdateWithWhereUniqueWithoutStudentPaymentInput = {
    where: PaymentRequestWhereUniqueInput
    data: XOR<PaymentRequestUpdateWithoutStudentPaymentInput, PaymentRequestUncheckedUpdateWithoutStudentPaymentInput>
  }

  export type PaymentRequestUpdateManyWithWhereWithoutStudentPaymentInput = {
    where: PaymentRequestScalarWhereInput
    data: XOR<PaymentRequestUpdateManyMutationInput, PaymentRequestUncheckedUpdateManyWithoutStudentPaymentInput>
  }

  export type BillAssignmentUpsertWithoutStudentPaymentsInput = {
    update: XOR<BillAssignmentUpdateWithoutStudentPaymentsInput, BillAssignmentUncheckedUpdateWithoutStudentPaymentsInput>
    create: XOR<BillAssignmentCreateWithoutStudentPaymentsInput, BillAssignmentUncheckedCreateWithoutStudentPaymentsInput>
    where?: BillAssignmentWhereInput
  }

  export type BillAssignmentUpdateToOneWithWhereWithoutStudentPaymentsInput = {
    where?: BillAssignmentWhereInput
    data: XOR<BillAssignmentUpdateWithoutStudentPaymentsInput, BillAssignmentUncheckedUpdateWithoutStudentPaymentsInput>
  }

  export type BillAssignmentUpdateWithoutStudentPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumBillAssignmentTypeFieldUpdateOperationsInput | $Enums.BillAssignmentType
    targetId?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bill?: BillUpdateOneRequiredWithoutAssignmentsNestedInput
    paymentRequests?: PaymentRequestUpdateManyWithoutBillAssignmentNestedInput
  }

  export type BillAssignmentUncheckedUpdateWithoutStudentPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    billId?: StringFieldUpdateOperationsInput | string
    targetType?: EnumBillAssignmentTypeFieldUpdateOperationsInput | $Enums.BillAssignmentType
    targetId?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentRequests?: PaymentRequestUncheckedUpdateManyWithoutBillAssignmentNestedInput
  }

  export type StudentUpsertWithoutPaymentsInput = {
    update: XOR<StudentUpdateWithoutPaymentsInput, StudentUncheckedUpdateWithoutPaymentsInput>
    create: XOR<StudentCreateWithoutPaymentsInput, StudentUncheckedCreateWithoutPaymentsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutPaymentsInput, StudentUncheckedUpdateWithoutPaymentsInput>
  }

  export type StudentUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    paymentRequests?: PaymentRequestUpdateManyWithoutStudentNestedInput
    results?: ResultUpdateManyWithoutStudentNestedInput
    department?: DepartmentUpdateOneWithoutStudentsNestedInput
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    classes?: StudentClassUpdateManyWithoutStudentNestedInput
    parents?: StudentParentUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    paymentRequests?: PaymentRequestUncheckedUpdateManyWithoutStudentNestedInput
    results?: ResultUncheckedUpdateManyWithoutStudentNestedInput
    classes?: StudentClassUncheckedUpdateManyWithoutStudentNestedInput
    parents?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type BillAssignmentCreateWithoutPaymentRequestsInput = {
    id?: string
    targetType: $Enums.BillAssignmentType
    targetId: string
    dueDate: Date | string
    status?: $Enums.BillStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    bill: BillCreateNestedOneWithoutAssignmentsInput
    studentPayments?: StudentPaymentCreateNestedManyWithoutBillAssignmentInput
  }

  export type BillAssignmentUncheckedCreateWithoutPaymentRequestsInput = {
    id?: string
    billId: string
    targetType: $Enums.BillAssignmentType
    targetId: string
    dueDate: Date | string
    status?: $Enums.BillStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    studentPayments?: StudentPaymentUncheckedCreateNestedManyWithoutBillAssignmentInput
  }

  export type BillAssignmentCreateOrConnectWithoutPaymentRequestsInput = {
    where: BillAssignmentWhereUniqueInput
    create: XOR<BillAssignmentCreateWithoutPaymentRequestsInput, BillAssignmentUncheckedCreateWithoutPaymentRequestsInput>
  }

  export type BillCreateWithoutPaymentRequestsInput = {
    id?: string
    name: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    account: PaymentAccountCreateNestedOneWithoutBillsInput
    school: SchoolCreateNestedOneWithoutBillsInput
    assignments?: BillAssignmentCreateNestedManyWithoutBillInput
    items?: BillItemCreateNestedManyWithoutBillInput
  }

  export type BillUncheckedCreateWithoutPaymentRequestsInput = {
    id?: string
    name: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schoolId: string
    accountId: string
    assignments?: BillAssignmentUncheckedCreateNestedManyWithoutBillInput
    items?: BillItemUncheckedCreateNestedManyWithoutBillInput
  }

  export type BillCreateOrConnectWithoutPaymentRequestsInput = {
    where: BillWhereUniqueInput
    create: XOR<BillCreateWithoutPaymentRequestsInput, BillUncheckedCreateWithoutPaymentRequestsInput>
  }

  export type UserCreateWithoutProcessedPaymentsInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.UserRole
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    parent?: ParentCreateNestedOneWithoutUserInput
    approvedResults?: ResultCreateNestedManyWithoutApprovedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    activityLogs?: UserActivityLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProcessedPaymentsInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.UserRole
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    schoolId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    parent?: ParentUncheckedCreateNestedOneWithoutUserInput
    approvedResults?: ResultUncheckedCreateNestedManyWithoutApprovedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    activityLogs?: UserActivityLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProcessedPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProcessedPaymentsInput, UserUncheckedCreateWithoutProcessedPaymentsInput>
  }

  export type StudentCreateWithoutPaymentRequestsInput = {
    id?: string
    admissionDate?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    religion?: string | null
    bloodGroup?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classId?: string | null
    attendance?: AttendanceCreateNestedManyWithoutStudentInput
    results?: ResultCreateNestedManyWithoutStudentInput
    department?: DepartmentCreateNestedOneWithoutStudentsInput
    user: UserCreateNestedOneWithoutStudentInput
    classes?: StudentClassCreateNestedManyWithoutStudentInput
    parents?: StudentParentCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutPaymentRequestsInput = {
    id?: string
    userId: string
    admissionDate?: Date | string | null
    departmentId?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    religion?: string | null
    bloodGroup?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classId?: string | null
    attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    results?: ResultUncheckedCreateNestedManyWithoutStudentInput
    classes?: StudentClassUncheckedCreateNestedManyWithoutStudentInput
    parents?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentUncheckedCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutPaymentRequestsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutPaymentRequestsInput, StudentUncheckedCreateWithoutPaymentRequestsInput>
  }

  export type StudentPaymentCreateWithoutPaymentRequestsInput = {
    id?: string
    amountPaid: number
    createdAt?: Date | string
    updatedAt?: Date | string
    billAssignment: BillAssignmentCreateNestedOneWithoutStudentPaymentsInput
    student: StudentCreateNestedOneWithoutPaymentsInput
  }

  export type StudentPaymentUncheckedCreateWithoutPaymentRequestsInput = {
    id?: string
    billAssignmentId: string
    studentId: string
    amountPaid: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentPaymentCreateOrConnectWithoutPaymentRequestsInput = {
    where: StudentPaymentWhereUniqueInput
    create: XOR<StudentPaymentCreateWithoutPaymentRequestsInput, StudentPaymentUncheckedCreateWithoutPaymentRequestsInput>
  }

  export type BillAssignmentUpsertWithoutPaymentRequestsInput = {
    update: XOR<BillAssignmentUpdateWithoutPaymentRequestsInput, BillAssignmentUncheckedUpdateWithoutPaymentRequestsInput>
    create: XOR<BillAssignmentCreateWithoutPaymentRequestsInput, BillAssignmentUncheckedCreateWithoutPaymentRequestsInput>
    where?: BillAssignmentWhereInput
  }

  export type BillAssignmentUpdateToOneWithWhereWithoutPaymentRequestsInput = {
    where?: BillAssignmentWhereInput
    data: XOR<BillAssignmentUpdateWithoutPaymentRequestsInput, BillAssignmentUncheckedUpdateWithoutPaymentRequestsInput>
  }

  export type BillAssignmentUpdateWithoutPaymentRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumBillAssignmentTypeFieldUpdateOperationsInput | $Enums.BillAssignmentType
    targetId?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bill?: BillUpdateOneRequiredWithoutAssignmentsNestedInput
    studentPayments?: StudentPaymentUpdateManyWithoutBillAssignmentNestedInput
  }

  export type BillAssignmentUncheckedUpdateWithoutPaymentRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    billId?: StringFieldUpdateOperationsInput | string
    targetType?: EnumBillAssignmentTypeFieldUpdateOperationsInput | $Enums.BillAssignmentType
    targetId?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentPayments?: StudentPaymentUncheckedUpdateManyWithoutBillAssignmentNestedInput
  }

  export type BillUpsertWithoutPaymentRequestsInput = {
    update: XOR<BillUpdateWithoutPaymentRequestsInput, BillUncheckedUpdateWithoutPaymentRequestsInput>
    create: XOR<BillCreateWithoutPaymentRequestsInput, BillUncheckedCreateWithoutPaymentRequestsInput>
    where?: BillWhereInput
  }

  export type BillUpdateToOneWithWhereWithoutPaymentRequestsInput = {
    where?: BillWhereInput
    data: XOR<BillUpdateWithoutPaymentRequestsInput, BillUncheckedUpdateWithoutPaymentRequestsInput>
  }

  export type BillUpdateWithoutPaymentRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: PaymentAccountUpdateOneRequiredWithoutBillsNestedInput
    school?: SchoolUpdateOneRequiredWithoutBillsNestedInput
    assignments?: BillAssignmentUpdateManyWithoutBillNestedInput
    items?: BillItemUpdateManyWithoutBillNestedInput
  }

  export type BillUncheckedUpdateWithoutPaymentRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    assignments?: BillAssignmentUncheckedUpdateManyWithoutBillNestedInput
    items?: BillItemUncheckedUpdateManyWithoutBillNestedInput
  }

  export type UserUpsertWithoutProcessedPaymentsInput = {
    update: XOR<UserUpdateWithoutProcessedPaymentsInput, UserUncheckedUpdateWithoutProcessedPaymentsInput>
    create: XOR<UserCreateWithoutProcessedPaymentsInput, UserUncheckedCreateWithoutProcessedPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProcessedPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProcessedPaymentsInput, UserUncheckedUpdateWithoutProcessedPaymentsInput>
  }

  export type UserUpdateWithoutProcessedPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    parent?: ParentUpdateOneWithoutUserNestedInput
    approvedResults?: ResultUpdateManyWithoutApprovedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    activityLogs?: UserActivityLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProcessedPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    parent?: ParentUncheckedUpdateOneWithoutUserNestedInput
    approvedResults?: ResultUncheckedUpdateManyWithoutApprovedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    activityLogs?: UserActivityLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StudentUpsertWithoutPaymentRequestsInput = {
    update: XOR<StudentUpdateWithoutPaymentRequestsInput, StudentUncheckedUpdateWithoutPaymentRequestsInput>
    create: XOR<StudentCreateWithoutPaymentRequestsInput, StudentUncheckedCreateWithoutPaymentRequestsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutPaymentRequestsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutPaymentRequestsInput, StudentUncheckedUpdateWithoutPaymentRequestsInput>
  }

  export type StudentUpdateWithoutPaymentRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    results?: ResultUpdateManyWithoutStudentNestedInput
    department?: DepartmentUpdateOneWithoutStudentsNestedInput
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    classes?: StudentClassUpdateManyWithoutStudentNestedInput
    parents?: StudentParentUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutPaymentRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    results?: ResultUncheckedUpdateManyWithoutStudentNestedInput
    classes?: StudentClassUncheckedUpdateManyWithoutStudentNestedInput
    parents?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUncheckedUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentPaymentUpsertWithoutPaymentRequestsInput = {
    update: XOR<StudentPaymentUpdateWithoutPaymentRequestsInput, StudentPaymentUncheckedUpdateWithoutPaymentRequestsInput>
    create: XOR<StudentPaymentCreateWithoutPaymentRequestsInput, StudentPaymentUncheckedCreateWithoutPaymentRequestsInput>
    where?: StudentPaymentWhereInput
  }

  export type StudentPaymentUpdateToOneWithWhereWithoutPaymentRequestsInput = {
    where?: StudentPaymentWhereInput
    data: XOR<StudentPaymentUpdateWithoutPaymentRequestsInput, StudentPaymentUncheckedUpdateWithoutPaymentRequestsInput>
  }

  export type StudentPaymentUpdateWithoutPaymentRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billAssignment?: BillAssignmentUpdateOneRequiredWithoutStudentPaymentsNestedInput
    student?: StudentUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type StudentPaymentUncheckedUpdateWithoutPaymentRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    billAssignmentId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassCreateWithoutLevelInput = {
    id?: string
    name: string
    section?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutClassesInput
    teacher?: TeacherCreateNestedOneWithoutClassesInput
    subjects?: ClassSubjectCreateNestedManyWithoutClassInput
    students?: StudentClassCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutLevelInput = {
    id?: string
    name: string
    section?: string | null
    schoolId: string
    teacherId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: ClassSubjectUncheckedCreateNestedManyWithoutClassInput
    students?: StudentClassUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutLevelInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutLevelInput, ClassUncheckedCreateWithoutLevelInput>
  }

  export type ClassCreateManyLevelInputEnvelope = {
    data: ClassCreateManyLevelInput | ClassCreateManyLevelInput[]
    skipDuplicates?: boolean
  }

  export type SchoolCreateWithoutLevelsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email: string
    logo?: string | null
    subdomain: string
    primaryColor?: string | null
    secondaryColor?: string | null
    shortName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: AcademicSessionCreateNestedManyWithoutSchoolInput
    bills?: BillCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    departments?: DepartmentCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    paymentAccounts?: PaymentAccountCreateNestedManyWithoutSchoolInput
    subjects?: SubjectCreateNestedManyWithoutSchoolInput
    users?: UserCreateNestedManyWithoutSchoolInput
    resultConfigs?: ResultConfigurationCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutLevelsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email: string
    logo?: string | null
    subdomain: string
    primaryColor?: string | null
    secondaryColor?: string | null
    shortName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: AcademicSessionUncheckedCreateNestedManyWithoutSchoolInput
    bills?: BillUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    paymentAccounts?: PaymentAccountUncheckedCreateNestedManyWithoutSchoolInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutSchoolInput
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    resultConfigs?: ResultConfigurationUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutLevelsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutLevelsInput, SchoolUncheckedCreateWithoutLevelsInput>
  }

  export type SubjectCreateWithoutLevelInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassSubjectCreateNestedManyWithoutSubjectInput
    results?: ResultCreateNestedManyWithoutSubjectInput
    students?: StudentSubjectCreateNestedManyWithoutSubjectInput
    department?: DepartmentCreateNestedOneWithoutSubjectsInput
    school: SchoolCreateNestedOneWithoutSubjectsInput
    teachers?: SubjectTeacherCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutLevelInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    schoolId: string
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassSubjectUncheckedCreateNestedManyWithoutSubjectInput
    results?: ResultUncheckedCreateNestedManyWithoutSubjectInput
    students?: StudentSubjectUncheckedCreateNestedManyWithoutSubjectInput
    teachers?: SubjectTeacherUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutLevelInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutLevelInput, SubjectUncheckedCreateWithoutLevelInput>
  }

  export type SubjectCreateManyLevelInputEnvelope = {
    data: SubjectCreateManyLevelInput | SubjectCreateManyLevelInput[]
    skipDuplicates?: boolean
  }

  export type ClassUpsertWithWhereUniqueWithoutLevelInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutLevelInput, ClassUncheckedUpdateWithoutLevelInput>
    create: XOR<ClassCreateWithoutLevelInput, ClassUncheckedCreateWithoutLevelInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutLevelInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutLevelInput, ClassUncheckedUpdateWithoutLevelInput>
  }

  export type ClassUpdateManyWithWhereWithoutLevelInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutLevelInput>
  }

  export type SchoolUpsertWithoutLevelsInput = {
    update: XOR<SchoolUpdateWithoutLevelsInput, SchoolUncheckedUpdateWithoutLevelsInput>
    create: XOR<SchoolCreateWithoutLevelsInput, SchoolUncheckedCreateWithoutLevelsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutLevelsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutLevelsInput, SchoolUncheckedUpdateWithoutLevelsInput>
  }

  export type SchoolUpdateWithoutLevelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: StringFieldUpdateOperationsInput | string
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    shortName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: AcademicSessionUpdateManyWithoutSchoolNestedInput
    bills?: BillUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    departments?: DepartmentUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    paymentAccounts?: PaymentAccountUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUpdateManyWithoutSchoolNestedInput
    users?: UserUpdateManyWithoutSchoolNestedInput
    resultConfigs?: ResultConfigurationUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutLevelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: StringFieldUpdateOperationsInput | string
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    shortName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: AcademicSessionUncheckedUpdateManyWithoutSchoolNestedInput
    bills?: BillUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    paymentAccounts?: PaymentAccountUncheckedUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutSchoolNestedInput
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    resultConfigs?: ResultConfigurationUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SubjectUpsertWithWhereUniqueWithoutLevelInput = {
    where: SubjectWhereUniqueInput
    update: XOR<SubjectUpdateWithoutLevelInput, SubjectUncheckedUpdateWithoutLevelInput>
    create: XOR<SubjectCreateWithoutLevelInput, SubjectUncheckedCreateWithoutLevelInput>
  }

  export type SubjectUpdateWithWhereUniqueWithoutLevelInput = {
    where: SubjectWhereUniqueInput
    data: XOR<SubjectUpdateWithoutLevelInput, SubjectUncheckedUpdateWithoutLevelInput>
  }

  export type SubjectUpdateManyWithWhereWithoutLevelInput = {
    where: SubjectScalarWhereInput
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyWithoutLevelInput>
  }

  export type UserCreateWithoutActivityLogsInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.UserRole
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    parent?: ParentCreateNestedOneWithoutUserInput
    processedPayments?: PaymentRequestCreateNestedManyWithoutProcessedByInput
    approvedResults?: ResultCreateNestedManyWithoutApprovedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    school?: SchoolCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutActivityLogsInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.UserRole
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    schoolId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    parent?: ParentUncheckedCreateNestedOneWithoutUserInput
    processedPayments?: PaymentRequestUncheckedCreateNestedManyWithoutProcessedByInput
    approvedResults?: ResultUncheckedCreateNestedManyWithoutApprovedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActivityLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
  }

  export type UserUpsertWithoutActivityLogsInput = {
    update: XOR<UserUpdateWithoutActivityLogsInput, UserUncheckedUpdateWithoutActivityLogsInput>
    create: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivityLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivityLogsInput, UserUncheckedUpdateWithoutActivityLogsInput>
  }

  export type UserUpdateWithoutActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    parent?: ParentUpdateOneWithoutUserNestedInput
    processedPayments?: PaymentRequestUpdateManyWithoutProcessedByNestedInput
    approvedResults?: ResultUpdateManyWithoutApprovedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    parent?: ParentUncheckedUpdateOneWithoutUserNestedInput
    processedPayments?: PaymentRequestUncheckedUpdateManyWithoutProcessedByNestedInput
    approvedResults?: ResultUncheckedUpdateManyWithoutApprovedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.UserRole
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    parent?: ParentCreateNestedOneWithoutUserInput
    processedPayments?: PaymentRequestCreateNestedManyWithoutProcessedByInput
    approvedResults?: ResultCreateNestedManyWithoutApprovedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    activityLogs?: UserActivityLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.UserRole
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    schoolId?: string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    parent?: ParentUncheckedCreateNestedOneWithoutUserInput
    processedPayments?: PaymentRequestUncheckedCreateNestedManyWithoutProcessedByInput
    approvedResults?: ResultUncheckedCreateNestedManyWithoutApprovedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    activityLogs?: UserActivityLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneWithoutUserNestedInput
    parent?: ParentUpdateOneWithoutUserNestedInput
    processedPayments?: PaymentRequestUpdateManyWithoutProcessedByNestedInput
    approvedResults?: ResultUpdateManyWithoutApprovedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    activityLogs?: UserActivityLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    parent?: ParentUncheckedUpdateOneWithoutUserNestedInput
    processedPayments?: PaymentRequestUncheckedUpdateManyWithoutProcessedByNestedInput
    approvedResults?: ResultUncheckedUpdateManyWithoutApprovedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    activityLogs?: UserActivityLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.UserRole
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    parent?: ParentCreateNestedOneWithoutUserInput
    processedPayments?: PaymentRequestCreateNestedManyWithoutProcessedByInput
    approvedResults?: ResultCreateNestedManyWithoutApprovedByInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    activityLogs?: UserActivityLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.UserRole
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    schoolId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    parent?: ParentUncheckedCreateNestedOneWithoutUserInput
    processedPayments?: PaymentRequestUncheckedCreateNestedManyWithoutProcessedByInput
    approvedResults?: ResultUncheckedCreateNestedManyWithoutApprovedByInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    activityLogs?: UserActivityLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    parent?: ParentUpdateOneWithoutUserNestedInput
    processedPayments?: PaymentRequestUpdateManyWithoutProcessedByNestedInput
    approvedResults?: ResultUpdateManyWithoutApprovedByNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    activityLogs?: UserActivityLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    parent?: ParentUncheckedUpdateOneWithoutUserNestedInput
    processedPayments?: PaymentRequestUncheckedUpdateManyWithoutProcessedByNestedInput
    approvedResults?: ResultUncheckedUpdateManyWithoutApprovedByNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    activityLogs?: UserActivityLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ResultPeriodCreateWithoutConfigurationInput = {
    id?: string
    name: string
    weight?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    results?: ResultCreateNestedManyWithoutPeriodInput
  }

  export type ResultPeriodUncheckedCreateWithoutConfigurationInput = {
    id?: string
    name: string
    weight?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    results?: ResultUncheckedCreateNestedManyWithoutPeriodInput
  }

  export type ResultPeriodCreateOrConnectWithoutConfigurationInput = {
    where: ResultPeriodWhereUniqueInput
    create: XOR<ResultPeriodCreateWithoutConfigurationInput, ResultPeriodUncheckedCreateWithoutConfigurationInput>
  }

  export type ResultPeriodCreateManyConfigurationInputEnvelope = {
    data: ResultPeriodCreateManyConfigurationInput | ResultPeriodCreateManyConfigurationInput[]
    skipDuplicates?: boolean
  }

  export type AssessmentComponentCreateWithoutConfigurationInput = {
    id?: string
    name: string
    key: string
    maxScore: number
    createdAt?: Date | string
    updatedAt?: Date | string
    scores?: ComponentScoreCreateNestedManyWithoutComponentInput
  }

  export type AssessmentComponentUncheckedCreateWithoutConfigurationInput = {
    id?: string
    name: string
    key: string
    maxScore: number
    createdAt?: Date | string
    updatedAt?: Date | string
    scores?: ComponentScoreUncheckedCreateNestedManyWithoutComponentInput
  }

  export type AssessmentComponentCreateOrConnectWithoutConfigurationInput = {
    where: AssessmentComponentWhereUniqueInput
    create: XOR<AssessmentComponentCreateWithoutConfigurationInput, AssessmentComponentUncheckedCreateWithoutConfigurationInput>
  }

  export type AssessmentComponentCreateManyConfigurationInputEnvelope = {
    data: AssessmentComponentCreateManyConfigurationInput | AssessmentComponentCreateManyConfigurationInput[]
    skipDuplicates?: boolean
  }

  export type GradingScaleCreateWithoutConfigurationInput = {
    id?: string
    minScore: number
    maxScore: number
    grade: string
    remark: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GradingScaleUncheckedCreateWithoutConfigurationInput = {
    id?: string
    minScore: number
    maxScore: number
    grade: string
    remark: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GradingScaleCreateOrConnectWithoutConfigurationInput = {
    where: GradingScaleWhereUniqueInput
    create: XOR<GradingScaleCreateWithoutConfigurationInput, GradingScaleUncheckedCreateWithoutConfigurationInput>
  }

  export type GradingScaleCreateManyConfigurationInputEnvelope = {
    data: GradingScaleCreateManyConfigurationInput | GradingScaleCreateManyConfigurationInput[]
    skipDuplicates?: boolean
  }

  export type SchoolCreateWithoutResultConfigsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email: string
    logo?: string | null
    subdomain: string
    primaryColor?: string | null
    secondaryColor?: string | null
    shortName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: AcademicSessionCreateNestedManyWithoutSchoolInput
    bills?: BillCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    departments?: DepartmentCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    paymentAccounts?: PaymentAccountCreateNestedManyWithoutSchoolInput
    levels?: SchoolLevelCreateNestedManyWithoutSchoolInput
    subjects?: SubjectCreateNestedManyWithoutSchoolInput
    users?: UserCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutResultConfigsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email: string
    logo?: string | null
    subdomain: string
    primaryColor?: string | null
    secondaryColor?: string | null
    shortName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: AcademicSessionUncheckedCreateNestedManyWithoutSchoolInput
    bills?: BillUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    paymentAccounts?: PaymentAccountUncheckedCreateNestedManyWithoutSchoolInput
    levels?: SchoolLevelUncheckedCreateNestedManyWithoutSchoolInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutSchoolInput
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutResultConfigsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutResultConfigsInput, SchoolUncheckedCreateWithoutResultConfigsInput>
  }

  export type AcademicSessionCreateWithoutResultConfigurationsInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutSessionsInput
    attendance?: AttendanceCreateNestedManyWithoutSessionInput
    results?: ResultCreateNestedManyWithoutSessionInput
    studentClasses?: StudentClassCreateNestedManyWithoutSessionInput
  }

  export type AcademicSessionUncheckedCreateWithoutResultConfigurationsInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    attendance?: AttendanceUncheckedCreateNestedManyWithoutSessionInput
    results?: ResultUncheckedCreateNestedManyWithoutSessionInput
    studentClasses?: StudentClassUncheckedCreateNestedManyWithoutSessionInput
  }

  export type AcademicSessionCreateOrConnectWithoutResultConfigurationsInput = {
    where: AcademicSessionWhereUniqueInput
    create: XOR<AcademicSessionCreateWithoutResultConfigurationsInput, AcademicSessionUncheckedCreateWithoutResultConfigurationsInput>
  }

  export type ResultPeriodUpsertWithWhereUniqueWithoutConfigurationInput = {
    where: ResultPeriodWhereUniqueInput
    update: XOR<ResultPeriodUpdateWithoutConfigurationInput, ResultPeriodUncheckedUpdateWithoutConfigurationInput>
    create: XOR<ResultPeriodCreateWithoutConfigurationInput, ResultPeriodUncheckedCreateWithoutConfigurationInput>
  }

  export type ResultPeriodUpdateWithWhereUniqueWithoutConfigurationInput = {
    where: ResultPeriodWhereUniqueInput
    data: XOR<ResultPeriodUpdateWithoutConfigurationInput, ResultPeriodUncheckedUpdateWithoutConfigurationInput>
  }

  export type ResultPeriodUpdateManyWithWhereWithoutConfigurationInput = {
    where: ResultPeriodScalarWhereInput
    data: XOR<ResultPeriodUpdateManyMutationInput, ResultPeriodUncheckedUpdateManyWithoutConfigurationInput>
  }

  export type ResultPeriodScalarWhereInput = {
    AND?: ResultPeriodScalarWhereInput | ResultPeriodScalarWhereInput[]
    OR?: ResultPeriodScalarWhereInput[]
    NOT?: ResultPeriodScalarWhereInput | ResultPeriodScalarWhereInput[]
    id?: StringFilter<"ResultPeriod"> | string
    name?: StringFilter<"ResultPeriod"> | string
    weight?: FloatFilter<"ResultPeriod"> | number
    configurationId?: StringFilter<"ResultPeriod"> | string
    createdAt?: DateTimeFilter<"ResultPeriod"> | Date | string
    updatedAt?: DateTimeFilter<"ResultPeriod"> | Date | string
  }

  export type AssessmentComponentUpsertWithWhereUniqueWithoutConfigurationInput = {
    where: AssessmentComponentWhereUniqueInput
    update: XOR<AssessmentComponentUpdateWithoutConfigurationInput, AssessmentComponentUncheckedUpdateWithoutConfigurationInput>
    create: XOR<AssessmentComponentCreateWithoutConfigurationInput, AssessmentComponentUncheckedCreateWithoutConfigurationInput>
  }

  export type AssessmentComponentUpdateWithWhereUniqueWithoutConfigurationInput = {
    where: AssessmentComponentWhereUniqueInput
    data: XOR<AssessmentComponentUpdateWithoutConfigurationInput, AssessmentComponentUncheckedUpdateWithoutConfigurationInput>
  }

  export type AssessmentComponentUpdateManyWithWhereWithoutConfigurationInput = {
    where: AssessmentComponentScalarWhereInput
    data: XOR<AssessmentComponentUpdateManyMutationInput, AssessmentComponentUncheckedUpdateManyWithoutConfigurationInput>
  }

  export type AssessmentComponentScalarWhereInput = {
    AND?: AssessmentComponentScalarWhereInput | AssessmentComponentScalarWhereInput[]
    OR?: AssessmentComponentScalarWhereInput[]
    NOT?: AssessmentComponentScalarWhereInput | AssessmentComponentScalarWhereInput[]
    id?: StringFilter<"AssessmentComponent"> | string
    name?: StringFilter<"AssessmentComponent"> | string
    key?: StringFilter<"AssessmentComponent"> | string
    maxScore?: FloatFilter<"AssessmentComponent"> | number
    configurationId?: StringFilter<"AssessmentComponent"> | string
    createdAt?: DateTimeFilter<"AssessmentComponent"> | Date | string
    updatedAt?: DateTimeFilter<"AssessmentComponent"> | Date | string
  }

  export type GradingScaleUpsertWithWhereUniqueWithoutConfigurationInput = {
    where: GradingScaleWhereUniqueInput
    update: XOR<GradingScaleUpdateWithoutConfigurationInput, GradingScaleUncheckedUpdateWithoutConfigurationInput>
    create: XOR<GradingScaleCreateWithoutConfigurationInput, GradingScaleUncheckedCreateWithoutConfigurationInput>
  }

  export type GradingScaleUpdateWithWhereUniqueWithoutConfigurationInput = {
    where: GradingScaleWhereUniqueInput
    data: XOR<GradingScaleUpdateWithoutConfigurationInput, GradingScaleUncheckedUpdateWithoutConfigurationInput>
  }

  export type GradingScaleUpdateManyWithWhereWithoutConfigurationInput = {
    where: GradingScaleScalarWhereInput
    data: XOR<GradingScaleUpdateManyMutationInput, GradingScaleUncheckedUpdateManyWithoutConfigurationInput>
  }

  export type GradingScaleScalarWhereInput = {
    AND?: GradingScaleScalarWhereInput | GradingScaleScalarWhereInput[]
    OR?: GradingScaleScalarWhereInput[]
    NOT?: GradingScaleScalarWhereInput | GradingScaleScalarWhereInput[]
    id?: StringFilter<"GradingScale"> | string
    minScore?: FloatFilter<"GradingScale"> | number
    maxScore?: FloatFilter<"GradingScale"> | number
    grade?: StringFilter<"GradingScale"> | string
    remark?: StringFilter<"GradingScale"> | string
    configurationId?: StringFilter<"GradingScale"> | string
    createdAt?: DateTimeFilter<"GradingScale"> | Date | string
    updatedAt?: DateTimeFilter<"GradingScale"> | Date | string
  }

  export type SchoolUpsertWithoutResultConfigsInput = {
    update: XOR<SchoolUpdateWithoutResultConfigsInput, SchoolUncheckedUpdateWithoutResultConfigsInput>
    create: XOR<SchoolCreateWithoutResultConfigsInput, SchoolUncheckedCreateWithoutResultConfigsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutResultConfigsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutResultConfigsInput, SchoolUncheckedUpdateWithoutResultConfigsInput>
  }

  export type SchoolUpdateWithoutResultConfigsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: StringFieldUpdateOperationsInput | string
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    shortName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: AcademicSessionUpdateManyWithoutSchoolNestedInput
    bills?: BillUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    departments?: DepartmentUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    paymentAccounts?: PaymentAccountUpdateManyWithoutSchoolNestedInput
    levels?: SchoolLevelUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUpdateManyWithoutSchoolNestedInput
    users?: UserUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutResultConfigsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: StringFieldUpdateOperationsInput | string
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    shortName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: AcademicSessionUncheckedUpdateManyWithoutSchoolNestedInput
    bills?: BillUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    paymentAccounts?: PaymentAccountUncheckedUpdateManyWithoutSchoolNestedInput
    levels?: SchoolLevelUncheckedUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutSchoolNestedInput
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type AcademicSessionUpsertWithoutResultConfigurationsInput = {
    update: XOR<AcademicSessionUpdateWithoutResultConfigurationsInput, AcademicSessionUncheckedUpdateWithoutResultConfigurationsInput>
    create: XOR<AcademicSessionCreateWithoutResultConfigurationsInput, AcademicSessionUncheckedCreateWithoutResultConfigurationsInput>
    where?: AcademicSessionWhereInput
  }

  export type AcademicSessionUpdateToOneWithWhereWithoutResultConfigurationsInput = {
    where?: AcademicSessionWhereInput
    data: XOR<AcademicSessionUpdateWithoutResultConfigurationsInput, AcademicSessionUncheckedUpdateWithoutResultConfigurationsInput>
  }

  export type AcademicSessionUpdateWithoutResultConfigurationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutSessionsNestedInput
    attendance?: AttendanceUpdateManyWithoutSessionNestedInput
    results?: ResultUpdateManyWithoutSessionNestedInput
    studentClasses?: StudentClassUpdateManyWithoutSessionNestedInput
  }

  export type AcademicSessionUncheckedUpdateWithoutResultConfigurationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: AttendanceUncheckedUpdateManyWithoutSessionNestedInput
    results?: ResultUncheckedUpdateManyWithoutSessionNestedInput
    studentClasses?: StudentClassUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type ResultConfigurationCreateWithoutPeriodsInput = {
    id?: string
    cumulativeEnabled?: boolean
    cumulativeMethod?: string
    showCumulativePerTerm?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assessmentComponents?: AssessmentComponentCreateNestedManyWithoutConfigurationInput
    gradingScale?: GradingScaleCreateNestedManyWithoutConfigurationInput
    school: SchoolCreateNestedOneWithoutResultConfigsInput
    session: AcademicSessionCreateNestedOneWithoutResultConfigurationsInput
  }

  export type ResultConfigurationUncheckedCreateWithoutPeriodsInput = {
    id?: string
    schoolId: string
    sessionId: string
    cumulativeEnabled?: boolean
    cumulativeMethod?: string
    showCumulativePerTerm?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assessmentComponents?: AssessmentComponentUncheckedCreateNestedManyWithoutConfigurationInput
    gradingScale?: GradingScaleUncheckedCreateNestedManyWithoutConfigurationInput
  }

  export type ResultConfigurationCreateOrConnectWithoutPeriodsInput = {
    where: ResultConfigurationWhereUniqueInput
    create: XOR<ResultConfigurationCreateWithoutPeriodsInput, ResultConfigurationUncheckedCreateWithoutPeriodsInput>
  }

  export type ResultCreateWithoutPeriodInput = {
    id?: string
    total: number
    grade: string
    remark: string
    cumulativeAverage?: number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: string | null
    adminComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    componentScores?: ComponentScoreCreateNestedManyWithoutResultInput
    student: StudentCreateNestedOneWithoutResultsInput
    subject: SubjectCreateNestedOneWithoutResultsInput
    session: AcademicSessionCreateNestedOneWithoutResultsInput
    approvedBy?: UserCreateNestedOneWithoutApprovedResultsInput
  }

  export type ResultUncheckedCreateWithoutPeriodInput = {
    id?: string
    studentId: string
    subjectId: string
    sessionId: string
    total: number
    grade: string
    remark: string
    cumulativeAverage?: number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: string | null
    adminComment?: string | null
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    componentScores?: ComponentScoreUncheckedCreateNestedManyWithoutResultInput
  }

  export type ResultCreateOrConnectWithoutPeriodInput = {
    where: ResultWhereUniqueInput
    create: XOR<ResultCreateWithoutPeriodInput, ResultUncheckedCreateWithoutPeriodInput>
  }

  export type ResultCreateManyPeriodInputEnvelope = {
    data: ResultCreateManyPeriodInput | ResultCreateManyPeriodInput[]
    skipDuplicates?: boolean
  }

  export type ResultConfigurationUpsertWithoutPeriodsInput = {
    update: XOR<ResultConfigurationUpdateWithoutPeriodsInput, ResultConfigurationUncheckedUpdateWithoutPeriodsInput>
    create: XOR<ResultConfigurationCreateWithoutPeriodsInput, ResultConfigurationUncheckedCreateWithoutPeriodsInput>
    where?: ResultConfigurationWhereInput
  }

  export type ResultConfigurationUpdateToOneWithWhereWithoutPeriodsInput = {
    where?: ResultConfigurationWhereInput
    data: XOR<ResultConfigurationUpdateWithoutPeriodsInput, ResultConfigurationUncheckedUpdateWithoutPeriodsInput>
  }

  export type ResultConfigurationUpdateWithoutPeriodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cumulativeEnabled?: BoolFieldUpdateOperationsInput | boolean
    cumulativeMethod?: StringFieldUpdateOperationsInput | string
    showCumulativePerTerm?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assessmentComponents?: AssessmentComponentUpdateManyWithoutConfigurationNestedInput
    gradingScale?: GradingScaleUpdateManyWithoutConfigurationNestedInput
    school?: SchoolUpdateOneRequiredWithoutResultConfigsNestedInput
    session?: AcademicSessionUpdateOneRequiredWithoutResultConfigurationsNestedInput
  }

  export type ResultConfigurationUncheckedUpdateWithoutPeriodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    cumulativeEnabled?: BoolFieldUpdateOperationsInput | boolean
    cumulativeMethod?: StringFieldUpdateOperationsInput | string
    showCumulativePerTerm?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assessmentComponents?: AssessmentComponentUncheckedUpdateManyWithoutConfigurationNestedInput
    gradingScale?: GradingScaleUncheckedUpdateManyWithoutConfigurationNestedInput
  }

  export type ResultUpsertWithWhereUniqueWithoutPeriodInput = {
    where: ResultWhereUniqueInput
    update: XOR<ResultUpdateWithoutPeriodInput, ResultUncheckedUpdateWithoutPeriodInput>
    create: XOR<ResultCreateWithoutPeriodInput, ResultUncheckedCreateWithoutPeriodInput>
  }

  export type ResultUpdateWithWhereUniqueWithoutPeriodInput = {
    where: ResultWhereUniqueInput
    data: XOR<ResultUpdateWithoutPeriodInput, ResultUncheckedUpdateWithoutPeriodInput>
  }

  export type ResultUpdateManyWithWhereWithoutPeriodInput = {
    where: ResultScalarWhereInput
    data: XOR<ResultUpdateManyMutationInput, ResultUncheckedUpdateManyWithoutPeriodInput>
  }

  export type ResultConfigurationCreateWithoutAssessmentComponentsInput = {
    id?: string
    cumulativeEnabled?: boolean
    cumulativeMethod?: string
    showCumulativePerTerm?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    periods?: ResultPeriodCreateNestedManyWithoutConfigurationInput
    gradingScale?: GradingScaleCreateNestedManyWithoutConfigurationInput
    school: SchoolCreateNestedOneWithoutResultConfigsInput
    session: AcademicSessionCreateNestedOneWithoutResultConfigurationsInput
  }

  export type ResultConfigurationUncheckedCreateWithoutAssessmentComponentsInput = {
    id?: string
    schoolId: string
    sessionId: string
    cumulativeEnabled?: boolean
    cumulativeMethod?: string
    showCumulativePerTerm?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    periods?: ResultPeriodUncheckedCreateNestedManyWithoutConfigurationInput
    gradingScale?: GradingScaleUncheckedCreateNestedManyWithoutConfigurationInput
  }

  export type ResultConfigurationCreateOrConnectWithoutAssessmentComponentsInput = {
    where: ResultConfigurationWhereUniqueInput
    create: XOR<ResultConfigurationCreateWithoutAssessmentComponentsInput, ResultConfigurationUncheckedCreateWithoutAssessmentComponentsInput>
  }

  export type ComponentScoreCreateWithoutComponentInput = {
    id?: string
    score: number
    createdAt?: Date | string
    updatedAt?: Date | string
    result: ResultCreateNestedOneWithoutComponentScoresInput
  }

  export type ComponentScoreUncheckedCreateWithoutComponentInput = {
    id?: string
    score: number
    resultId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComponentScoreCreateOrConnectWithoutComponentInput = {
    where: ComponentScoreWhereUniqueInput
    create: XOR<ComponentScoreCreateWithoutComponentInput, ComponentScoreUncheckedCreateWithoutComponentInput>
  }

  export type ComponentScoreCreateManyComponentInputEnvelope = {
    data: ComponentScoreCreateManyComponentInput | ComponentScoreCreateManyComponentInput[]
    skipDuplicates?: boolean
  }

  export type ResultConfigurationUpsertWithoutAssessmentComponentsInput = {
    update: XOR<ResultConfigurationUpdateWithoutAssessmentComponentsInput, ResultConfigurationUncheckedUpdateWithoutAssessmentComponentsInput>
    create: XOR<ResultConfigurationCreateWithoutAssessmentComponentsInput, ResultConfigurationUncheckedCreateWithoutAssessmentComponentsInput>
    where?: ResultConfigurationWhereInput
  }

  export type ResultConfigurationUpdateToOneWithWhereWithoutAssessmentComponentsInput = {
    where?: ResultConfigurationWhereInput
    data: XOR<ResultConfigurationUpdateWithoutAssessmentComponentsInput, ResultConfigurationUncheckedUpdateWithoutAssessmentComponentsInput>
  }

  export type ResultConfigurationUpdateWithoutAssessmentComponentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cumulativeEnabled?: BoolFieldUpdateOperationsInput | boolean
    cumulativeMethod?: StringFieldUpdateOperationsInput | string
    showCumulativePerTerm?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    periods?: ResultPeriodUpdateManyWithoutConfigurationNestedInput
    gradingScale?: GradingScaleUpdateManyWithoutConfigurationNestedInput
    school?: SchoolUpdateOneRequiredWithoutResultConfigsNestedInput
    session?: AcademicSessionUpdateOneRequiredWithoutResultConfigurationsNestedInput
  }

  export type ResultConfigurationUncheckedUpdateWithoutAssessmentComponentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    cumulativeEnabled?: BoolFieldUpdateOperationsInput | boolean
    cumulativeMethod?: StringFieldUpdateOperationsInput | string
    showCumulativePerTerm?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    periods?: ResultPeriodUncheckedUpdateManyWithoutConfigurationNestedInput
    gradingScale?: GradingScaleUncheckedUpdateManyWithoutConfigurationNestedInput
  }

  export type ComponentScoreUpsertWithWhereUniqueWithoutComponentInput = {
    where: ComponentScoreWhereUniqueInput
    update: XOR<ComponentScoreUpdateWithoutComponentInput, ComponentScoreUncheckedUpdateWithoutComponentInput>
    create: XOR<ComponentScoreCreateWithoutComponentInput, ComponentScoreUncheckedCreateWithoutComponentInput>
  }

  export type ComponentScoreUpdateWithWhereUniqueWithoutComponentInput = {
    where: ComponentScoreWhereUniqueInput
    data: XOR<ComponentScoreUpdateWithoutComponentInput, ComponentScoreUncheckedUpdateWithoutComponentInput>
  }

  export type ComponentScoreUpdateManyWithWhereWithoutComponentInput = {
    where: ComponentScoreScalarWhereInput
    data: XOR<ComponentScoreUpdateManyMutationInput, ComponentScoreUncheckedUpdateManyWithoutComponentInput>
  }

  export type ResultConfigurationCreateWithoutGradingScaleInput = {
    id?: string
    cumulativeEnabled?: boolean
    cumulativeMethod?: string
    showCumulativePerTerm?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    periods?: ResultPeriodCreateNestedManyWithoutConfigurationInput
    assessmentComponents?: AssessmentComponentCreateNestedManyWithoutConfigurationInput
    school: SchoolCreateNestedOneWithoutResultConfigsInput
    session: AcademicSessionCreateNestedOneWithoutResultConfigurationsInput
  }

  export type ResultConfigurationUncheckedCreateWithoutGradingScaleInput = {
    id?: string
    schoolId: string
    sessionId: string
    cumulativeEnabled?: boolean
    cumulativeMethod?: string
    showCumulativePerTerm?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    periods?: ResultPeriodUncheckedCreateNestedManyWithoutConfigurationInput
    assessmentComponents?: AssessmentComponentUncheckedCreateNestedManyWithoutConfigurationInput
  }

  export type ResultConfigurationCreateOrConnectWithoutGradingScaleInput = {
    where: ResultConfigurationWhereUniqueInput
    create: XOR<ResultConfigurationCreateWithoutGradingScaleInput, ResultConfigurationUncheckedCreateWithoutGradingScaleInput>
  }

  export type ResultConfigurationUpsertWithoutGradingScaleInput = {
    update: XOR<ResultConfigurationUpdateWithoutGradingScaleInput, ResultConfigurationUncheckedUpdateWithoutGradingScaleInput>
    create: XOR<ResultConfigurationCreateWithoutGradingScaleInput, ResultConfigurationUncheckedCreateWithoutGradingScaleInput>
    where?: ResultConfigurationWhereInput
  }

  export type ResultConfigurationUpdateToOneWithWhereWithoutGradingScaleInput = {
    where?: ResultConfigurationWhereInput
    data: XOR<ResultConfigurationUpdateWithoutGradingScaleInput, ResultConfigurationUncheckedUpdateWithoutGradingScaleInput>
  }

  export type ResultConfigurationUpdateWithoutGradingScaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    cumulativeEnabled?: BoolFieldUpdateOperationsInput | boolean
    cumulativeMethod?: StringFieldUpdateOperationsInput | string
    showCumulativePerTerm?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    periods?: ResultPeriodUpdateManyWithoutConfigurationNestedInput
    assessmentComponents?: AssessmentComponentUpdateManyWithoutConfigurationNestedInput
    school?: SchoolUpdateOneRequiredWithoutResultConfigsNestedInput
    session?: AcademicSessionUpdateOneRequiredWithoutResultConfigurationsNestedInput
  }

  export type ResultConfigurationUncheckedUpdateWithoutGradingScaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    cumulativeEnabled?: BoolFieldUpdateOperationsInput | boolean
    cumulativeMethod?: StringFieldUpdateOperationsInput | string
    showCumulativePerTerm?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    periods?: ResultPeriodUncheckedUpdateManyWithoutConfigurationNestedInput
    assessmentComponents?: AssessmentComponentUncheckedUpdateManyWithoutConfigurationNestedInput
  }

  export type AssessmentComponentCreateWithoutScoresInput = {
    id?: string
    name: string
    key: string
    maxScore: number
    createdAt?: Date | string
    updatedAt?: Date | string
    configuration: ResultConfigurationCreateNestedOneWithoutAssessmentComponentsInput
  }

  export type AssessmentComponentUncheckedCreateWithoutScoresInput = {
    id?: string
    name: string
    key: string
    maxScore: number
    configurationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssessmentComponentCreateOrConnectWithoutScoresInput = {
    where: AssessmentComponentWhereUniqueInput
    create: XOR<AssessmentComponentCreateWithoutScoresInput, AssessmentComponentUncheckedCreateWithoutScoresInput>
  }

  export type ResultCreateWithoutComponentScoresInput = {
    id?: string
    total: number
    grade: string
    remark: string
    cumulativeAverage?: number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: string | null
    adminComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutResultsInput
    subject: SubjectCreateNestedOneWithoutResultsInput
    period: ResultPeriodCreateNestedOneWithoutResultsInput
    session: AcademicSessionCreateNestedOneWithoutResultsInput
    approvedBy?: UserCreateNestedOneWithoutApprovedResultsInput
  }

  export type ResultUncheckedCreateWithoutComponentScoresInput = {
    id?: string
    studentId: string
    subjectId: string
    periodId: string
    sessionId: string
    total: number
    grade: string
    remark: string
    cumulativeAverage?: number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: string | null
    adminComment?: string | null
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResultCreateOrConnectWithoutComponentScoresInput = {
    where: ResultWhereUniqueInput
    create: XOR<ResultCreateWithoutComponentScoresInput, ResultUncheckedCreateWithoutComponentScoresInput>
  }

  export type AssessmentComponentUpsertWithoutScoresInput = {
    update: XOR<AssessmentComponentUpdateWithoutScoresInput, AssessmentComponentUncheckedUpdateWithoutScoresInput>
    create: XOR<AssessmentComponentCreateWithoutScoresInput, AssessmentComponentUncheckedCreateWithoutScoresInput>
    where?: AssessmentComponentWhereInput
  }

  export type AssessmentComponentUpdateToOneWithWhereWithoutScoresInput = {
    where?: AssessmentComponentWhereInput
    data: XOR<AssessmentComponentUpdateWithoutScoresInput, AssessmentComponentUncheckedUpdateWithoutScoresInput>
  }

  export type AssessmentComponentUpdateWithoutScoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    maxScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    configuration?: ResultConfigurationUpdateOneRequiredWithoutAssessmentComponentsNestedInput
  }

  export type AssessmentComponentUncheckedUpdateWithoutScoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    maxScore?: FloatFieldUpdateOperationsInput | number
    configurationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultUpsertWithoutComponentScoresInput = {
    update: XOR<ResultUpdateWithoutComponentScoresInput, ResultUncheckedUpdateWithoutComponentScoresInput>
    create: XOR<ResultCreateWithoutComponentScoresInput, ResultUncheckedCreateWithoutComponentScoresInput>
    where?: ResultWhereInput
  }

  export type ResultUpdateToOneWithWhereWithoutComponentScoresInput = {
    where?: ResultWhereInput
    data: XOR<ResultUpdateWithoutComponentScoresInput, ResultUncheckedUpdateWithoutComponentScoresInput>
  }

  export type ResultUpdateWithoutComponentScoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remark?: StringFieldUpdateOperationsInput | string
    cumulativeAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: NullableStringFieldUpdateOperationsInput | string | null
    adminComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutResultsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutResultsNestedInput
    period?: ResultPeriodUpdateOneRequiredWithoutResultsNestedInput
    session?: AcademicSessionUpdateOneRequiredWithoutResultsNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedResultsNestedInput
  }

  export type ResultUncheckedUpdateWithoutComponentScoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remark?: StringFieldUpdateOperationsInput | string
    cumulativeAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: NullableStringFieldUpdateOperationsInput | string | null
    adminComment?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type PaymentRequestCreateManyProcessedByInput = {
    id?: string
    billId: string
    billAssignmentId: string
    studentPaymentId?: string | null
    studentId: string
    amount: number
    receiptUrl?: string | null
    status?: $Enums.PaymentStatus
    notes?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResultCreateManyApprovedByInput = {
    id?: string
    studentId: string
    subjectId: string
    periodId: string
    sessionId: string
    total: number
    grade: string
    remark: string
    cumulativeAverage?: number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: string | null
    adminComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type UserActivityLogCreateManyUserInput = {
    id?: string
    page: string
    action: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentRequestUpdateWithoutProcessedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billAssignment?: BillAssignmentUpdateOneRequiredWithoutPaymentRequestsNestedInput
    bill?: BillUpdateOneRequiredWithoutPaymentRequestsNestedInput
    student?: StudentUpdateOneRequiredWithoutPaymentRequestsNestedInput
    studentPayment?: StudentPaymentUpdateOneWithoutPaymentRequestsNestedInput
  }

  export type PaymentRequestUncheckedUpdateWithoutProcessedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    billId?: StringFieldUpdateOperationsInput | string
    billAssignmentId?: StringFieldUpdateOperationsInput | string
    studentPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentRequestUncheckedUpdateManyWithoutProcessedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    billId?: StringFieldUpdateOperationsInput | string
    billAssignmentId?: StringFieldUpdateOperationsInput | string
    studentPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remark?: StringFieldUpdateOperationsInput | string
    cumulativeAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: NullableStringFieldUpdateOperationsInput | string | null
    adminComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    componentScores?: ComponentScoreUpdateManyWithoutResultNestedInput
    student?: StudentUpdateOneRequiredWithoutResultsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutResultsNestedInput
    period?: ResultPeriodUpdateOneRequiredWithoutResultsNestedInput
    session?: AcademicSessionUpdateOneRequiredWithoutResultsNestedInput
  }

  export type ResultUncheckedUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remark?: StringFieldUpdateOperationsInput | string
    cumulativeAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: NullableStringFieldUpdateOperationsInput | string | null
    adminComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    componentScores?: ComponentScoreUncheckedUpdateManyWithoutResultNestedInput
  }

  export type ResultUncheckedUpdateManyWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remark?: StringFieldUpdateOperationsInput | string
    cumulativeAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: NullableStringFieldUpdateOperationsInput | string | null
    adminComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivityLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivityLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivityLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassCreateManyTeacherInput = {
    id?: string
    name: string
    section?: string | null
    schoolId: string
    levelId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectTeacherCreateManyTeacherInput = {
    id?: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: SchoolLevelUpdateOneWithoutClassesNestedInput
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    subjects?: ClassSubjectUpdateManyWithoutClassNestedInput
    students?: StudentClassUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: ClassSubjectUncheckedUpdateManyWithoutClassNestedInput
    students?: StudentClassUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectTeacherUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneRequiredWithoutTeachersNestedInput
  }

  export type SubjectTeacherUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectTeacherUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateManyStudentInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    sessionId: string
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentRequestCreateManyStudentInput = {
    id?: string
    billId: string
    billAssignmentId: string
    studentPaymentId?: string | null
    amount: number
    receiptUrl?: string | null
    status?: $Enums.PaymentStatus
    notes?: string | null
    processedById?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResultCreateManyStudentInput = {
    id?: string
    subjectId: string
    periodId: string
    sessionId: string
    total: number
    grade: string
    remark: string
    cumulativeAverage?: number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: string | null
    adminComment?: string | null
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentClassCreateManyStudentInput = {
    id?: string
    classId: string
    sessionId: string
    rollNumber?: string | null
    status?: $Enums.EnrollmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentParentCreateManyStudentInput = {
    id?: string
    parentId: string
    relation?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentPaymentCreateManyStudentInput = {
    id?: string
    billAssignmentId: string
    amountPaid: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSubjectCreateManyStudentInput = {
    id?: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: AcademicSessionUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    sessionId?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    sessionId?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentRequestUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billAssignment?: BillAssignmentUpdateOneRequiredWithoutPaymentRequestsNestedInput
    bill?: BillUpdateOneRequiredWithoutPaymentRequestsNestedInput
    processedBy?: UserUpdateOneWithoutProcessedPaymentsNestedInput
    studentPayment?: StudentPaymentUpdateOneWithoutPaymentRequestsNestedInput
  }

  export type PaymentRequestUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    billId?: StringFieldUpdateOperationsInput | string
    billAssignmentId?: StringFieldUpdateOperationsInput | string
    studentPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentRequestUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    billId?: StringFieldUpdateOperationsInput | string
    billAssignmentId?: StringFieldUpdateOperationsInput | string
    studentPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remark?: StringFieldUpdateOperationsInput | string
    cumulativeAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: NullableStringFieldUpdateOperationsInput | string | null
    adminComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    componentScores?: ComponentScoreUpdateManyWithoutResultNestedInput
    subject?: SubjectUpdateOneRequiredWithoutResultsNestedInput
    period?: ResultPeriodUpdateOneRequiredWithoutResultsNestedInput
    session?: AcademicSessionUpdateOneRequiredWithoutResultsNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedResultsNestedInput
  }

  export type ResultUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remark?: StringFieldUpdateOperationsInput | string
    cumulativeAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: NullableStringFieldUpdateOperationsInput | string | null
    adminComment?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    componentScores?: ComponentScoreUncheckedUpdateManyWithoutResultNestedInput
  }

  export type ResultUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remark?: StringFieldUpdateOperationsInput | string
    cumulativeAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: NullableStringFieldUpdateOperationsInput | string | null
    adminComment?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentClassUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutStudentsNestedInput
    session?: AcademicSessionUpdateOneRequiredWithoutStudentClassesNestedInput
  }

  export type StudentClassUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentClassUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentParentUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: ParentUpdateOneRequiredWithoutChildrenNestedInput
  }

  export type StudentParentUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentParentUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentPaymentUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentRequests?: PaymentRequestUpdateManyWithoutStudentPaymentNestedInput
    billAssignment?: BillAssignmentUpdateOneRequiredWithoutStudentPaymentsNestedInput
  }

  export type StudentPaymentUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    billAssignmentId?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentRequests?: PaymentRequestUncheckedUpdateManyWithoutStudentPaymentNestedInput
  }

  export type StudentPaymentUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    billAssignmentId?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSubjectUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneRequiredWithoutStudentsNestedInput
  }

  export type StudentSubjectUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSubjectUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentParentCreateManyParentInput = {
    id?: string
    studentId: string
    relation?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentParentUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutParentsNestedInput
  }

  export type StudentParentUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentParentUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicSessionCreateManySchoolInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillCreateManySchoolInput = {
    id?: string
    name: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accountId: string
  }

  export type ClassCreateManySchoolInput = {
    id?: string
    name: string
    section?: string | null
    teacherId?: string | null
    levelId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentCreateManySchoolInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventCreateManySchoolInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    location?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentAccountCreateManySchoolInput = {
    id?: string
    name: string
    accountNo: string
    bankName: string
    branchCode?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolLevelCreateManySchoolInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectCreateManySchoolInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    departmentId?: string | null
    levelId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManySchoolInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.UserRole
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
  }

  export type ResultConfigurationCreateManySchoolInput = {
    id?: string
    sessionId: string
    cumulativeEnabled?: boolean
    cumulativeMethod?: string
    showCumulativePerTerm?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicSessionUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: AttendanceUpdateManyWithoutSessionNestedInput
    results?: ResultUpdateManyWithoutSessionNestedInput
    studentClasses?: StudentClassUpdateManyWithoutSessionNestedInput
    resultConfigurations?: ResultConfigurationUpdateManyWithoutSessionNestedInput
  }

  export type AcademicSessionUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: AttendanceUncheckedUpdateManyWithoutSessionNestedInput
    results?: ResultUncheckedUpdateManyWithoutSessionNestedInput
    studentClasses?: StudentClassUncheckedUpdateManyWithoutSessionNestedInput
    resultConfigurations?: ResultConfigurationUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type AcademicSessionUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: PaymentAccountUpdateOneRequiredWithoutBillsNestedInput
    assignments?: BillAssignmentUpdateManyWithoutBillNestedInput
    items?: BillItemUpdateManyWithoutBillNestedInput
    paymentRequests?: PaymentRequestUpdateManyWithoutBillNestedInput
  }

  export type BillUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    assignments?: BillAssignmentUncheckedUpdateManyWithoutBillNestedInput
    items?: BillItemUncheckedUpdateManyWithoutBillNestedInput
    paymentRequests?: PaymentRequestUncheckedUpdateManyWithoutBillNestedInput
  }

  export type BillUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
  }

  export type ClassUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: SchoolLevelUpdateOneWithoutClassesNestedInput
    teacher?: TeacherUpdateOneWithoutClassesNestedInput
    subjects?: ClassSubjectUpdateManyWithoutClassNestedInput
    students?: StudentClassUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: ClassSubjectUncheckedUpdateManyWithoutClassNestedInput
    students?: StudentClassUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUpdateManyWithoutDepartmentNestedInput
    subjects?: SubjectUpdateManyWithoutDepartmentNestedInput
    teachers?: TeacherUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutDepartmentNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutDepartmentNestedInput
    teachers?: TeacherUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentAccountUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountNo?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    branchCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: BillUpdateManyWithoutAccountNestedInput
  }

  export type PaymentAccountUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountNo?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    branchCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: BillUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type PaymentAccountUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountNo?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    branchCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolLevelUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassUpdateManyWithoutLevelNestedInput
    subjects?: SubjectUpdateManyWithoutLevelNestedInput
  }

  export type SchoolLevelUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassUncheckedUpdateManyWithoutLevelNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutLevelNestedInput
  }

  export type SchoolLevelUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassSubjectUpdateManyWithoutSubjectNestedInput
    results?: ResultUpdateManyWithoutSubjectNestedInput
    students?: StudentSubjectUpdateManyWithoutSubjectNestedInput
    department?: DepartmentUpdateOneWithoutSubjectsNestedInput
    level?: SchoolLevelUpdateOneWithoutSubjectsNestedInput
    teachers?: SubjectTeacherUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    results?: ResultUncheckedUpdateManyWithoutSubjectNestedInput
    students?: StudentSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    teachers?: SubjectTeacherUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    parent?: ParentUpdateOneWithoutUserNestedInput
    processedPayments?: PaymentRequestUpdateManyWithoutProcessedByNestedInput
    approvedResults?: ResultUpdateManyWithoutApprovedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    activityLogs?: UserActivityLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    parent?: ParentUncheckedUpdateOneWithoutUserNestedInput
    processedPayments?: PaymentRequestUncheckedUpdateManyWithoutProcessedByNestedInput
    approvedResults?: ResultUncheckedUpdateManyWithoutApprovedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    activityLogs?: UserActivityLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResultConfigurationUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    cumulativeEnabled?: BoolFieldUpdateOperationsInput | boolean
    cumulativeMethod?: StringFieldUpdateOperationsInput | string
    showCumulativePerTerm?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    periods?: ResultPeriodUpdateManyWithoutConfigurationNestedInput
    assessmentComponents?: AssessmentComponentUpdateManyWithoutConfigurationNestedInput
    gradingScale?: GradingScaleUpdateManyWithoutConfigurationNestedInput
    session?: AcademicSessionUpdateOneRequiredWithoutResultConfigurationsNestedInput
  }

  export type ResultConfigurationUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    cumulativeEnabled?: BoolFieldUpdateOperationsInput | boolean
    cumulativeMethod?: StringFieldUpdateOperationsInput | string
    showCumulativePerTerm?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    periods?: ResultPeriodUncheckedUpdateManyWithoutConfigurationNestedInput
    assessmentComponents?: AssessmentComponentUncheckedUpdateManyWithoutConfigurationNestedInput
    gradingScale?: GradingScaleUncheckedUpdateManyWithoutConfigurationNestedInput
  }

  export type ResultConfigurationUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    cumulativeEnabled?: BoolFieldUpdateOperationsInput | boolean
    cumulativeMethod?: StringFieldUpdateOperationsInput | string
    showCumulativePerTerm?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateManyDepartmentInput = {
    id?: string
    userId: string
    admissionDate?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    religion?: string | null
    bloodGroup?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classId?: string | null
  }

  export type SubjectCreateManyDepartmentInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    schoolId: string
    levelId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherCreateManyDepartmentInput = {
    id?: string
    userId: string
    employeeId?: string | null
    qualifications?: string | null
    specialization?: string | null
    joiningDate?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    emergencyContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    paymentRequests?: PaymentRequestUpdateManyWithoutStudentNestedInput
    results?: ResultUpdateManyWithoutStudentNestedInput
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    classes?: StudentClassUpdateManyWithoutStudentNestedInput
    parents?: StudentParentUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    paymentRequests?: PaymentRequestUncheckedUpdateManyWithoutStudentNestedInput
    results?: ResultUncheckedUpdateManyWithoutStudentNestedInput
    classes?: StudentClassUncheckedUpdateManyWithoutStudentNestedInput
    parents?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUncheckedUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubjectUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassSubjectUpdateManyWithoutSubjectNestedInput
    results?: ResultUpdateManyWithoutSubjectNestedInput
    students?: StudentSubjectUpdateManyWithoutSubjectNestedInput
    level?: SchoolLevelUpdateOneWithoutSubjectsNestedInput
    school?: SchoolUpdateOneRequiredWithoutSubjectsNestedInput
    teachers?: SubjectTeacherUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    results?: ResultUncheckedUpdateManyWithoutSubjectNestedInput
    students?: StudentSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    teachers?: SubjectTeacherUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassUpdateManyWithoutTeacherNestedInput
    subjects?: SubjectTeacherUpdateManyWithoutTeacherNestedInput
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    subjects?: SubjectTeacherUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassSubjectCreateManyClassInput = {
    id?: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentClassCreateManyClassInput = {
    id?: string
    studentId: string
    sessionId: string
    rollNumber?: string | null
    status?: $Enums.EnrollmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassSubjectUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneRequiredWithoutClassesNestedInput
  }

  export type ClassSubjectUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassSubjectUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentClassUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: AcademicSessionUpdateOneRequiredWithoutStudentClassesNestedInput
    student?: StudentUpdateOneRequiredWithoutClassesNestedInput
  }

  export type StudentClassUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentClassUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassSubjectCreateManySubjectInput = {
    id?: string
    classId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResultCreateManySubjectInput = {
    id?: string
    studentId: string
    periodId: string
    sessionId: string
    total: number
    grade: string
    remark: string
    cumulativeAverage?: number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: string | null
    adminComment?: string | null
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSubjectCreateManySubjectInput = {
    id?: string
    studentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectTeacherCreateManySubjectInput = {
    id?: string
    teacherId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassSubjectUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutSubjectsNestedInput
  }

  export type ClassSubjectUncheckedUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassSubjectUncheckedUpdateManyWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remark?: StringFieldUpdateOperationsInput | string
    cumulativeAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: NullableStringFieldUpdateOperationsInput | string | null
    adminComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    componentScores?: ComponentScoreUpdateManyWithoutResultNestedInput
    student?: StudentUpdateOneRequiredWithoutResultsNestedInput
    period?: ResultPeriodUpdateOneRequiredWithoutResultsNestedInput
    session?: AcademicSessionUpdateOneRequiredWithoutResultsNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedResultsNestedInput
  }

  export type ResultUncheckedUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remark?: StringFieldUpdateOperationsInput | string
    cumulativeAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: NullableStringFieldUpdateOperationsInput | string | null
    adminComment?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    componentScores?: ComponentScoreUncheckedUpdateManyWithoutResultNestedInput
  }

  export type ResultUncheckedUpdateManyWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remark?: StringFieldUpdateOperationsInput | string
    cumulativeAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: NullableStringFieldUpdateOperationsInput | string | null
    adminComment?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSubjectUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutSubjectsNestedInput
  }

  export type StudentSubjectUncheckedUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSubjectUncheckedUpdateManyWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectTeacherUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneRequiredWithoutSubjectsNestedInput
  }

  export type SubjectTeacherUncheckedUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectTeacherUncheckedUpdateManyWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateManySessionInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    studentId: string
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResultCreateManySessionInput = {
    id?: string
    studentId: string
    subjectId: string
    periodId: string
    total: number
    grade: string
    remark: string
    cumulativeAverage?: number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: string | null
    adminComment?: string | null
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentClassCreateManySessionInput = {
    id?: string
    studentId: string
    classId: string
    rollNumber?: string | null
    status?: $Enums.EnrollmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResultConfigurationCreateManySessionInput = {
    id?: string
    schoolId: string
    cumulativeEnabled?: boolean
    cumulativeMethod?: string
    showCumulativePerTerm?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    studentId?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    studentId?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remark?: StringFieldUpdateOperationsInput | string
    cumulativeAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: NullableStringFieldUpdateOperationsInput | string | null
    adminComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    componentScores?: ComponentScoreUpdateManyWithoutResultNestedInput
    student?: StudentUpdateOneRequiredWithoutResultsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutResultsNestedInput
    period?: ResultPeriodUpdateOneRequiredWithoutResultsNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedResultsNestedInput
  }

  export type ResultUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remark?: StringFieldUpdateOperationsInput | string
    cumulativeAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: NullableStringFieldUpdateOperationsInput | string | null
    adminComment?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    componentScores?: ComponentScoreUncheckedUpdateManyWithoutResultNestedInput
  }

  export type ResultUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remark?: StringFieldUpdateOperationsInput | string
    cumulativeAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: NullableStringFieldUpdateOperationsInput | string | null
    adminComment?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentClassUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutStudentsNestedInput
    student?: StudentUpdateOneRequiredWithoutClassesNestedInput
  }

  export type StudentClassUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentClassUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultConfigurationUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    cumulativeEnabled?: BoolFieldUpdateOperationsInput | boolean
    cumulativeMethod?: StringFieldUpdateOperationsInput | string
    showCumulativePerTerm?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    periods?: ResultPeriodUpdateManyWithoutConfigurationNestedInput
    assessmentComponents?: AssessmentComponentUpdateManyWithoutConfigurationNestedInput
    gradingScale?: GradingScaleUpdateManyWithoutConfigurationNestedInput
    school?: SchoolUpdateOneRequiredWithoutResultConfigsNestedInput
  }

  export type ResultConfigurationUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    cumulativeEnabled?: BoolFieldUpdateOperationsInput | boolean
    cumulativeMethod?: StringFieldUpdateOperationsInput | string
    showCumulativePerTerm?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    periods?: ResultPeriodUncheckedUpdateManyWithoutConfigurationNestedInput
    assessmentComponents?: AssessmentComponentUncheckedUpdateManyWithoutConfigurationNestedInput
    gradingScale?: GradingScaleUncheckedUpdateManyWithoutConfigurationNestedInput
  }

  export type ResultConfigurationUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    cumulativeEnabled?: BoolFieldUpdateOperationsInput | boolean
    cumulativeMethod?: StringFieldUpdateOperationsInput | string
    showCumulativePerTerm?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComponentScoreCreateManyResultInput = {
    id?: string
    score: number
    componentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComponentScoreUpdateWithoutResultInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    component?: AssessmentComponentUpdateOneRequiredWithoutScoresNestedInput
  }

  export type ComponentScoreUncheckedUpdateWithoutResultInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    componentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComponentScoreUncheckedUpdateManyWithoutResultInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    componentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillAssignmentCreateManyBillInput = {
    id?: string
    targetType: $Enums.BillAssignmentType
    targetId: string
    dueDate: Date | string
    status?: $Enums.BillStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillItemCreateManyBillInput = {
    id?: string
    name: string
    amount: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentRequestCreateManyBillInput = {
    id?: string
    billAssignmentId: string
    studentPaymentId?: string | null
    studentId: string
    amount: number
    receiptUrl?: string | null
    status?: $Enums.PaymentStatus
    notes?: string | null
    processedById?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillAssignmentUpdateWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumBillAssignmentTypeFieldUpdateOperationsInput | $Enums.BillAssignmentType
    targetId?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentRequests?: PaymentRequestUpdateManyWithoutBillAssignmentNestedInput
    studentPayments?: StudentPaymentUpdateManyWithoutBillAssignmentNestedInput
  }

  export type BillAssignmentUncheckedUpdateWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumBillAssignmentTypeFieldUpdateOperationsInput | $Enums.BillAssignmentType
    targetId?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentRequests?: PaymentRequestUncheckedUpdateManyWithoutBillAssignmentNestedInput
    studentPayments?: StudentPaymentUncheckedUpdateManyWithoutBillAssignmentNestedInput
  }

  export type BillAssignmentUncheckedUpdateManyWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumBillAssignmentTypeFieldUpdateOperationsInput | $Enums.BillAssignmentType
    targetId?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillItemUpdateWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillItemUncheckedUpdateWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillItemUncheckedUpdateManyWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentRequestUpdateWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billAssignment?: BillAssignmentUpdateOneRequiredWithoutPaymentRequestsNestedInput
    processedBy?: UserUpdateOneWithoutProcessedPaymentsNestedInput
    student?: StudentUpdateOneRequiredWithoutPaymentRequestsNestedInput
    studentPayment?: StudentPaymentUpdateOneWithoutPaymentRequestsNestedInput
  }

  export type PaymentRequestUncheckedUpdateWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    billAssignmentId?: StringFieldUpdateOperationsInput | string
    studentPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentRequestUncheckedUpdateManyWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    billAssignmentId?: StringFieldUpdateOperationsInput | string
    studentPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillCreateManyAccountInput = {
    id?: string
    name: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schoolId: string
  }

  export type BillUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutBillsNestedInput
    assignments?: BillAssignmentUpdateManyWithoutBillNestedInput
    items?: BillItemUpdateManyWithoutBillNestedInput
    paymentRequests?: PaymentRequestUpdateManyWithoutBillNestedInput
  }

  export type BillUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolId?: StringFieldUpdateOperationsInput | string
    assignments?: BillAssignmentUncheckedUpdateManyWithoutBillNestedInput
    items?: BillItemUncheckedUpdateManyWithoutBillNestedInput
    paymentRequests?: PaymentRequestUncheckedUpdateManyWithoutBillNestedInput
  }

  export type BillUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolId?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentRequestCreateManyBillAssignmentInput = {
    id?: string
    billId: string
    studentPaymentId?: string | null
    studentId: string
    amount: number
    receiptUrl?: string | null
    status?: $Enums.PaymentStatus
    notes?: string | null
    processedById?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentPaymentCreateManyBillAssignmentInput = {
    id?: string
    studentId: string
    amountPaid: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentRequestUpdateWithoutBillAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bill?: BillUpdateOneRequiredWithoutPaymentRequestsNestedInput
    processedBy?: UserUpdateOneWithoutProcessedPaymentsNestedInput
    student?: StudentUpdateOneRequiredWithoutPaymentRequestsNestedInput
    studentPayment?: StudentPaymentUpdateOneWithoutPaymentRequestsNestedInput
  }

  export type PaymentRequestUncheckedUpdateWithoutBillAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    billId?: StringFieldUpdateOperationsInput | string
    studentPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentRequestUncheckedUpdateManyWithoutBillAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    billId?: StringFieldUpdateOperationsInput | string
    studentPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentPaymentUpdateWithoutBillAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentRequests?: PaymentRequestUpdateManyWithoutStudentPaymentNestedInput
    student?: StudentUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type StudentPaymentUncheckedUpdateWithoutBillAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentRequests?: PaymentRequestUncheckedUpdateManyWithoutStudentPaymentNestedInput
  }

  export type StudentPaymentUncheckedUpdateManyWithoutBillAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentRequestCreateManyStudentPaymentInput = {
    id?: string
    billId: string
    billAssignmentId: string
    studentId: string
    amount: number
    receiptUrl?: string | null
    status?: $Enums.PaymentStatus
    notes?: string | null
    processedById?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentRequestUpdateWithoutStudentPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billAssignment?: BillAssignmentUpdateOneRequiredWithoutPaymentRequestsNestedInput
    bill?: BillUpdateOneRequiredWithoutPaymentRequestsNestedInput
    processedBy?: UserUpdateOneWithoutProcessedPaymentsNestedInput
    student?: StudentUpdateOneRequiredWithoutPaymentRequestsNestedInput
  }

  export type PaymentRequestUncheckedUpdateWithoutStudentPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    billId?: StringFieldUpdateOperationsInput | string
    billAssignmentId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentRequestUncheckedUpdateManyWithoutStudentPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    billId?: StringFieldUpdateOperationsInput | string
    billAssignmentId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassCreateManyLevelInput = {
    id?: string
    name: string
    section?: string | null
    schoolId: string
    teacherId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectCreateManyLevelInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    schoolId: string
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassUpdateWithoutLevelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    teacher?: TeacherUpdateOneWithoutClassesNestedInput
    subjects?: ClassSubjectUpdateManyWithoutClassNestedInput
    students?: StudentClassUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutLevelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: ClassSubjectUncheckedUpdateManyWithoutClassNestedInput
    students?: StudentClassUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateManyWithoutLevelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectUpdateWithoutLevelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassSubjectUpdateManyWithoutSubjectNestedInput
    results?: ResultUpdateManyWithoutSubjectNestedInput
    students?: StudentSubjectUpdateManyWithoutSubjectNestedInput
    department?: DepartmentUpdateOneWithoutSubjectsNestedInput
    school?: SchoolUpdateOneRequiredWithoutSubjectsNestedInput
    teachers?: SubjectTeacherUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutLevelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    results?: ResultUncheckedUpdateManyWithoutSubjectNestedInput
    students?: StudentSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    teachers?: SubjectTeacherUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateManyWithoutLevelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultPeriodCreateManyConfigurationInput = {
    id?: string
    name: string
    weight?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssessmentComponentCreateManyConfigurationInput = {
    id?: string
    name: string
    key: string
    maxScore: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GradingScaleCreateManyConfigurationInput = {
    id?: string
    minScore: number
    maxScore: number
    grade: string
    remark: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResultPeriodUpdateWithoutConfigurationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: ResultUpdateManyWithoutPeriodNestedInput
  }

  export type ResultPeriodUncheckedUpdateWithoutConfigurationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: ResultUncheckedUpdateManyWithoutPeriodNestedInput
  }

  export type ResultPeriodUncheckedUpdateManyWithoutConfigurationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentComponentUpdateWithoutConfigurationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    maxScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scores?: ComponentScoreUpdateManyWithoutComponentNestedInput
  }

  export type AssessmentComponentUncheckedUpdateWithoutConfigurationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    maxScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scores?: ComponentScoreUncheckedUpdateManyWithoutComponentNestedInput
  }

  export type AssessmentComponentUncheckedUpdateManyWithoutConfigurationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    maxScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradingScaleUpdateWithoutConfigurationInput = {
    id?: StringFieldUpdateOperationsInput | string
    minScore?: FloatFieldUpdateOperationsInput | number
    maxScore?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remark?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradingScaleUncheckedUpdateWithoutConfigurationInput = {
    id?: StringFieldUpdateOperationsInput | string
    minScore?: FloatFieldUpdateOperationsInput | number
    maxScore?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remark?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradingScaleUncheckedUpdateManyWithoutConfigurationInput = {
    id?: StringFieldUpdateOperationsInput | string
    minScore?: FloatFieldUpdateOperationsInput | number
    maxScore?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remark?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultCreateManyPeriodInput = {
    id?: string
    studentId: string
    subjectId: string
    sessionId: string
    total: number
    grade: string
    remark: string
    cumulativeAverage?: number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: string | null
    adminComment?: string | null
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResultUpdateWithoutPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remark?: StringFieldUpdateOperationsInput | string
    cumulativeAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: NullableStringFieldUpdateOperationsInput | string | null
    adminComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    componentScores?: ComponentScoreUpdateManyWithoutResultNestedInput
    student?: StudentUpdateOneRequiredWithoutResultsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutResultsNestedInput
    session?: AcademicSessionUpdateOneRequiredWithoutResultsNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedResultsNestedInput
  }

  export type ResultUncheckedUpdateWithoutPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remark?: StringFieldUpdateOperationsInput | string
    cumulativeAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: NullableStringFieldUpdateOperationsInput | string | null
    adminComment?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    componentScores?: ComponentScoreUncheckedUpdateManyWithoutResultNestedInput
  }

  export type ResultUncheckedUpdateManyWithoutPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remark?: StringFieldUpdateOperationsInput | string
    cumulativeAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    affectiveTraits?: NullableJsonNullValueInput | InputJsonValue
    psychomotorSkills?: NullableJsonNullValueInput | InputJsonValue
    customFields?: NullableJsonNullValueInput | InputJsonValue
    teacherComment?: NullableStringFieldUpdateOperationsInput | string | null
    adminComment?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComponentScoreCreateManyComponentInput = {
    id?: string
    score: number
    resultId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComponentScoreUpdateWithoutComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    result?: ResultUpdateOneRequiredWithoutComponentScoresNestedInput
  }

  export type ComponentScoreUncheckedUpdateWithoutComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    resultId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComponentScoreUncheckedUpdateManyWithoutComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    resultId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}